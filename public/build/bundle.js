
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop$1(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
    // at the end of hydration without touching the remaining nodes.
    let is_hydrating = false;
    function start_hydrating() {
        is_hydrating = true;
    }
    function end_hydrating() {
        is_hydrating = false;
    }
    function upper_bound(low, high, key, value) {
        // Return first index of value larger than input value in the range [low, high)
        while (low < high) {
            const mid = low + ((high - low) >> 1);
            if (key(mid) <= value) {
                low = mid + 1;
            }
            else {
                high = mid;
            }
        }
        return low;
    }
    function init_hydrate(target) {
        if (target.hydrate_init)
            return;
        target.hydrate_init = true;
        // We know that all children have claim_order values since the unclaimed have been detached
        const children = target.childNodes;
        /*
        * Reorder claimed children optimally.
        * We can reorder claimed children optimally by finding the longest subsequence of
        * nodes that are already claimed in order and only moving the rest. The longest
        * subsequence subsequence of nodes that are claimed in order can be found by
        * computing the longest increasing subsequence of .claim_order values.
        *
        * This algorithm is optimal in generating the least amount of reorder operations
        * possible.
        *
        * Proof:
        * We know that, given a set of reordering operations, the nodes that do not move
        * always form an increasing subsequence, since they do not move among each other
        * meaning that they must be already ordered among each other. Thus, the maximal
        * set of nodes that do not move form a longest increasing subsequence.
        */
        // Compute longest increasing subsequence
        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
        const m = new Int32Array(children.length + 1);
        // Predecessor indices + 1
        const p = new Int32Array(children.length);
        m[0] = -1;
        let longest = 0;
        for (let i = 0; i < children.length; i++) {
            const current = children[i].claim_order;
            // Find the largest subsequence length such that it ends in a value less than our current value
            // upper_bound returns first greater value, so we subtract one
            const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;
            p[i] = m[seqLen] + 1;
            const newLen = seqLen + 1;
            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
            m[newLen] = i;
            longest = Math.max(newLen, longest);
        }
        // The longest increasing subsequence of nodes (initially reversed)
        const lis = [];
        // The rest of the nodes, nodes that will be moved
        const toMove = [];
        let last = children.length - 1;
        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
            lis.push(children[cur - 1]);
            for (; last >= cur; last--) {
                toMove.push(children[last]);
            }
            last--;
        }
        for (; last >= 0; last--) {
            toMove.push(children[last]);
        }
        lis.reverse();
        // We sort the nodes being moved to guarantee that their insertion order matches the claim order
        toMove.sort((a, b) => a.claim_order - b.claim_order);
        // Finally, we move the nodes
        for (let i = 0, j = 0; i < toMove.length; i++) {
            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
                j++;
            }
            const anchor = j < lis.length ? lis[j] : null;
            target.insertBefore(toMove[i], anchor);
        }
    }
    function append(target, node) {
        if (is_hydrating) {
            init_hydrate(target);
            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
                target.actual_end_child = target.firstChild;
            }
            if (node !== target.actual_end_child) {
                target.insertBefore(node, target.actual_end_child);
            }
            else {
                target.actual_end_child = node.nextSibling;
            }
        }
        else if (node.parentNode !== target) {
            target.appendChild(node);
        }
    }
    function insert(target, node, anchor) {
        if (is_hydrating && !anchor) {
            append(target, node);
        }
        else if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {
            target.insertBefore(node, anchor || null);
        }
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
        // Try to find nodes in an order such that we lengthen the longest increasing subsequence
        if (nodes.claim_info === undefined) {
            nodes.claim_info = { last_index: 0, total_claimed: 0 };
        }
        const resultNode = (() => {
            // We first try to find an element after the previous one
            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
                const node = nodes[i];
                if (predicate(node)) {
                    processNode(node);
                    nodes.splice(i, 1);
                    if (!dontUpdateLastIndex) {
                        nodes.claim_info.last_index = i;
                    }
                    return node;
                }
            }
            // Otherwise, we try to find one before
            // We iterate in reverse so that we don't go too far back
            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
                const node = nodes[i];
                if (predicate(node)) {
                    processNode(node);
                    nodes.splice(i, 1);
                    if (!dontUpdateLastIndex) {
                        nodes.claim_info.last_index = i;
                    }
                    else {
                        // Since we spliced before the last_index, we decrease it
                        nodes.claim_info.last_index--;
                    }
                    return node;
                }
            }
            // If we can't find any matching node, we create a new one
            return createNode();
        })();
        resultNode.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
        return resultNode;
    }
    function claim_element(nodes, name, attributes, svg) {
        return claim_node(nodes, (node) => node.nodeName === name, (node) => {
            const remove = [];
            for (let j = 0; j < node.attributes.length; j++) {
                const attribute = node.attributes[j];
                if (!attributes[attribute.name]) {
                    remove.push(attribute.name);
                }
            }
            remove.forEach(v => node.removeAttribute(v));
        }, () => svg ? svg_element(name) : element(name));
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(claimed_nodes) {
            this.e = this.n = null;
            this.l = claimed_nodes;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                if (this.l) {
                    this.n = this.l;
                }
                else {
                    this.h(html);
                }
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop$1(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop$1(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop$1(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                start_hydrating();
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            end_hydrating();
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.3' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const LOCATION = {};
    const ROUTER = {};

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    function getLocation(source) {
      return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial"
      };
    }

    function createHistory(source, options) {
      const listeners = [];
      let location = getLocation(source);

      return {
        get location() {
          return location;
        },

        listen(listener) {
          listeners.push(listener);

          const popstateListener = () => {
            location = getLocation(source);
            listener({ location, action: "POP" });
          };

          source.addEventListener("popstate", popstateListener);

          return () => {
            source.removeEventListener("popstate", popstateListener);

            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
          };
        },

        navigate(to, { state, replace = false } = {}) {
          state = { ...state, key: Date.now() + "" };
          // try...catch iOS Safari limits to 100 pushState calls
          try {
            if (replace) {
              source.history.replaceState(state, null, to);
            } else {
              source.history.pushState(state, null, to);
            }
          } catch (e) {
            source.location[replace ? "replace" : "assign"](to);
          }

          location = getLocation(source);
          listeners.forEach(listener => listener({ location, action: "PUSH" }));
        }
      };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
      let index = 0;
      const stack = [{ pathname: initialPathname, search: "" }];
      const states = [];

      return {
        get location() {
          return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
          get entries() {
            return stack;
          },
          get index() {
            return index;
          },
          get state() {
            return states[index];
          },
          pushState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            index++;
            stack.push({ pathname, search });
            states.push(state);
          },
          replaceState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            stack[index] = { pathname, search };
            states[index] = state;
          }
        }
      };
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = Boolean(
      typeof window !== "undefined" &&
        window.document &&
        window.document.createElement
    );
    const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
    const { navigate } = globalHistory;

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    const paramRe = /^:(.+)/;

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    function startsWith(string, search) {
      return string.substr(0, search.length) === search;
    }

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    function isRootSegment(segment) {
      return segment === "";
    }

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    function isDynamic(segment) {
      return paramRe.test(segment);
    }

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    function isSplat(segment) {
      return segment[0] === "*";
    }

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri) {
      return (
        uri
          // Strip starting/ending `/`
          .replace(/(^\/+|\/+$)/g, "")
          .split("/")
      );
    }

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    function stripSlashes(str) {
      return str.replace(/(^\/+|\/+$)/g, "");
    }

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
      const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
            score += SEGMENT_POINTS;

            if (isRootSegment(segment)) {
              score += ROOT_POINTS;
            } else if (isDynamic(segment)) {
              score += DYNAMIC_POINTS;
            } else if (isSplat(segment)) {
              score -= SEGMENT_POINTS + SPLAT_PENALTY;
            } else {
              score += STATIC_POINTS;
            }

            return score;
          }, 0);

      return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
      return (
        routes
          .map(rankRoute)
          // If two routes have the exact same score, we go by index instead
          .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
          )
      );
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { path, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
      let match;
      let default_;

      const [uriPathname] = uri.split("?");
      const uriSegments = segmentize(uriPathname);
      const isRootUri = uriSegments[0] === "";
      const ranked = rankRoutes(routes);

      for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
          default_ = {
            route,
            params: {},
            uri
          };
          continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
          const routeSegment = routeSegments[index];
          const uriSegment = uriSegments[index];

          if (routeSegment !== undefined && isSplat(routeSegment)) {
            // Hit a splat, just grab the rest, and return a match
            // uri:   /files/documents/work
            // route: /files/* or /files/*splatname
            const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

            params[splatName] = uriSegments
              .slice(index)
              .map(decodeURIComponent)
              .join("/");
            break;
          }

          if (uriSegment === undefined) {
            // URI is shorter than the route, no match
            // uri:   /users
            // route: /users/:userId
            missed = true;
            break;
          }

          let dynamicMatch = paramRe.exec(routeSegment);

          if (dynamicMatch && !isRootUri) {
            const value = decodeURIComponent(uriSegment);
            params[dynamicMatch[1]] = value;
          } else if (routeSegment !== uriSegment) {
            // Current segments don't match, not dynamic, not splat, so no match
            // uri:   /users/123/settings
            // route: /users/:id/profile
            missed = true;
            break;
          }
        }

        if (!missed) {
          match = {
            route,
            params,
            uri: "/" + uriSegments.slice(0, index).join("/")
          };
          break;
        }
      }

      return match || default_ || null;
    }

    /**
     * Check if the `path` matches the `uri`.
     * @param {string} path
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
      return pick([route], uri);
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    function addQuery(pathname, query) {
      return pathname + (query ? `?${query}` : "");
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
      // /foo/bar, /baz/qux => /foo/bar
      if (startsWith(to, "/")) {
        return to;
      }

      const [toPathname, toQuery] = to.split("?");
      const [basePathname] = base.split("?");
      const toSegments = segmentize(toPathname);
      const baseSegments = segmentize(basePathname);

      // ?a=b, /users?b=c => /users?a=b
      if (toSegments[0] === "") {
        return addQuery(basePathname, toQuery);
      }

      // profile, /users/789 => /users/789/profile
      if (!startsWith(toSegments[0], ".")) {
        const pathname = baseSegments.concat(toSegments).join("/");

        return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
      }

      // ./       , /users/123 => /users/123
      // ../      , /users/123 => /users
      // ../..    , /users/123 => /
      // ../../one, /a/b/c/d   => /a/b/one
      // .././one , /a/b/c/d   => /a/b/c/one
      const allSegments = baseSegments.concat(toSegments);
      const segments = [];

      allSegments.forEach(segment => {
        if (segment === "..") {
          segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });

      return addQuery("/" + segments.join("/"), toQuery);
    }

    /**
     * Combines the `basepath` and the `path` into one path.
     * @param {string} basepath
     * @param {string} path
     */
    function combinePaths(basepath, path) {
      return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
    }

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
      return (
        !event.defaultPrevented &&
        event.button === 0 &&
        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
      );
    }

    /* node_modules\svelte-routing\src\Router.svelte generated by Svelte v3.38.3 */

    function create_fragment$1Q(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let $routes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { basepath = "/" } = $$props;
    	let { url = null } = $$props;
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate(7, $routes = value));
    	const activeRoute = writable(null);
    	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

    	// If locationContext is not set, this is the topmost Router in the tree.
    	// If the `url` prop is given we force the location to it.
    	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(6, $location = value));

    	// If routerContext is set, the routerBase of the parent Router
    	// will be the base for this Router's descendants.
    	// If routerContext is not set, the path and resolved uri will both
    	// have the value of the basepath prop.
    	const base = routerContext
    	? routerContext.routerBase
    	: writable({ path: basepath, uri: basepath });

    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(5, $base = value));

    	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    		// If there is no activeRoute, the routerBase will be identical to the base.
    		if (activeRoute === null) {
    			return base;
    		}

    		const { path: basepath } = base;
    		const { route, uri } = activeRoute;

    		// Remove the potential /* or /*splatname from
    		// the end of the child Routes relative paths.
    		const path = route.default
    		? basepath
    		: route.path.replace(/\*.*$/, "");

    		return { path, uri };
    	});

    	function registerRoute(route) {
    		const { path: basepath } = $base;
    		let { path } = route;

    		// We store the original path in the _path property so we can reuse
    		// it when the basepath changes. The only thing that matters is that
    		// the route reference is intact, so mutation is fine.
    		route._path = path;

    		route.path = combinePaths(basepath, path);

    		if (typeof window === "undefined") {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				activeRoute.set(matchingRoute);
    				hasActiveRoute = true;
    			}
    		} else {
    			routes.update(rs => {
    				rs.push(route);
    				return rs;
    			});
    		}
    	}

    	function unregisterRoute(route) {
    		routes.update(rs => {
    			const index = rs.indexOf(route);
    			rs.splice(index, 1);
    			return rs;
    		});
    	}

    	if (!locationContext) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = globalHistory.listen(history => {
    				location.set(history.location);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute
    	});

    	const writable_props = ["basepath", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		derived,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		pick,
    		match,
    		stripSlashes,
    		combinePaths,
    		basepath,
    		url,
    		locationContext,
    		routerContext,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		location,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute,
    		$base,
    		$location,
    		$routes
    	});

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$base*/ 32) {
    			// This reactive statement will update all the Routes' path when
    			// the basepath changes.
    			{
    				const { path: basepath } = $base;

    				routes.update(rs => {
    					rs.forEach(r => r.path = combinePaths(basepath, r._path));
    					return rs;
    				});
    			}
    		}

    		if ($$self.$$.dirty & /*$routes, $location*/ 192) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}
    	};

    	return [
    		routes,
    		location,
    		base,
    		basepath,
    		url,
    		$base,
    		$location,
    		$routes,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, { basepath: 3, url: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1Q.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-routing\src\Route.svelte generated by Svelte v3.38.3 */

    const get_default_slot_changes$1 = dirty => ({
    	params: dirty & /*routeParams*/ 4,
    	location: dirty & /*$location*/ 16
    });

    const get_default_slot_context$1 = ctx => ({
    	params: /*routeParams*/ ctx[2],
    	location: /*$location*/ ctx[4]
    });

    // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
    function create_if_block$I(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$y, create_else_block$u];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {:else}
    function create_else_block$u(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, routeParams, $location*/ 532)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], !current ? -1 : dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$u.name,
    		type: "else",
    		source: "(43:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if component !== null}
    function create_if_block_1$y(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[4] },
    		/*routeParams*/ ctx[2],
    		/*routeProps*/ ctx[3]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 28)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
    					dirty & /*routeParams*/ 4 && get_spread_object(/*routeParams*/ ctx[2]),
    					dirty & /*routeProps*/ 8 && get_spread_object(/*routeProps*/ ctx[3])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$y.name,
    		type: "if",
    		source: "(41:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1P(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7] && create_if_block$I(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activeRoute*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$I(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Route", slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

    	const route = {
    		path,
    		// If no path prop is given, this Route will act as the default Route
    		// that is rendered if no other Route in the Router is a match.
    		default: path === ""
    	};

    	let routeParams = {};
    	let routeProps = {};
    	registerRoute(route);

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway.
    	if (typeof window !== "undefined") {
    		onDestroy(() => {
    			unregisterRoute(route);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onDestroy,
    		ROUTER,
    		LOCATION,
    		path,
    		component,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		location,
    		route,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
    		if ("routeParams" in $$props) $$invalidate(2, routeParams = $$new_props.routeParams);
    		if ("routeProps" in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeRoute*/ 2) {
    			if ($activeRoute && $activeRoute.route === route) {
    				$$invalidate(2, routeParams = $activeRoute.params);
    			}
    		}

    		{
    			const { path, component, ...rest } = $$props;
    			$$invalidate(3, routeProps = rest);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		$activeRoute,
    		routeParams,
    		routeProps,
    		$location,
    		activeRoute,
    		location,
    		route,
    		path,
    		$$scope,
    		slots
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, { path: 8, component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$1P.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-routing\src\Link.svelte generated by Svelte v3.38.3 */
    const file$_ = "node_modules\\svelte-routing\\src\\Link.svelte";

    function create_fragment$1O(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[16].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

    	let a_levels = [
    		{ href: /*href*/ ctx[0] },
    		{ "aria-current": /*ariaCurrent*/ ctx[2] },
    		/*props*/ ctx[1],
    		/*$$restProps*/ ctx[6]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$_, 40, 0, 1249);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], !current ? -1 : dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				(!current || dirty & /*ariaCurrent*/ 4) && { "aria-current": /*ariaCurrent*/ ctx[2] },
    				dirty & /*props*/ 2 && /*props*/ ctx[1],
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let ariaCurrent;
    	const omit_props_names = ["to","replace","state","getProps"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $base;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Link", slots, ['default']);
    	let { to = "#" } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = () => ({}) } = $$props;
    	const { base } = getContext(ROUTER);
    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(13, $base = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(14, $location = value));
    	const dispatch = createEventDispatcher();
    	let href, isPartiallyCurrent, isCurrent, props;

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();

    			// Don't push another entry to the history stack when the user
    			// clicks on a Link to the page they are currently on.
    			const shouldReplace = $location.pathname === href || replace;

    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("to" in $$new_props) $$invalidate(7, to = $$new_props.to);
    		if ("replace" in $$new_props) $$invalidate(8, replace = $$new_props.replace);
    		if ("state" in $$new_props) $$invalidate(9, state = $$new_props.state);
    		if ("getProps" in $$new_props) $$invalidate(10, getProps = $$new_props.getProps);
    		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		createEventDispatcher,
    		ROUTER,
    		LOCATION,
    		navigate,
    		startsWith,
    		resolve,
    		shouldNavigate,
    		to,
    		replace,
    		state,
    		getProps,
    		base,
    		location,
    		dispatch,
    		href,
    		isPartiallyCurrent,
    		isCurrent,
    		props,
    		onClick,
    		$base,
    		$location,
    		ariaCurrent
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("to" in $$props) $$invalidate(7, to = $$new_props.to);
    		if ("replace" in $$props) $$invalidate(8, replace = $$new_props.replace);
    		if ("state" in $$props) $$invalidate(9, state = $$new_props.state);
    		if ("getProps" in $$props) $$invalidate(10, getProps = $$new_props.getProps);
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("isPartiallyCurrent" in $$props) $$invalidate(11, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
    		if ("isCurrent" in $$props) $$invalidate(12, isCurrent = $$new_props.isCurrent);
    		if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
    		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$new_props.ariaCurrent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*to, $base*/ 8320) {
    			$$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
    		}

    		if ($$self.$$.dirty & /*$location, href*/ 16385) {
    			$$invalidate(11, isPartiallyCurrent = startsWith($location.pathname, href));
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 16385) {
    			$$invalidate(12, isCurrent = href === $location.pathname);
    		}

    		if ($$self.$$.dirty & /*isCurrent*/ 4096) {
    			$$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
    		}

    		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 23553) {
    			$$invalidate(1, props = getProps({
    				location: $location,
    				href,
    				isPartiallyCurrent,
    				isCurrent
    			}));
    		}
    	};

    	return [
    		href,
    		props,
    		ariaCurrent,
    		base,
    		location,
    		onClick,
    		$$restProps,
    		to,
    		replace,
    		state,
    		getProps,
    		isPartiallyCurrent,
    		isCurrent,
    		$base,
    		$location,
    		$$scope,
    		slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {
    			to: 7,
    			replace: 8,
    			state: 9,
    			getProps: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$1O.name
    		});
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Debug toggle for development
    let debugMode = writable(false);

    // Attempt to obtain the Ampache server installation based on requested path
    let detectedURL = (window.location.origin + window.location.pathname).split(/\/ample/)[0];

    // Fallback to old version
    let APIVersion = writable("350001");

    const serverURL = readable(detectedURL, function start(set) {
        // local testing override
        // detectedURL = "http://ampache-preview";

        // stable demo server override
        // detectedURL = "https://demo.ampache.dev";

        // develop demo server override
        // detectedURL = "https://develop.ampache.dev";

        set(detectedURL);
        return function stop() {};
    });

    let serverVersion = writable('');

    let serverTotals = writable([]);

    let allArtists = writable({});
    let artistIndex = derived(
        allArtists,
        $allArtists => {
            if ($allArtists.loaded) {
                let usedChars = new Map();

                // Add a catchall for numbers and non-word chars
                usedChars.set("#", []);

                // find unique starting characters
                for (let i = 0; i < $allArtists.data.length; i++) {
                    let char = $allArtists.data[i].name.charAt(0).toLowerCase();

                    // if digit or non-word char, skip adding to map
                    if (/^((\d|\W))/i.test(char)) {
                        continue;
                    }

                    if (!usedChars.get(char)) {
                        usedChars.set(char, []);
                    }
                }


                // work out counts for artists and album artists
                usedChars.forEach((value, key) => {
                    let artistCount;
                    let albumArtistCount;

                    let code = key.replaceAll("#", "(\\d|\\W)");

                    artistCount = $allArtists.data.filter(function(a) {
                        let regex = new RegExp("^" + code, "i");
                        return regex.test(a.name);
                    });

                    albumArtistCount = artistCount.filter(a => a.albumcount > 0);

                    usedChars.set(key, {artistCount: artistCount.length, albumArtistCount: albumArtistCount.length});
                });

                let sorted = new Map([...usedChars.entries()].sort());

                return sorted;
            }
        }
    );

    let allAlbums = writable({});
    let albumIndex = derived(
        allAlbums,
        $allAlbums => {
            if ($allAlbums.loaded) {
                let usedChars = new Map();

                // Add a catchall for numbers and non-word chars
                usedChars.set("#", []);

                // find unique starting characters
                for (let i = 0; i < $allAlbums.data.length; i++) {
                    let char = $allAlbums.data[i].name.charAt(0).toLowerCase();

                    // if digit or non-word char, skip adding to map
                    if (/^((\d|\W))/i.test(char)) {
                        continue;
                    }

                    if (!usedChars.get(char)) {
                        usedChars.set(char, []);
                    }
                }


                // work out counts for artists and album artists
                usedChars.forEach((value, key) => {
                    let albumCount;

                    let code = key.replaceAll("#", "(\\d|\\W)");

                    albumCount = $allAlbums.data.filter(function(a) {
                        let regex = new RegExp("^" + code, "i");
                        return regex.test(a.name);
                    });

                    usedChars.set(key, {albumCount: albumCount.length});
                });

                let sorted = new Map([...usedChars.entries()].sort());

                return sorted;
            }
        }
    );

    let userToken = writable(null);
    let userName = writable(null);
    let isLoggedIn = writable(null);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*!
     * wavesurfer.js 5.1.0 (2021-06-20)
     * https://wavesurfer-js.org
     * @license BSD-3-Clause
     */

    var wavesurfer = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (() => { // webpackBootstrap
    /******/ 	var __webpack_modules__ = ({

    /***/ "./src/drawer.canvasentry.js":
    /*!***********************************!*\
      !*** ./src/drawer.canvasentry.js ***!
      \***********************************/
    /***/ ((module, exports, __webpack_require__) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var _style = _interopRequireDefault(__webpack_require__(/*! ./util/style */ "./src/util/style.js"));

    var _getId = _interopRequireDefault(__webpack_require__(/*! ./util/get-id */ "./src/util/get-id.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * The `CanvasEntry` class represents an element consisting of a wave `canvas`
     * and an (optional) progress wave `canvas`.
     *
     * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
     * render a waveform, depending on the zoom level.
     */
    var CanvasEntry = /*#__PURE__*/function () {
      function CanvasEntry() {
        _classCallCheck(this, CanvasEntry);

        /**
         * The wave node
         *
         * @type {HTMLCanvasElement}
         */
        this.wave = null;
        /**
         * The wave canvas rendering context
         *
         * @type {CanvasRenderingContext2D}
         */

        this.waveCtx = null;
        /**
         * The (optional) progress wave node
         *
         * @type {HTMLCanvasElement}
         */

        this.progress = null;
        /**
         * The (optional) progress wave canvas rendering context
         *
         * @type {CanvasRenderingContext2D}
         */

        this.progressCtx = null;
        /**
         * Start of the area the canvas should render, between 0 and 1
         *
         * @type {number}
         */

        this.start = 0;
        /**
         * End of the area the canvas should render, between 0 and 1
         *
         * @type {number}
         */

        this.end = 1;
        /**
         * Unique identifier for this entry
         *
         * @type {string}
         */

        this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
        /**
         * Canvas 2d context attributes
         *
         * @type {object}
         */

        this.canvasContextAttributes = {};
      }
      /**
       * Store the wave canvas element and create the 2D rendering context
       *
       * @param {HTMLCanvasElement} element The wave `canvas` element.
       */


      _createClass(CanvasEntry, [{
        key: "initWave",
        value: function initWave(element) {
          this.wave = element;
          this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
        }
        /**
         * Store the progress wave canvas element and create the 2D rendering
         * context
         *
         * @param {HTMLCanvasElement} element The progress wave `canvas` element.
         */

      }, {
        key: "initProgress",
        value: function initProgress(element) {
          this.progress = element;
          this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
        }
        /**
         * Update the dimensions
         *
         * @param {number} elementWidth Width of the entry
         * @param {number} totalWidth Total width of the multi canvas renderer
         * @param {number} width The new width of the element
         * @param {number} height The new height of the element
         */

      }, {
        key: "updateDimensions",
        value: function updateDimensions(elementWidth, totalWidth, width, height) {
          // where the canvas starts and ends in the waveform, represented as a
          // decimal between 0 and 1
          this.start = this.wave.offsetLeft / totalWidth || 0;
          this.end = this.start + elementWidth / totalWidth; // set wave canvas dimensions

          this.wave.width = width;
          this.wave.height = height;
          var elementSize = {
            width: elementWidth + 'px'
          };
          (0, _style.default)(this.wave, elementSize);

          if (this.hasProgressCanvas) {
            // set progress canvas dimensions
            this.progress.width = width;
            this.progress.height = height;
            (0, _style.default)(this.progress, elementSize);
          }
        }
        /**
         * Clear the wave and progress rendering contexts
         */

      }, {
        key: "clearWave",
        value: function clearWave() {
          // wave
          this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height); // progress

          if (this.hasProgressCanvas) {
            this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
          }
        }
        /**
         * Set the fill styles for wave and progress
         *
         * @param {string} waveColor Fill color for the wave canvas
         * @param {?string} progressColor Fill color for the progress canvas
         */

      }, {
        key: "setFillStyles",
        value: function setFillStyles(waveColor, progressColor) {
          this.waveCtx.fillStyle = waveColor;

          if (this.hasProgressCanvas) {
            this.progressCtx.fillStyle = progressColor;
          }
        }
        /**
         * Set the canvas transforms for wave and progress
         *
         * @param {boolean} vertical Whether to render vertically
         */

      }, {
        key: "applyCanvasTransforms",
        value: function applyCanvasTransforms(vertical) {
          if (vertical) {
            // Reflect the waveform across the line y = -x
            this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);

            if (this.hasProgressCanvas) {
              this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);
            }
          }
        }
        /**
         * Draw a rectangle for wave and progress
         *
         * @param {number} x X start position
         * @param {number} y Y start position
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         */

      }, {
        key: "fillRects",
        value: function fillRects(x, y, width, height, radius) {
          this.fillRectToContext(this.waveCtx, x, y, width, height, radius);

          if (this.hasProgressCanvas) {
            this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
          }
        }
        /**
         * Draw the actual rectangle on a `canvas` element
         *
         * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
         * @param {number} x X start position
         * @param {number} y Y start position
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         */

      }, {
        key: "fillRectToContext",
        value: function fillRectToContext(ctx, x, y, width, height, radius) {
          if (!ctx) {
            return;
          }

          if (radius) {
            this.drawRoundedRect(ctx, x, y, width, height, radius);
          } else {
            ctx.fillRect(x, y, width, height);
          }
        }
        /**
         * Draw a rounded rectangle on Canvas
         *
         * @param {CanvasRenderingContext2D} ctx Canvas context
         * @param {number} x X-position of the rectangle
         * @param {number} y Y-position of the rectangle
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         *
         * @return {void}
         * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
         */

      }, {
        key: "drawRoundedRect",
        value: function drawRoundedRect(ctx, x, y, width, height, radius) {
          if (height === 0) {
            return;
          } // peaks are float values from -1 to 1. Use absolute height values in
          // order to correctly calculate rounded rectangle coordinates


          if (height < 0) {
            height *= -1;
            y -= height;
          }

          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
        }
        /**
         * Render the actual wave and progress lines
         *
         * @param {number[]} peaks Array with peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         */

      }, {
        key: "drawLines",
        value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
          this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);

          if (this.hasProgressCanvas) {
            this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
          }
        }
        /**
         * Render the actual waveform line on a `canvas` element
         *
         * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
         * @param {number[]} peaks Array with peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         */

      }, {
        key: "drawLineToContext",
        value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
          if (!ctx) {
            return;
          }

          var length = peaks.length / 2;
          var first = Math.round(length * this.start); // use one more peak value to make sure we join peaks at ends -- unless,
          // of course, this is the last canvas

          var last = Math.round(length * this.end) + 1;
          var canvasStart = first;
          var canvasEnd = last;
          var scale = this.wave.width / (canvasEnd - canvasStart - 1); // optimization

          var halfOffset = halfH + offsetY;
          var absmaxHalf = absmax / halfH;
          ctx.beginPath();
          ctx.moveTo((canvasStart - first) * scale, halfOffset);
          ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
          var i, peak, h;

          for (i = canvasStart; i < canvasEnd; i++) {
            peak = peaks[2 * i] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
          } // draw the bottom edge going backwards, to make a single
          // closed hull to fill


          var j = canvasEnd - 1;

          for (j; j >= canvasStart; j--) {
            peak = peaks[2 * j + 1] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
          }

          ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
          ctx.closePath();
          ctx.fill();
        }
        /**
         * Destroys this entry
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.waveCtx = null;
          this.wave = null;
          this.progressCtx = null;
          this.progress = null;
        }
        /**
         * Return image data of the wave `canvas` element
         *
         * When using a `type` of `'blob'`, this will return a `Promise` that
         * resolves with a `Blob` instance.
         *
         * @param {string} format='image/png' An optional value of a format type.
         * @param {number} quality=0.92 An optional value between 0 and 1.
         * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
         * @return {string|Promise} When using the default `'dataURL'` `type` this
         * returns a data URL. When using the `'blob'` `type` this returns a
         * `Promise` that resolves with a `Blob` instance.
         */

      }, {
        key: "getImage",
        value: function getImage(format, quality, type) {
          var _this = this;

          if (type === 'blob') {
            return new Promise(function (resolve) {
              _this.wave.toBlob(resolve, format, quality);
            });
          } else if (type === 'dataURL') {
            return this.wave.toDataURL(format, quality);
          }
        }
      }]);

      return CanvasEntry;
    }();

    exports.default = CanvasEntry;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/drawer.js":
    /*!***********************!*\
      !*** ./src/drawer.js ***!
      \***********************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

    function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * Parent class for renderers
     *
     * @extends {Observer}
     */
    var Drawer = /*#__PURE__*/function (_util$Observer) {
      _inherits(Drawer, _util$Observer);

      var _super = _createSuper(Drawer);

      /**
       * @param {HTMLElement} container The container node of the wavesurfer instance
       * @param {WavesurferParams} params The wavesurfer initialisation options
       */
      function Drawer(container, params) {
        var _this;

        _classCallCheck(this, Drawer);

        _this = _super.call(this);
        _this.container = util.withOrientation(container, params.vertical);
        /**
         * @type {WavesurferParams}
         */

        _this.params = params;
        /**
         * The width of the renderer
         * @type {number}
         */

        _this.width = 0;
        /**
         * The height of the renderer
         * @type {number}
         */

        _this.height = params.height * _this.params.pixelRatio;
        _this.lastPos = 0;
        /**
         * The `<wave>` element which is added to the container
         * @type {HTMLElement}
         */

        _this.wrapper = null;
        return _this;
      }
      /**
       * Alias of `util.style`
       *
       * @param {HTMLElement} el The element that the styles will be applied to
       * @param {Object} styles The map of propName: attribute, both are used as-is
       * @return {HTMLElement} el
       */


      _createClass(Drawer, [{
        key: "style",
        value: function style(el, styles) {
          return util.style(el, styles);
        }
        /**
         * Create the wrapper `<wave>` element, style it and set up the events for
         * interaction
         */

      }, {
        key: "createWrapper",
        value: function createWrapper() {
          this.wrapper = util.withOrientation(this.container.appendChild(document.createElement('wave')), this.params.vertical);
          this.style(this.wrapper, {
            display: 'block',
            position: 'relative',
            userSelect: 'none',
            webkitUserSelect: 'none',
            height: this.params.height + 'px'
          });

          if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
              width: '100%',
              overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
              overflowY: 'hidden'
            });
          }

          this.setupWrapperEvents();
        }
        /**
         * Handle click event
         *
         * @param {Event} e Click event
         * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
         * @return {number} Playback position from 0 to 1
         */

      }, {
        key: "handleEvent",
        value: function handleEvent(e, noPrevent) {
          !noPrevent && e.preventDefault();
          var clientX = util.withOrientation(e.targetTouches ? e.targetTouches[0] : e, this.params.vertical).clientX;
          var bbox = this.wrapper.getBoundingClientRect();
          var nominalWidth = this.width;
          var parentWidth = this.getWidth();
          var progressPixels = this.getProgressPixels(bbox, clientX);
          var progress;

          if (!this.params.fillParent && nominalWidth < parentWidth) {
            progress = progressPixels * (this.params.pixelRatio / nominalWidth) || 0;
          } else {
            progress = (progressPixels + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
          }

          return util.clamp(progress, 0, 1);
        }
      }, {
        key: "getProgressPixels",
        value: function getProgressPixels(wrapperBbox, clientX) {
          if (this.params.rtl) {
            return wrapperBbox.right - clientX;
          } else {
            return clientX - wrapperBbox.left;
          }
        }
      }, {
        key: "setupWrapperEvents",
        value: function setupWrapperEvents() {
          var _this2 = this;

          this.wrapper.addEventListener('click', function (e) {
            var orientedEvent = util.withOrientation(e, _this2.params.vertical);
            var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

            if (scrollbarHeight !== 0) {
              // scrollbar is visible.  Check if click was on it
              var bbox = _this2.wrapper.getBoundingClientRect();

              if (orientedEvent.clientY >= bbox.bottom - scrollbarHeight) {
                // ignore mousedown as it was on the scrollbar
                return;
              }
            }

            if (_this2.params.interact) {
              _this2.fireEvent('click', e, _this2.handleEvent(e));
            }
          });
          this.wrapper.addEventListener('dblclick', function (e) {
            if (_this2.params.interact) {
              _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
            }
          });
          this.wrapper.addEventListener('scroll', function (e) {
            return _this2.fireEvent('scroll', e);
          });
        }
        /**
         * Draw peaks on the canvas
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} length The width of the area that should be drawn
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawPeaks",
        value: function drawPeaks(peaks, length, start, end) {
          if (!this.setWidth(length)) {
            this.clearWave();
          }

          this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
        }
        /**
         * Scroll to the beginning
         */

      }, {
        key: "resetScroll",
        value: function resetScroll() {
          if (this.wrapper !== null) {
            this.wrapper.scrollLeft = 0;
          }
        }
        /**
         * Recenter the view-port at a certain percent of the waveform
         *
         * @param {number} percent Value from 0 to 1 on the waveform
         */

      }, {
        key: "recenter",
        value: function recenter(percent) {
          var position = this.wrapper.scrollWidth * percent;
          this.recenterOnPosition(position, true);
        }
        /**
         * Recenter the view-port on a position, either scroll there immediately or
         * in steps of 5 pixels
         *
         * @param {number} position X-offset in pixels
         * @param {boolean} immediate Set to true to immediately scroll somewhere
         */

      }, {
        key: "recenterOnPosition",
        value: function recenterOnPosition(position, immediate) {
          var scrollLeft = this.wrapper.scrollLeft;
          var half = ~~(this.wrapper.clientWidth / 2);
          var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
          var target = position - half;
          var offset = target - scrollLeft;

          if (maxScroll == 0) {
            // no need to continue if scrollbar is not there
            return;
          } // if the cursor is currently visible...


          if (!immediate && -half <= offset && offset < half) {
            // set rate at which waveform is centered
            var rate = this.params.autoCenterRate; // make rate depend on width of view and length of waveform

            rate /= half;
            rate *= maxScroll;
            offset = Math.max(-rate, Math.min(rate, offset));
            target = scrollLeft + offset;
          } // limit target to valid range (0 to maxScroll)


          target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

          if (target != scrollLeft) {
            this.wrapper.scrollLeft = target;
          }
        }
        /**
         * Get the current scroll position in pixels
         *
         * @return {number} Horizontal scroll position in pixels
         */

      }, {
        key: "getScrollX",
        value: function getScrollX() {
          var x = 0;

          if (this.wrapper) {
            var pixelRatio = this.params.pixelRatio;
            x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
            // scroll beyond the limits of the container
            // Calculate and floor the scrollable extent to make sure an out
            // of bounds value is not returned
            // Ticket #1312

            if (this.params.scrollParent) {
              var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
              x = Math.min(maxScroll, Math.max(0, x));
            }
          }

          return x;
        }
        /**
         * Get the width of the container
         *
         * @return {number} The width of the container
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return Math.round(this.container.clientWidth * this.params.pixelRatio);
        }
        /**
         * Set the width of the container
         *
         * @param {number} width The new width of the container
         * @return {boolean} Whether the width of the container was updated or not
         */

      }, {
        key: "setWidth",
        value: function setWidth(width) {
          if (this.width == width) {
            return false;
          }

          this.width = width;

          if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
              width: ''
            });
          } else {
            var newWidth = ~~(this.width / this.params.pixelRatio) + 'px';
            this.style(this.wrapper, {
              width: newWidth
            });
          }

          this.updateSize();
          return true;
        }
        /**
         * Set the height of the container
         *
         * @param {number} height The new height of the container.
         * @return {boolean} Whether the height of the container was updated or not
         */

      }, {
        key: "setHeight",
        value: function setHeight(height) {
          if (height == this.height) {
            return false;
          }

          this.height = height;
          this.style(this.wrapper, {
            height: ~~(this.height / this.params.pixelRatio) + 'px'
          });
          this.updateSize();
          return true;
        }
        /**
         * Called by wavesurfer when progress should be rendered
         *
         * @param {number} progress From 0 to 1
         */

      }, {
        key: "progress",
        value: function progress(_progress) {
          var minPxDelta = 1 / this.params.pixelRatio;
          var pos = Math.round(_progress * this.width) * minPxDelta;

          if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
            this.lastPos = pos;

            if (this.params.scrollParent && this.params.autoCenter) {
              var newPos = ~~(this.wrapper.scrollWidth * _progress);
              this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
            }

            this.updateProgress(pos);
          }
        }
        /**
         * This is called when wavesurfer is destroyed
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.unAll();

          if (this.wrapper) {
            if (this.wrapper.parentNode == this.container.domElement) {
              this.container.removeChild(this.wrapper.domElement);
            }

            this.wrapper = null;
          }
        }
        /* Renderer-specific methods */

        /**
         * Called after cursor related params have changed.
         *
         * @abstract
         */

      }, {
        key: "updateCursor",
        value: function updateCursor() {}
        /**
         * Called when the size of the container changes so the renderer can adjust
         *
         * @abstract
         */

      }, {
        key: "updateSize",
        value: function updateSize() {}
        /**
         * Draw a waveform with bars
         *
         * @abstract
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
         * rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawBars",
        value: function drawBars(peaks, channelIndex, start, end) {}
        /**
         * Draw a waveform
         *
         * @abstract
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
         * rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawWave",
        value: function drawWave(peaks, channelIndex, start, end) {}
        /**
         * Clear the waveform
         *
         * @abstract
         */

      }, {
        key: "clearWave",
        value: function clearWave() {}
        /**
         * Render the new progress
         *
         * @abstract
         * @param {number} position X-Offset of progress position in pixels
         */

      }, {
        key: "updateProgress",
        value: function updateProgress(position) {}
      }]);

      return Drawer;
    }(util.Observer);

    exports.default = Drawer;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/drawer.multicanvas.js":
    /*!***********************************!*\
      !*** ./src/drawer.multicanvas.js ***!
      \***********************************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer */ "./src/drawer.js"));

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    var _drawer2 = _interopRequireDefault(__webpack_require__(/*! ./drawer.canvasentry */ "./src/drawer.canvasentry.js"));

    function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

    function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MultiCanvas renderer for wavesurfer. Is currently the default and sole
     * builtin renderer.
     *
     * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
     * on the zoom level.
     */
    var MultiCanvas = /*#__PURE__*/function (_Drawer) {
      _inherits(MultiCanvas, _Drawer);

      var _super = _createSuper(MultiCanvas);

      /**
       * @param {HTMLElement} container The container node of the wavesurfer instance
       * @param {WavesurferParams} params The wavesurfer initialisation options
       */
      function MultiCanvas(container, params) {
        var _this;

        _classCallCheck(this, MultiCanvas);

        _this = _super.call(this, container, params);
        /**
         * @type {number}
         */

        _this.maxCanvasWidth = params.maxCanvasWidth;
        /**
         * @type {number}
         */

        _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
        /**
         * Whether or not the progress wave is rendered. If the `waveColor`
         * and `progressColor` are the same color it is not.
         *
         * @type {boolean}
         */

        _this.hasProgressCanvas = params.waveColor != params.progressColor;
        /**
         * @type {number}
         */

        _this.halfPixel = 0.5 / params.pixelRatio;
        /**
         * List of `CanvasEntry` instances.
         *
         * @type {Array}
         */

        _this.canvases = [];
        /**
         * @type {HTMLElement}
         */

        _this.progressWave = null;
        /**
         * Class used to generate entries.
         *
         * @type {function}
         */

        _this.EntryClass = _drawer2.default;
        /**
         * Canvas 2d context attributes.
         *
         * @type {object}
         */

        _this.canvasContextAttributes = params.drawingContextAttributes;
        /**
         * Overlap added between entries to prevent vertical white stripes
         * between `canvas` elements.
         *
         * @type {number}
         */

        _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
        /**
         * The radius of the wave bars. Makes bars rounded
         *
         * @type {number}
         */

        _this.barRadius = params.barRadius || 0;
        /**
         * Whether to render the waveform vertically. Defaults to false.
         *
         * @type {boolean}
         */

        _this.vertical = params.vertical;
        return _this;
      }
      /**
       * Initialize the drawer
       */


      _createClass(MultiCanvas, [{
        key: "init",
        value: function init() {
          this.createWrapper();
          this.createElements();
        }
        /**
         * Create the canvas elements and style them
         *
         */

      }, {
        key: "createElements",
        value: function createElements() {
          this.progressWave = util.withOrientation(this.wrapper.appendChild(document.createElement('wave')), this.params.vertical);
          this.style(this.progressWave, {
            position: 'absolute',
            zIndex: 3,
            left: 0,
            top: 0,
            bottom: 0,
            overflow: 'hidden',
            width: '0',
            display: 'none',
            boxSizing: 'border-box',
            borderRightStyle: 'solid',
            pointerEvents: 'none'
          });
          this.addCanvas();
          this.updateCursor();
        }
        /**
         * Update cursor style
         */

      }, {
        key: "updateCursor",
        value: function updateCursor() {
          this.style(this.progressWave, {
            borderRightWidth: this.params.cursorWidth + 'px',
            borderRightColor: this.params.cursorColor
          });
        }
        /**
         * Adjust to the updated size by adding or removing canvases
         */

      }, {
        key: "updateSize",
        value: function updateSize() {
          var _this2 = this;

          var totalWidth = Math.round(this.width / this.params.pixelRatio);
          var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap)); // add required canvases

          while (this.canvases.length < requiredCanvases) {
            this.addCanvas();
          } // remove older existing canvases, if any


          while (this.canvases.length > requiredCanvases) {
            this.removeCanvas();
          }

          var canvasWidth = this.maxCanvasWidth + this.overlap;
          var lastCanvas = this.canvases.length - 1;
          this.canvases.forEach(function (entry, i) {
            if (i == lastCanvas) {
              canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
            }

            _this2.updateDimensions(entry, canvasWidth, _this2.height);

            entry.clearWave();
          });
        }
        /**
         * Add a canvas to the canvas list
         *
         */

      }, {
        key: "addCanvas",
        value: function addCanvas() {
          var entry = new this.EntryClass();
          entry.canvasContextAttributes = this.canvasContextAttributes;
          entry.hasProgressCanvas = this.hasProgressCanvas;
          entry.halfPixel = this.halfPixel;
          var leftOffset = this.maxCanvasElementWidth * this.canvases.length; // wave

          var wave = util.withOrientation(this.wrapper.appendChild(document.createElement('canvas')), this.params.vertical);
          this.style(wave, {
            position: 'absolute',
            zIndex: 2,
            left: leftOffset + 'px',
            top: 0,
            bottom: 0,
            height: '100%',
            pointerEvents: 'none'
          });
          entry.initWave(wave); // progress

          if (this.hasProgressCanvas) {
            var progress = util.withOrientation(this.progressWave.appendChild(document.createElement('canvas')), this.params.vertical);
            this.style(progress, {
              position: 'absolute',
              left: leftOffset + 'px',
              top: 0,
              bottom: 0,
              height: '100%'
            });
            entry.initProgress(progress);
          }

          this.canvases.push(entry);
        }
        /**
         * Pop single canvas from the list
         *
         */

      }, {
        key: "removeCanvas",
        value: function removeCanvas() {
          var lastEntry = this.canvases[this.canvases.length - 1]; // wave

          lastEntry.wave.parentElement.removeChild(lastEntry.wave.domElement); // progress

          if (this.hasProgressCanvas) {
            lastEntry.progress.parentElement.removeChild(lastEntry.progress.domElement);
          } // cleanup


          if (lastEntry) {
            lastEntry.destroy();
            lastEntry = null;
          }

          this.canvases.pop();
        }
        /**
         * Update the dimensions of a canvas element
         *
         * @param {CanvasEntry} entry Target entry
         * @param {number} width The new width of the element
         * @param {number} height The new height of the element
         */

      }, {
        key: "updateDimensions",
        value: function updateDimensions(entry, width, height) {
          var elementWidth = Math.round(width / this.params.pixelRatio);
          var totalWidth = Math.round(this.width / this.params.pixelRatio); // update canvas dimensions

          entry.updateDimensions(elementWidth, totalWidth, width, height); // style element

          this.style(this.progressWave, {
            display: 'block'
          });
        }
        /**
         * Clear the whole multi-canvas
         */

      }, {
        key: "clearWave",
        value: function clearWave() {
          var _this3 = this;

          util.frame(function () {
            _this3.canvases.forEach(function (entry) {
              return entry.clearWave();
            });
          })();
        }
        /**
         * Draw a waveform with bars
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0. Must be an integer.
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         * @returns {void}
         */

      }, {
        key: "drawBars",
        value: function drawBars(peaks, channelIndex, start, end) {
          var _this4 = this;

          return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
            var absmax = _ref.absmax,
                hasMinVals = _ref.hasMinVals;
                _ref.height;
                var offsetY = _ref.offsetY,
                halfH = _ref.halfH,
                peaks = _ref.peaks,
                ch = _ref.channelIndex;

            // if drawBars was called within ws.empty we don't pass a start and
            // don't want anything to happen
            if (start === undefined) {
              return;
            } // Skip every other value if there are negatives.


            var peakIndexScale = hasMinVals ? 2 : 1;
            var length = peaks.length / peakIndexScale;
            var bar = _this4.params.barWidth * _this4.params.pixelRatio;
            var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
            var step = bar + gap;
            var scale = length / _this4.width;
            var first = start;
            var last = end;
            var i = first;

            for (i; i < last; i += step) {
              var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
              var h = Math.round(peak / absmax * halfH);
              /* in case of silences, allow the user to specify that we
               * always draw *something* (normally a 1px high bar) */

              if (h == 0 && _this4.params.barMinHeight) {
                h = _this4.params.barMinHeight;
              }

              _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius, ch);
            }
          });
        }
        /**
         * Draw a waveform
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number?} start The x-offset of the beginning of the area that
         * should be rendered (If this isn't set only a flat line is rendered)
         * @param {number?} end The x-offset of the end of the area that should be
         * rendered
         * @returns {void}
         */

      }, {
        key: "drawWave",
        value: function drawWave(peaks, channelIndex, start, end) {
          var _this5 = this;

          return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
            var absmax = _ref2.absmax,
                hasMinVals = _ref2.hasMinVals;
                _ref2.height;
                var offsetY = _ref2.offsetY,
                halfH = _ref2.halfH,
                peaks = _ref2.peaks,
                channelIndex = _ref2.channelIndex;

            if (!hasMinVals) {
              var reflectedPeaks = [];
              var len = peaks.length;
              var i = 0;

              for (i; i < len; i++) {
                reflectedPeaks[2 * i] = peaks[i];
                reflectedPeaks[2 * i + 1] = -peaks[i];
              }

              peaks = reflectedPeaks;
            } // if drawWave was called within ws.empty we don't pass a start and
            // end and simply want a flat line


            if (start !== undefined) {
              _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
            } // always draw a median line


            _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius, channelIndex);
          });
        }
        /**
         * Tell the canvas entries to render their portion of the waveform
         *
         * @param {number[]} peaks Peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         * @param {channelIndex} channelIndex The channel index of the line drawn
         */

      }, {
        key: "drawLine",
        value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
          var _this6 = this;

          var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
              waveColor = _ref3.waveColor,
              progressColor = _ref3.progressColor;

          this.canvases.forEach(function (entry, i) {
            _this6.setFillStyles(entry, waveColor, progressColor);

            _this6.applyCanvasTransforms(entry, _this6.params.vertical);

            entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
          });
        }
        /**
         * Draw a rectangle on the multi-canvas
         *
         * @param {number} x X-position of the rectangle
         * @param {number} y Y-position of the rectangle
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         * @param {channelIndex} channelIndex The channel index of the bar drawn
         */

      }, {
        key: "fillRect",
        value: function fillRect(x, y, width, height, radius, channelIndex) {
          var startCanvas = Math.floor(x / this.maxCanvasWidth);
          var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
          var i = startCanvas;

          for (i; i < endCanvas; i++) {
            var entry = this.canvases[i];
            var leftOffset = i * this.maxCanvasWidth;
            var intersection = {
              x1: Math.max(x, i * this.maxCanvasWidth),
              y1: y,
              x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
              y2: y + height
            };

            if (intersection.x1 < intersection.x2) {
              var _ref4 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                  waveColor = _ref4.waveColor,
                  progressColor = _ref4.progressColor;

              this.setFillStyles(entry, waveColor, progressColor);
              this.applyCanvasTransforms(entry, this.params.vertical);
              entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
            }
          }
        }
        /**
         * Returns whether to hide the channel from being drawn based on params.
         *
         * @param {number} channelIndex The index of the current channel.
         * @returns {bool} True to hide the channel, false to draw.
         */

      }, {
        key: "hideChannel",
        value: function hideChannel(channelIndex) {
          return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
        }
        /**
         * Performs preparation tasks and calculations which are shared by `drawBars`
         * and `drawWave`
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
         * split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number?} start The x-offset of the beginning of the area that
         * should be rendered. If this isn't set only a flat line is rendered
         * @param {number?} end The x-offset of the end of the area that should be
         * rendered
         * @param {function} fn The render function to call, e.g. `drawWave`
         * @param {number} drawIndex The index of the current channel after filtering.
         * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
         * @returns {void}
         */

      }, {
        key: "prepareDraw",
        value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
          var _this7 = this;

          return util.frame(function () {
            // Split channels and call this function with the channelIndex set
            if (peaks[0] instanceof Array) {
              var channels = peaks;

              if (_this7.params.splitChannels) {
                var filteredChannels = channels.filter(function (c, i) {
                  return !_this7.hideChannel(i);
                });

                if (!_this7.params.splitChannelsOptions.overlay) {
                  _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
                }

                var overallAbsMax;

                if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
                  // calculate maximum peak across channels to use for normalization
                  overallAbsMax = util.max(channels.map(function (channelPeaks) {
                    return util.absMax(channelPeaks);
                  }));
                }

                return channels.forEach(function (channelPeaks, i) {
                  return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
                });
              }

              peaks = channels[0];
            } // Return and do not draw channel peaks if hidden.


            if (_this7.hideChannel(channelIndex)) {
              return;
            } // calculate maximum modulation value, either from the barHeight
            // parameter or if normalize=true from the largest value in the peak
            // set


            var absmax = 1 / _this7.params.barHeight;

            if (_this7.params.normalize) {
              absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
            } // Bar wave draws the bottom only as a reflection of the top,
            // so we don't need negative values


            var hasMinVals = [].some.call(peaks, function (val) {
              return val < 0;
            });
            var height = _this7.params.height * _this7.params.pixelRatio;
            var halfH = height / 2;
            var offsetY = height * drawIndex || 0; // Override offsetY if overlay is true

            if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.overlay) {
              offsetY = 0;
            }

            return fn({
              absmax: absmax,
              hasMinVals: hasMinVals,
              height: height,
              offsetY: offsetY,
              halfH: halfH,
              peaks: peaks,
              channelIndex: channelIndex
            });
          })();
        }
        /**
         * Set the fill styles for a certain entry (wave and progress)
         *
         * @param {CanvasEntry} entry Target entry
         * @param {string} waveColor Wave color to draw this entry
         * @param {string} progressColor Progress color to draw this entry
         */

      }, {
        key: "setFillStyles",
        value: function setFillStyles(entry) {
          var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
          var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
          entry.setFillStyles(waveColor, progressColor);
        }
        /**
         * Set the canvas transforms for a certain entry (wave and progress)
         *
         * @param {CanvasEntry} entry Target entry
         * @param {boolean} vertical Whether to render the waveform vertically
         */

      }, {
        key: "applyCanvasTransforms",
        value: function applyCanvasTransforms(entry) {
          var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          entry.applyCanvasTransforms(vertical);
        }
        /**
         * Return image data of the multi-canvas
         *
         * When using a `type` of `'blob'`, this will return a `Promise`.
         *
         * @param {string} format='image/png' An optional value of a format type.
         * @param {number} quality=0.92 An optional value between 0 and 1.
         * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
         * @return {string|string[]|Promise} When using the default `'dataURL'`
         * `type` this returns a single data URL or an array of data URLs,
         * one for each canvas. When using the `'blob'` `type` this returns a
         * `Promise` that resolves with an array of `Blob` instances, one for each
         * canvas.
         */

      }, {
        key: "getImage",
        value: function getImage(format, quality, type) {
          if (type === 'blob') {
            return Promise.all(this.canvases.map(function (entry) {
              return entry.getImage(format, quality, type);
            }));
          } else if (type === 'dataURL') {
            var images = this.canvases.map(function (entry) {
              return entry.getImage(format, quality, type);
            });
            return images.length > 1 ? images : images[0];
          }
        }
        /**
         * Render the new progress
         *
         * @param {number} position X-offset of progress position in pixels
         */

      }, {
        key: "updateProgress",
        value: function updateProgress(position) {
          this.style(this.progressWave, {
            width: position + 'px'
          });
        }
      }]);

      return MultiCanvas;
    }(_drawer.default);

    exports.default = MultiCanvas;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/mediaelement-webaudio.js":
    /*!**************************************!*\
      !*** ./src/mediaelement-webaudio.js ***!
      \**************************************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

    function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
     * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
     * buffer the entire file in one request, and you still get the filtering and scripting functionality
     * of the webaudio API.
     * Note that in order to use range requests and prevent buffering, you must provide peak data.
     *
     * @since 3.2.0
     */
    var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
      _inherits(MediaElementWebAudio, _MediaElement);

      var _super = _createSuper(MediaElementWebAudio);

      /**
       * Construct the backend
       *
       * @param {WavesurferParams} params Wavesurfer parameters
       */
      function MediaElementWebAudio(params) {
        var _this;

        _classCallCheck(this, MediaElementWebAudio);

        _this = _super.call(this, params);
        /** @private */

        _this.params = params;
        /** @private */

        _this.sourceMediaElement = null;
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(MediaElementWebAudio, [{
        key: "init",
        value: function init() {
          this.setPlaybackRate(this.params.audioRate);
          this.createTimer();
          this.createVolumeNode();
          this.createScriptNode();
          this.createAnalyserNode();
        }
        /**
         * Private method called by both `load` (from url)
         * and `loadElt` (existing media element) methods.
         *
         * @param {HTMLMediaElement} media HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @private
         */

      }, {
        key: "_load",
        value: function _load(media, peaks, preload) {
          _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);

          this.createMediaElementSource(media);
        }
        /**
         * Create MediaElementSource node
         *
         * @since 3.2.0
         * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
         */

      }, {
        key: "createMediaElementSource",
        value: function createMediaElementSource(mediaElement) {
          this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
          this.sourceMediaElement.connect(this.analyser);
        }
      }, {
        key: "play",
        value: function play(start, end) {
          this.resumeAudioContext();
          return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
        }
        /**
         * This is called when wavesurfer is destroyed
         *
         */

      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);

          this.destroyWebAudio();
        }
      }]);

      return MediaElementWebAudio;
    }(_mediaelement.default);

    exports.default = MediaElementWebAudio;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/mediaelement.js":
    /*!*****************************!*\
      !*** ./src/mediaelement.js ***!
      \*****************************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

    function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

    function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MediaElement backend
     */
    var MediaElement = /*#__PURE__*/function (_WebAudio) {
      _inherits(MediaElement, _WebAudio);

      var _super = _createSuper(MediaElement);

      /**
       * Construct the backend
       *
       * @param {WavesurferParams} params Wavesurfer parameters
       */
      function MediaElement(params) {
        var _this;

        _classCallCheck(this, MediaElement);

        _this = _super.call(this, params);
        /** @private */

        _this.params = params;
        /**
         * Initially a dummy media element to catch errors. Once `_load` is
         * called, this will contain the actual `HTMLMediaElement`.
         * @private
         */

        _this.media = {
          currentTime: 0,
          duration: 0,
          paused: true,
          playbackRate: 1,
          play: function play() {},
          pause: function pause() {},
          volume: 0
        };
        /** @private */

        _this.mediaType = params.mediaType.toLowerCase();
        /** @private */

        _this.elementPosition = params.elementPosition;
        /** @private */

        _this.peaks = null;
        /** @private */

        _this.playbackRate = 1;
        /** @private */

        _this.volume = 1;
        /** @private */

        _this.isMuted = false;
        /** @private */

        _this.buffer = null;
        /** @private */

        _this.onPlayEnd = null;
        /** @private */

        _this.mediaListeners = {};
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(MediaElement, [{
        key: "init",
        value: function init() {
          this.setPlaybackRate(this.params.audioRate);
          this.createTimer();
        }
        /**
         * Attach event listeners to media element.
         */

      }, {
        key: "_setupMediaListeners",
        value: function _setupMediaListeners() {
          var _this2 = this;

          this.mediaListeners.error = function () {
            _this2.fireEvent('error', 'Error loading media element');
          };

          this.mediaListeners.canplay = function () {
            _this2.fireEvent('canplay');
          };

          this.mediaListeners.ended = function () {
            _this2.fireEvent('finish');
          }; // listen to and relay play, pause and seeked events to enable
          // playback control from the external media element


          this.mediaListeners.play = function () {
            _this2.fireEvent('play');
          };

          this.mediaListeners.pause = function () {
            _this2.fireEvent('pause');
          };

          this.mediaListeners.seeked = function (event) {
            _this2.fireEvent('seek');
          };

          this.mediaListeners.volumechange = function (event) {
            _this2.isMuted = _this2.media.muted;

            if (_this2.isMuted) {
              _this2.volume = 0;
            } else {
              _this2.volume = _this2.media.volume;
            }

            _this2.fireEvent('volume');
          }; // reset event listeners


          Object.keys(this.mediaListeners).forEach(function (id) {
            _this2.media.removeEventListener(id, _this2.mediaListeners[id]);

            _this2.media.addEventListener(id, _this2.mediaListeners[id]);
          });
        }
        /**
         * Create a timer to provide a more precise `audioprocess` event.
         */

      }, {
        key: "createTimer",
        value: function createTimer() {
          var _this3 = this;

          var onAudioProcess = function onAudioProcess() {
            if (_this3.isPaused()) {
              return;
            }

            _this3.fireEvent('audioprocess', _this3.getCurrentTime()); // Call again in the next frame


            util.frame(onAudioProcess)();
          };

          this.on('play', onAudioProcess); // Update the progress one more time to prevent it from being stuck in
          // case of lower framerates

          this.on('pause', function () {
            _this3.fireEvent('audioprocess', _this3.getCurrentTime());
          });
        }
        /**
         * Create media element with url as its source,
         * and append to container element.
         *
         * @param {string} url Path to media file
         * @param {HTMLElement} container HTML element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @throws Will throw an error if the `url` argument is not a valid media
         * element.
         */

      }, {
        key: "load",
        value: function load(url, container, peaks, preload) {
          var media = document.createElement(this.mediaType);
          media.controls = this.params.mediaControls;
          media.autoplay = this.params.autoplay || false;
          media.preload = preload == null ? 'auto' : preload;
          media.src = url;
          media.style.width = '100%';
          var prevMedia = container.querySelector(this.mediaType);

          if (prevMedia) {
            container.removeChild(prevMedia);
          }

          container.appendChild(media);

          this._load(media, peaks, preload);
        }
        /**
         * Load existing media element.
         *
         * @param {HTMLMediaElement} elt HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         */

      }, {
        key: "loadElt",
        value: function loadElt(elt, peaks) {
          elt.controls = this.params.mediaControls;
          elt.autoplay = this.params.autoplay || false;

          this._load(elt, peaks, elt.preload);
        }
        /**
         * Method called by both `load` (from url)
         * and `loadElt` (existing media element) methods.
         *
         * @param {HTMLMediaElement} media HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @throws Will throw an error if the `media` argument is not a valid media
         * element.
         * @private
         */

      }, {
        key: "_load",
        value: function _load(media, peaks, preload) {
          // verify media element is valid
          if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
            throw new Error('media parameter is not a valid media element');
          } // load must be called manually on iOS, otherwise peaks won't draw
          // until a user interaction triggers load --> 'ready' event
          //
          // note that we avoid calling media.load here when given peaks and preload == 'none'
          // as this almost always triggers some browser fetch of the media.


          if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
            // Resets the media element and restarts the media resource. Any
            // pending events are discarded. How much media data is fetched is
            // still affected by the preload attribute.
            media.load();
          }

          this.media = media;

          this._setupMediaListeners();

          this.peaks = peaks;
          this.onPlayEnd = null;
          this.buffer = null;
          this.isMuted = media.muted;
          this.setPlaybackRate(this.playbackRate);
          this.setVolume(this.volume);
        }
        /**
         * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
         *
         * @return {boolean} Media paused or not
         */

      }, {
        key: "isPaused",
        value: function isPaused() {
          return !this.media || this.media.paused;
        }
        /**
         * Used by `wavesurfer.getDuration()`
         *
         * @return {number} Duration
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          if (this.explicitDuration) {
            return this.explicitDuration;
          }

          var duration = (this.buffer || this.media).duration;

          if (duration >= Infinity) {
            // streaming audio
            duration = this.media.seekable.end(0);
          }

          return duration;
        }
        /**
         * Returns the current time in seconds relative to the audio-clip's
         * duration.
         *
         * @return {number} Current time
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.media && this.media.currentTime;
        }
        /**
         * Get the position from 0 to 1
         *
         * @return {number} Current position
         */

      }, {
        key: "getPlayedPercents",
        value: function getPlayedPercents() {
          return this.getCurrentTime() / this.getDuration() || 0;
        }
        /**
         * Get the audio source playback rate.
         *
         * @return {number} Playback rate
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.playbackRate || this.media.playbackRate;
        }
        /**
         * Set the audio source playback rate.
         *
         * @param {number} value Playback rate
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(value) {
          this.playbackRate = value || 1;
          this.media.playbackRate = this.playbackRate;
        }
        /**
         * Used by `wavesurfer.seekTo()`
         *
         * @param {number} start Position to start at in seconds
         */

      }, {
        key: "seekTo",
        value: function seekTo(start) {
          if (start != null) {
            this.media.currentTime = start;
          }

          this.clearPlayEnd();
        }
        /**
         * Plays the loaded audio region.
         *
         * @param {number} start Start offset in seconds, relative to the beginning
         * of a clip.
         * @param {number} end When to stop, relative to the beginning of a clip.
         * @emits MediaElement#play
         * @return {Promise} Result
         */

      }, {
        key: "play",
        value: function play(start, end) {
          this.seekTo(start);
          var promise = this.media.play();
          end && this.setPlayEnd(end);
          return promise;
        }
        /**
         * Pauses the loaded audio.
         *
         * @emits MediaElement#pause
         * @return {Promise} Result
         */

      }, {
        key: "pause",
        value: function pause() {
          var promise;

          if (this.media) {
            promise = this.media.pause();
          }

          this.clearPlayEnd();
          return promise;
        }
        /**
         * Set the play end
         *
         * @param {number} end Where to end
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(end) {
          var _this4 = this;

          this.clearPlayEnd();

          this._onPlayEnd = function (time) {
            if (time >= end) {
              _this4.pause();

              _this4.seekTo(end);
            }
          };

          this.on('audioprocess', this._onPlayEnd);
        }
        /** @private */

      }, {
        key: "clearPlayEnd",
        value: function clearPlayEnd() {
          if (this._onPlayEnd) {
            this.un('audioprocess', this._onPlayEnd);
            this._onPlayEnd = null;
          }
        }
        /**
         * Compute the max and min value of the waveform when broken into
         * <length> subranges.
         *
         * @param {number} length How many subranges to break the waveform into.
         * @param {number} first First sample in the required range.
         * @param {number} last Last sample in the required range.
         * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
         * arrays of peaks consisting of (max, min) values for each subrange.
         */

      }, {
        key: "getPeaks",
        value: function getPeaks(length, first, last) {
          if (this.buffer) {
            return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
          }

          return this.peaks || [];
        }
        /**
         * Set the sink id for the media player
         *
         * @param {string} deviceId String value representing audio device id.
         * @returns {Promise} A Promise that resolves to `undefined` when there
         * are no errors.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          if (deviceId) {
            if (!this.media.setSinkId) {
              return Promise.reject(new Error('setSinkId is not supported in your browser'));
            }

            return this.media.setSinkId(deviceId);
          }

          return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
        }
        /**
         * Get the current volume
         *
         * @return {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.volume;
        }
        /**
         * Set the audio volume
         *
         * @param {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "setVolume",
        value: function setVolume(value) {
          this.volume = value; // no need to change when it's already at that volume

          if (this.media.volume !== this.volume) {
            this.media.volume = this.volume;
          }
        }
        /**
         * Enable or disable muted audio
         *
         * @since 4.0.0
         * @param {boolean} muted Specify `true` to mute audio.
         */

      }, {
        key: "setMute",
        value: function setMute(muted) {
          // This causes a volume change to be emitted too through the
          // volumechange event listener.
          this.isMuted = this.media.muted = muted;
        }
        /**
         * This is called when wavesurfer is destroyed
         *
         */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this5 = this;

          this.pause();
          this.unAll();
          this.destroyed = true; // cleanup media event listeners

          Object.keys(this.mediaListeners).forEach(function (id) {
            if (_this5.media) {
              _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
            }
          });

          if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
            this.media.parentNode.removeChild(this.media);
          }

          this.media = null;
        }
      }]);

      return MediaElement;
    }(_webaudio.default);

    exports.default = MediaElement;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/peakcache.js":
    /*!**************************!*\
      !*** ./src/peakcache.js ***!
      \**************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * Caches the decoded peaks data to improve rendering speed for large audio
     *
     * Is used if the option parameter `partialRender` is set to `true`
     */
    var PeakCache = /*#__PURE__*/function () {
      /**
       * Instantiate cache
       */
      function PeakCache() {
        _classCallCheck(this, PeakCache);

        this.clearPeakCache();
      }
      /**
       * Empty the cache
       */


      _createClass(PeakCache, [{
        key: "clearPeakCache",
        value: function clearPeakCache() {
          /**
           * Flat array with entries that are always in pairs to mark the
           * beginning and end of each subrange.  This is a convenience so we can
           * iterate over the pairs for easy set difference operations.
           * @private
           */
          this.peakCacheRanges = [];
          /**
           * Length of the entire cachable region, used for resetting the cache
           * when this changes (zoom events, for instance).
           * @private
           */

          this.peakCacheLength = -1;
        }
        /**
         * Add a range of peaks to the cache
         *
         * @param {number} length The length of the range
         * @param {number} start The x offset of the start of the range
         * @param {number} end The x offset of the end of the range
         * @return {Number.<Array[]>} Array with arrays of numbers
         */

      }, {
        key: "addRangeToPeakCache",
        value: function addRangeToPeakCache(length, start, end) {
          if (length != this.peakCacheLength) {
            this.clearPeakCache();
            this.peakCacheLength = length;
          } // Return ranges that weren't in the cache before the call.


          var uncachedRanges = [];
          var i = 0; // Skip ranges before the current start.

          while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
            i++;
          } // If |i| is even, |start| falls after an existing range.  Otherwise,
          // |start| falls between an existing range, and the uncached region
          // starts when we encounter the next node in |peakCacheRanges| or
          // |end|, whichever comes first.


          if (i % 2 == 0) {
            uncachedRanges.push(start);
          }

          while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
            uncachedRanges.push(this.peakCacheRanges[i]);
            i++;
          } // If |i| is even, |end| is after all existing ranges.


          if (i % 2 == 0) {
            uncachedRanges.push(end);
          } // Filter out the 0-length ranges.


          uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
            if (pos == 0) {
              return item != arr[pos + 1];
            } else if (pos == arr.length - 1) {
              return item != arr[pos - 1];
            }

            return item != arr[pos - 1] && item != arr[pos + 1];
          }); // Merge the two ranges together, uncachedRanges will either contain
          // wholly new points, or duplicates of points in peakCacheRanges.  If
          // duplicates are detected, remove both and extend the range.

          this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
          this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
            return a - b;
          }).filter(function (item, pos, arr) {
            if (pos == 0) {
              return item != arr[pos + 1];
            } else if (pos == arr.length - 1) {
              return item != arr[pos - 1];
            }

            return item != arr[pos - 1] && item != arr[pos + 1];
          }); // Push the uncached ranges into an array of arrays for ease of
          // iteration in the functions that call this.

          var uncachedRangePairs = [];

          for (i = 0; i < uncachedRanges.length; i += 2) {
            uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
          }

          return uncachedRangePairs;
        }
        /**
         * For testing
         *
         * @return {Number.<Array[]>} Array with arrays of numbers
         */

      }, {
        key: "getCacheRanges",
        value: function getCacheRanges() {
          var peakCacheRangePairs = [];
          var i;

          for (i = 0; i < this.peakCacheRanges.length; i += 2) {
            peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
          }

          return peakCacheRangePairs;
        }
      }]);

      return PeakCache;
    }();

    exports.default = PeakCache;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/absMax.js":
    /*!****************************!*\
      !*** ./src/util/absMax.js ***!
      \****************************/
    /***/ ((module, exports, __webpack_require__) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = absMax;

    var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));

    var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Get the largest absolute value in an array
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Largest number found
     * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
     * @since 4.3.0
     */
    function absMax(values) {
      var max = (0, _max.default)(values);
      var min = (0, _min.default)(values);
      return -min > max ? -min : max;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/clamp.js":
    /*!***************************!*\
      !*** ./src/util/clamp.js ***!
      \***************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = clamp;

    /**
     * Returns a number limited to the given range.
     *
     * @param {number} val The number to be limited to a range
     * @param {number} min The lower boundary of the limit range
     * @param {number} max The upper boundary of the limit range
     * @returns {number} A number in the range [min, max]
     */
    function clamp(val, min, max) {
      return Math.min(Math.max(min, val), max);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/fetch.js":
    /*!***************************!*\
      !*** ./src/util/fetch.js ***!
      \***************************/
    /***/ ((module, exports, __webpack_require__) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = fetchFile;

    var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var ProgressHandler = /*#__PURE__*/function () {
      /**
       * Instantiate ProgressHandler
       *
       * @param {Observer} instance The `fetchFile` observer instance.
       * @param {Number} contentLength Content length.
       * @param {Response} response Response object.
       */
      function ProgressHandler(instance, contentLength, response) {
        _classCallCheck(this, ProgressHandler);

        this.instance = instance;
        this.instance._reader = response.body.getReader();
        this.total = parseInt(contentLength, 10);
        this.loaded = 0;
      }
      /**
       * A method that is called once, immediately after the `ReadableStream``
       * is constructed.
       *
       * @param {ReadableStreamDefaultController} controller Controller instance
       *     used to control the stream.
       */


      _createClass(ProgressHandler, [{
        key: "start",
        value: function start(controller) {
          var _this = this;

          var read = function read() {
            // instance._reader.read() returns a promise that resolves
            // when a value has been received
            _this.instance._reader.read().then(function (_ref) {
              var done = _ref.done,
                  value = _ref.value;

              // result objects contain two properties:
              // done  - true if the stream has already given you all its data.
              // value - some data. Always undefined when done is true.
              if (done) {
                // ensure onProgress called when content-length=0
                if (_this.total === 0) {
                  _this.instance.onProgress.call(_this.instance, {
                    loaded: _this.loaded,
                    total: _this.total,
                    lengthComputable: false
                  });
                } // no more data needs to be consumed, close the stream


                controller.close();
                return;
              }

              _this.loaded += value.byteLength;

              _this.instance.onProgress.call(_this.instance, {
                loaded: _this.loaded,
                total: _this.total,
                lengthComputable: !(_this.total === 0)
              }); // enqueue the next data chunk into our target stream


              controller.enqueue(value);
              read();
            }).catch(function (error) {
              controller.error(error);
            });
          };

          read();
        }
      }]);

      return ProgressHandler;
    }();
    /**
     * Load a file using `fetch`.
     *
     * @param {object} options Request options to use. See example below.
     * @returns {Observer} Observer instance
     * @example
     * // default options
     * let options = {
     *     url: undefined,
     *     method: 'GET',
     *     mode: 'cors',
     *     credentials: 'same-origin',
     *     cache: 'default',
     *     responseType: 'json',
     *     requestHeaders: [],
     *     redirect: 'follow',
     *     referrer: 'client'
     * };
     *
     * // override some options
     * options.url = '../media/demo.wav';

     * // available types: 'arraybuffer', 'blob', 'json' or 'text'
     * options.responseType = 'arraybuffer';
     *
     * // make fetch call
     * let request = util.fetchFile(options);
     *
     * // listen for events
     * request.on('progress', e => {
     *     console.log('progress', e);
     * });
     *
     * request.on('success', data => {
     *     console.log('success!', data);
     * });
     *
     * request.on('error', e => {
     *     console.warn('fetchFile error: ', e);
     * });
     */


    function fetchFile(options) {
      if (!options) {
        throw new Error('fetch options missing');
      } else if (!options.url) {
        throw new Error('fetch url missing');
      }

      var instance = new _observer.default();
      var fetchHeaders = new Headers();
      var fetchRequest = new Request(options.url); // add ability to abort

      instance.controller = new AbortController(); // check if headers have to be added

      if (options && options.requestHeaders) {
        // add custom request headers
        options.requestHeaders.forEach(function (header) {
          fetchHeaders.append(header.key, header.value);
        });
      } // parse fetch options


      var responseType = options.responseType || 'json';
      var fetchOptions = {
        method: options.method || 'GET',
        headers: fetchHeaders,
        mode: options.mode || 'cors',
        credentials: options.credentials || 'same-origin',
        cache: options.cache || 'default',
        redirect: options.redirect || 'follow',
        referrer: options.referrer || 'client',
        signal: instance.controller.signal
      };
      fetch(fetchRequest, fetchOptions).then(function (response) {
        // store response reference
        instance.response = response;
        var progressAvailable = true;

        if (!response.body) {
          // ReadableStream is not yet supported in this browser
          // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
          progressAvailable = false;
        } // Server must send CORS header "Access-Control-Expose-Headers: content-length"


        var contentLength = response.headers.get('content-length');

        if (contentLength === null) {
          // Content-Length server response header missing.
          // Don't evaluate download progress if we can't compare against a total size
          // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
          progressAvailable = false;
        }

        if (!progressAvailable) {
          // not able to check download progress so skip it
          return response;
        } // fire progress event when during load


        instance.onProgress = function (e) {
          instance.fireEvent('progress', e);
        };

        return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
      }).then(function (response) {
        var errMsg;

        if (response.ok) {
          switch (responseType) {
            case 'arraybuffer':
              return response.arrayBuffer();

            case 'json':
              return response.json();

            case 'blob':
              return response.blob();

            case 'text':
              return response.text();

            default:
              errMsg = 'Unknown responseType: ' + responseType;
              break;
          }
        }

        if (!errMsg) {
          errMsg = 'HTTP error status: ' + response.status;
        }

        throw new Error(errMsg);
      }).then(function (response) {
        instance.fireEvent('success', response);
      }).catch(function (error) {
        instance.fireEvent('error', error);
      }); // return the fetch request

      instance.fetchRequest = fetchRequest;
      return instance;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/frame.js":
    /*!***************************!*\
      !*** ./src/util/frame.js ***!
      \***************************/
    /***/ ((module, exports, __webpack_require__) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = frame;

    var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Create a function which will be called at the next requestAnimationFrame
     * cycle
     *
     * @param {function} func The function to call
     *
     * @return {func} The function wrapped within a requestAnimationFrame
     */
    function frame(func) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (0, _requestAnimationFrame.default)(function () {
          return func.apply(void 0, args);
        });
      };
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/get-id.js":
    /*!****************************!*\
      !*** ./src/util/get-id.js ***!
      \****************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = getId;

    /**
     * Get a random prefixed ID
     *
     * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
     * @returns {String} Random prefixed ID
     * @example
     * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
     *
     * let prefix = 'foo-';
     * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
     */
    function getId(prefix) {
      if (prefix === undefined) {
        prefix = 'wavesurfer_';
      }

      return prefix + Math.random().toString(32).substring(2);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/index.js":
    /*!***************************!*\
      !*** ./src/util/index.js ***!
      \***************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    Object.defineProperty(exports, "getId", ({
      enumerable: true,
      get: function get() {
        return _getId.default;
      }
    }));
    Object.defineProperty(exports, "max", ({
      enumerable: true,
      get: function get() {
        return _max.default;
      }
    }));
    Object.defineProperty(exports, "min", ({
      enumerable: true,
      get: function get() {
        return _min.default;
      }
    }));
    Object.defineProperty(exports, "absMax", ({
      enumerable: true,
      get: function get() {
        return _absMax.default;
      }
    }));
    Object.defineProperty(exports, "Observer", ({
      enumerable: true,
      get: function get() {
        return _observer.default;
      }
    }));
    Object.defineProperty(exports, "style", ({
      enumerable: true,
      get: function get() {
        return _style.default;
      }
    }));
    Object.defineProperty(exports, "requestAnimationFrame", ({
      enumerable: true,
      get: function get() {
        return _requestAnimationFrame.default;
      }
    }));
    Object.defineProperty(exports, "frame", ({
      enumerable: true,
      get: function get() {
        return _frame.default;
      }
    }));
    Object.defineProperty(exports, "debounce", ({
      enumerable: true,
      get: function get() {
        return _debounce.default;
      }
    }));
    Object.defineProperty(exports, "preventClick", ({
      enumerable: true,
      get: function get() {
        return _preventClick.default;
      }
    }));
    Object.defineProperty(exports, "fetchFile", ({
      enumerable: true,
      get: function get() {
        return _fetch.default;
      }
    }));
    Object.defineProperty(exports, "clamp", ({
      enumerable: true,
      get: function get() {
        return _clamp.default;
      }
    }));
    Object.defineProperty(exports, "withOrientation", ({
      enumerable: true,
      get: function get() {
        return _orientation.default;
      }
    }));

    var _getId = _interopRequireDefault(__webpack_require__(/*! ./get-id */ "./src/util/get-id.js"));

    var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));

    var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));

    var _absMax = _interopRequireDefault(__webpack_require__(/*! ./absMax */ "./src/util/absMax.js"));

    var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));

    var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./src/util/style.js"));

    var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));

    var _frame = _interopRequireDefault(__webpack_require__(/*! ./frame */ "./src/util/frame.js"));

    var _debounce = _interopRequireDefault(__webpack_require__(/*! debounce */ "./node_modules/debounce/index.js"));

    var _preventClick = _interopRequireDefault(__webpack_require__(/*! ./prevent-click */ "./src/util/prevent-click.js"));

    var _fetch = _interopRequireDefault(__webpack_require__(/*! ./fetch */ "./src/util/fetch.js"));

    var _clamp = _interopRequireDefault(__webpack_require__(/*! ./clamp */ "./src/util/clamp.js"));

    var _orientation = _interopRequireDefault(__webpack_require__(/*! ./orientation */ "./src/util/orientation.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /***/ }),

    /***/ "./src/util/max.js":
    /*!*************************!*\
      !*** ./src/util/max.js ***!
      \*************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = max;

    /**
     * Get the largest value
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Largest number found
     * @example console.log(max([1, 2, 3])); // logs 3
     */
    function max(values) {
      var largest = -Infinity;
      Object.keys(values).forEach(function (i) {
        if (values[i] > largest) {
          largest = values[i];
        }
      });
      return largest;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/min.js":
    /*!*************************!*\
      !*** ./src/util/min.js ***!
      \*************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = min;

    /**
     * Get the smallest value
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Smallest number found
     * @example console.log(min([1, 2, 3])); // logs 1
     */
    function min(values) {
      var smallest = Number(Infinity);
      Object.keys(values).forEach(function (i) {
        if (values[i] < smallest) {
          smallest = values[i];
        }
      });
      return smallest;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/observer.js":
    /*!******************************!*\
      !*** ./src/util/observer.js ***!
      \******************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * @typedef {Object} ListenerDescriptor
     * @property {string} name The name of the event
     * @property {function} callback The callback
     * @property {function} un The function to call to remove the listener
     */

    /**
     * Observer class
     */
    var Observer = /*#__PURE__*/function () {
      /**
       * Instantiate Observer
       */
      function Observer() {
        _classCallCheck(this, Observer);

        /**
         * @private
         * @todo Initialise the handlers here already and remove the conditional
         * assignment in `on()`
         */
        this._disabledEventEmissions = [];
        this.handlers = null;
      }
      /**
       * Attach a handler function for an event.
       *
       * @param {string} event Name of the event to listen to
       * @param {function} fn The callback to trigger when the event is fired
       * @return {ListenerDescriptor} The event descriptor
       */


      _createClass(Observer, [{
        key: "on",
        value: function on(event, fn) {
          var _this = this;

          if (!this.handlers) {
            this.handlers = {};
          }

          var handlers = this.handlers[event];

          if (!handlers) {
            handlers = this.handlers[event] = [];
          }

          handlers.push(fn); // Return an event descriptor

          return {
            name: event,
            callback: fn,
            un: function un(e, fn) {
              return _this.un(e, fn);
            }
          };
        }
        /**
         * Remove an event handler.
         *
         * @param {string} event Name of the event the listener that should be
         * removed listens to
         * @param {function} fn The callback that should be removed
         */

      }, {
        key: "un",
        value: function un(event, fn) {
          if (!this.handlers) {
            return;
          }

          var handlers = this.handlers[event];
          var i;

          if (handlers) {
            if (fn) {
              for (i = handlers.length - 1; i >= 0; i--) {
                if (handlers[i] == fn) {
                  handlers.splice(i, 1);
                }
              }
            } else {
              handlers.length = 0;
            }
          }
        }
        /**
         * Remove all event handlers.
         */

      }, {
        key: "unAll",
        value: function unAll() {
          this.handlers = null;
        }
        /**
         * Attach a handler to an event. The handler is executed at most once per
         * event type.
         *
         * @param {string} event The event to listen to
         * @param {function} handler The callback that is only to be called once
         * @return {ListenerDescriptor} The event descriptor
         */

      }, {
        key: "once",
        value: function once(event, handler) {
          var _this2 = this;

          var fn = function fn() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            /*  eslint-disable no-invalid-this */
            handler.apply(_this2, args);
            /*  eslint-enable no-invalid-this */

            setTimeout(function () {
              _this2.un(event, fn);
            }, 0);
          };

          return this.on(event, fn);
        }
        /**
         * Disable firing a list of events by name. When specified, event handlers for any event type
         * passed in here will not be called.
         *
         * @since 4.0.0
         * @param {string[]} eventNames an array of event names to disable emissions for
         * @example
         * // disable seek and interaction events
         * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
         */

      }, {
        key: "setDisabledEventEmissions",
        value: function setDisabledEventEmissions(eventNames) {
          this._disabledEventEmissions = eventNames;
        }
        /**
         * plugins borrow part of this class without calling the constructor,
         * so we have to be careful about _disabledEventEmissions
         */

      }, {
        key: "_isDisabledEventEmission",
        value: function _isDisabledEventEmission(event) {
          return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
        }
        /**
         * Manually fire an event
         *
         * @param {string} event The event to fire manually
         * @param {...any} args The arguments with which to call the listeners
         */

      }, {
        key: "fireEvent",
        value: function fireEvent(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (!this.handlers || this._isDisabledEventEmission(event)) {
            return;
          }

          var handlers = this.handlers[event];
          handlers && handlers.forEach(function (fn) {
            fn.apply(void 0, args);
          });
        }
      }]);

      return Observer;
    }();

    exports.default = Observer;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/orientation.js":
    /*!*********************************!*\
      !*** ./src/util/orientation.js ***!
      \*********************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = withOrientation;
    var verticalPropMap = {
      width: 'height',
      height: 'width',
      overflowX: 'overflowY',
      overflowY: 'overflowX',
      clientWidth: 'clientHeight',
      clientHeight: 'clientWidth',
      clientX: 'clientY',
      clientY: 'clientX',
      scrollWidth: 'scrollHeight',
      scrollLeft: 'scrollTop',
      offsetLeft: 'offsetTop',
      offsetTop: 'offsetLeft',
      offsetHeight: 'offsetWidth',
      offsetWidth: 'offsetHeight',
      left: 'top',
      right: 'bottom',
      top: 'left',
      bottom: 'right',
      borderRightStyle: 'borderBottomStyle',
      borderRightWidth: 'borderBottomWidth',
      borderRightColor: 'borderBottomColor'
    };
    /**
     * Convert a horizontally-oriented property name to a vertical one.
     *
     * @param {string} prop A property name
     * @param {bool} vertical Whether the element is oriented vertically
     * @returns {string} prop, converted appropriately
     */

    function mapProp(prop, vertical) {
      if (Object.prototype.hasOwnProperty.call(verticalPropMap, prop)) {
        return vertical ? verticalPropMap[prop] : prop;
      } else {
        return prop;
      }
    }

    var isProxy = Symbol("isProxy");
    /**
     * Returns an appropriately oriented object based on vertical.
     * If vertical is true, attribute getting and setting will be mapped through
     * verticalPropMap, so that e.g. getting the object's .width will give its
     * .height instead.
     * Certain methods of an oriented object will return oriented objects as well.
     * Oriented objects can't be added to the DOM directly since they are Proxy objects
     * and thus fail typechecks. Use domElement to get the actual element for this.
     *
     * @param {object} target The object to be wrapped and oriented
     * @param {bool} vertical Whether the element is oriented vertically
     * @returns {Proxy} An oriented object with attr translation via verticalAttrMap
     * @since 5.0.0
     */

    function withOrientation(target, vertical) {
      if (target[isProxy]) {
        return target;
      } else {
        return new Proxy(target, {
          get: function get(obj, prop, receiver) {
            if (prop === isProxy) {
              return true;
            } else if (prop === 'domElement') {
              return obj;
            } else if (prop === 'style') {
              return withOrientation(obj.style, vertical);
            } else if (prop === 'canvas') {
              return withOrientation(obj.canvas, vertical);
            } else if (prop === 'getBoundingClientRect') {
              return function () {
                return withOrientation(obj.getBoundingClientRect.apply(obj, arguments), vertical);
              };
            } else if (prop === 'getContext') {
              return function () {
                return withOrientation(obj.getContext.apply(obj, arguments), vertical);
              };
            } else {
              var value = obj[mapProp(prop, vertical)];
              return typeof value == 'function' ? value.bind(obj) : value;
            }
          },
          set: function set(obj, prop, value) {
            obj[mapProp(prop, vertical)] = value;
            return true;
          }
        });
      }
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/prevent-click.js":
    /*!***********************************!*\
      !*** ./src/util/prevent-click.js ***!
      \***********************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = preventClick;

    /**
     * Stops propagation of click event and removes event listener
     *
     * @private
     * @param {object} event The click event
     */
    function preventClickHandler(event) {
      event.stopPropagation();
      document.body.removeEventListener('click', preventClickHandler, true);
    }
    /**
     * Starts listening for click event and prevent propagation
     *
     * @param {object} values Values
     */


    function preventClick(values) {
      document.body.addEventListener('click', preventClickHandler, true);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/request-animation-frame.js":
    /*!*********************************************!*\
      !*** ./src/util/request-animation-frame.js ***!
      \*********************************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    /* eslint-disable valid-jsdoc */

    /**
     * Returns the `requestAnimationFrame` function for the browser, or a shim with
     * `setTimeout` if the function is not found
     *
     * @return {function} Available `requestAnimationFrame` function for the browser
     */
    var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
      return setTimeout(callback, 1000 / 60);
    }).bind(window);

    exports.default = _default;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/style.js":
    /*!***************************!*\
      !*** ./src/util/style.js ***!
      \***************************/
    /***/ ((module, exports) => {


    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = style;

    /**
     * Apply a map of styles to an element
     *
     * @param {HTMLElement} el The element that the styles will be applied to
     * @param {Object} styles The map of propName: attribute, both are used as-is
     *
     * @return {HTMLElement} el
     */
    function style(el, styles) {
      Object.keys(styles).forEach(function (prop) {
        if (el.style[prop] !== styles[prop]) {
          el.style[prop] = styles[prop];
        }
      });
      return el;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/wavesurfer.js":
    /*!***************************!*\
      !*** ./src/wavesurfer.js ***!
      \***************************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer.multicanvas */ "./src/drawer.multicanvas.js"));

    var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));

    var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));

    var _peakcache = _interopRequireDefault(__webpack_require__(/*! ./peakcache */ "./src/peakcache.js"));

    var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__(/*! ./mediaelement-webaudio */ "./src/mediaelement-webaudio.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

    function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
    /**
     * WaveSurfer core library class
     *
     * @extends {Observer}
     * @example
     * const params = {
     *   container: '#waveform',
     *   waveColor: 'violet',
     *   progressColor: 'purple'
     * };
     *
     * // initialise like this
     * const wavesurfer = WaveSurfer.create(params);
     *
     * // or like this ...
     * const wavesurfer = new WaveSurfer(params);
     * wavesurfer.init();
     *
     * // load audio file
     * wavesurfer.load('example/media/demo.wav');
     */


    var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
      _inherits(WaveSurfer, _util$Observer);

      var _super = _createSuper(WaveSurfer);

      /**
       * Initialise wavesurfer instance
       *
       * @param {WavesurferParams} params Instantiation options for wavesurfer
       * @example
       * const wavesurfer = new WaveSurfer(params);
       * @returns {this} Wavesurfer instance
       */
      function WaveSurfer(params) {
        var _this;

        _classCallCheck(this, WaveSurfer);

        _this = _super.call(this);
        /**
         * Extract relevant parameters (or defaults)
         * @private
         */

        _this.defaultParams = {
          audioContext: null,
          audioScriptProcessor: null,
          audioRate: 1,
          autoCenter: true,
          autoCenterRate: 5,
          autoCenterImmediately: false,
          backend: 'WebAudio',
          backgroundColor: null,
          barHeight: 1,
          barRadius: 0,
          barGap: null,
          barMinHeight: null,
          container: null,
          cursorColor: '#333',
          cursorWidth: 1,
          dragSelection: true,
          drawingContextAttributes: {
            // Boolean that hints the user agent to reduce the latency
            // by desynchronizing the canvas paint cycle from the event
            // loop
            desynchronized: false
          },
          duration: null,
          fillParent: true,
          forceDecode: false,
          height: 128,
          hideScrollbar: false,
          interact: true,
          loopSelection: true,
          maxCanvasWidth: 4000,
          mediaContainer: null,
          mediaControls: false,
          mediaType: 'audio',
          minPxPerSec: 20,
          normalize: false,
          partialRender: false,
          pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
          plugins: [],
          progressColor: '#555',
          removeMediaElementOnDestroy: true,
          renderer: _drawer.default,
          responsive: false,
          rtl: false,
          scrollParent: false,
          skipLength: 2,
          splitChannels: false,
          splitChannelsOptions: {
            overlay: false,
            channelColors: {},
            filterChannels: [],
            relativeNormalization: false
          },
          vertical: false,
          waveColor: '#999',
          xhr: {}
        };
        _this.backends = {
          MediaElement: _mediaelement.default,
          WebAudio: _webaudio.default,
          MediaElementWebAudio: _mediaelementWebaudio.default
        };
        _this.util = util;
        _this.params = Object.assign({}, _this.defaultParams, params);
        _this.params.splitChannelsOptions = Object.assign({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
        /** @private */

        _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;

        if (!_this.container) {
          throw new Error('Container element not found');
        }

        if (_this.params.mediaContainer == null) {
          /** @private */
          _this.mediaContainer = _this.container;
        } else if (typeof _this.params.mediaContainer == 'string') {
          /** @private */
          _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
        } else {
          /** @private */
          _this.mediaContainer = _this.params.mediaContainer;
        }

        if (!_this.mediaContainer) {
          throw new Error('Media Container element not found');
        }

        if (_this.params.maxCanvasWidth <= 1) {
          throw new Error('maxCanvasWidth must be greater than 1');
        } else if (_this.params.maxCanvasWidth % 2 == 1) {
          throw new Error('maxCanvasWidth must be an even number');
        }

        if (_this.params.rtl === true) {
          if (_this.params.vertical === true) {
            util.style(_this.container, {
              transform: 'rotateX(180deg)'
            });
          } else {
            util.style(_this.container, {
              transform: 'rotateY(180deg)'
            });
          }
        }

        if (_this.params.backgroundColor) {
          _this.setBackgroundColor(_this.params.backgroundColor);
        }
        /**
         * @private Used to save the current volume when muting so we can
         * restore once unmuted
         * @type {number}
         */


        _this.savedVolume = 0;
        /**
         * @private The current muted state
         * @type {boolean}
         */

        _this.isMuted = false;
        /**
         * @private Will hold a list of event descriptors that need to be
         * canceled on subsequent loads of audio
         * @type {Object[]}
         */

        _this.tmpEvents = [];
        /**
         * @private Holds any running audio downloads
         * @type {Observer}
         */

        _this.currentRequest = null;
        /** @private */

        _this.arraybuffer = null;
        /** @private */

        _this.drawer = null;
        /** @private */

        _this.backend = null;
        /** @private */

        _this.peakCache = null; // cache constructor objects

        if (typeof _this.params.renderer !== 'function') {
          throw new Error('Renderer parameter is invalid');
        }
        /**
         * @private The uninitialised Drawer class
         */


        _this.Drawer = _this.params.renderer;
        /**
         * @private The uninitialised Backend class
         */
        // Back compat

        if (_this.params.backend == 'AudioElement') {
          _this.params.backend = 'MediaElement';
        }

        if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
          _this.params.backend = 'MediaElement';
        }

        _this.Backend = _this.backends[_this.params.backend];
        /**
         * @private map of plugin names that are currently initialised
         */

        _this.initialisedPluginList = {};
        /** @private */

        _this.isDestroyed = false;
        /**
         * Get the current ready status.
         *
         * @example const isReady = wavesurfer.isReady;
         * @return {boolean}
         */

        _this.isReady = false; // responsive debounced event listener. If this.params.responsive is not
        // set, this is never called. Use 100ms or this.params.responsive as
        // timeout for the debounce function.

        var prevWidth = 0;
        _this._onResize = util.debounce(function () {
          if (prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
            prevWidth = _this.drawer.wrapper.clientWidth;

            _this.drawer.fireEvent('redraw');
          }
        }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      /**
       * Initialise the wave
       *
       * @example
       * var wavesurfer = new WaveSurfer(params);
       * wavesurfer.init();
       * @return {this} The wavesurfer instance
       */


      _createClass(WaveSurfer, [{
        key: "init",
        value: function init() {
          this.registerPlugins(this.params.plugins);
          this.createDrawer();
          this.createBackend();
          this.createPeakCache();
          return this;
        }
        /**
         * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
         * this function is called in the init function of wavesurfer
         *
         * @param {PluginDefinition[]} plugins An array of plugin definitions
         * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "registerPlugins",
        value: function registerPlugins(plugins) {
          var _this2 = this;

          // first instantiate all the plugins
          plugins.forEach(function (plugin) {
            return _this2.addPlugin(plugin);
          }); // now run the init functions

          plugins.forEach(function (plugin) {
            // call init function of the plugin if deferInit is falsey
            // in that case you would manually use initPlugins()
            if (!plugin.deferInit) {
              _this2.initPlugin(plugin.name);
            }
          });
          this.fireEvent('plugins-registered', plugins);
          return this;
        }
        /**
         * Get a map of plugin names that are currently initialised
         *
         * @example wavesurfer.getPlugins();
         * @return {Object} Object with plugin names
         */

      }, {
        key: "getActivePlugins",
        value: function getActivePlugins() {
          return this.initialisedPluginList;
        }
        /**
         * Add a plugin object to wavesurfer
         *
         * @param {PluginDefinition} plugin A plugin definition
         * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
         * @example wavesurfer.addPlugin(WaveSurfer.minimap());
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "addPlugin",
        value: function addPlugin(plugin) {
          var _this3 = this;

          if (!plugin.name) {
            throw new Error('Plugin does not have a name!');
          }

          if (!plugin.instance) {
            throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
          } // staticProps properties are applied to wavesurfer instance


          if (plugin.staticProps) {
            Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
              /**
               * Properties defined in a plugin definition's `staticProps` property are added as
               * staticProps properties of the WaveSurfer instance
               */
              _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
            });
          }

          var Instance = plugin.instance; // turn the plugin instance into an observer

          var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
          observerPrototypeKeys.forEach(function (key) {
            Instance.prototype[key] = util.Observer.prototype[key];
          });
          /**
           * Instantiated plugin classes are added as a property of the wavesurfer
           * instance
           * @type {Object}
           */

          this[plugin.name] = new Instance(plugin.params || {}, this);
          this.fireEvent('plugin-added', plugin.name);
          return this;
        }
        /**
         * Initialise a plugin
         *
         * @param {string} name A plugin name
         * @emits WaveSurfer#plugin-initialised
         * @example wavesurfer.initPlugin('minimap');
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "initPlugin",
        value: function initPlugin(name) {
          if (!this[name]) {
            throw new Error("Plugin ".concat(name, " has not been added yet!"));
          }

          if (this.initialisedPluginList[name]) {
            // destroy any already initialised plugins
            this.destroyPlugin(name);
          }

          this[name].init();
          this.initialisedPluginList[name] = true;
          this.fireEvent('plugin-initialised', name);
          return this;
        }
        /**
         * Destroy a plugin
         *
         * @param {string} name A plugin name
         * @emits WaveSurfer#plugin-destroyed
         * @example wavesurfer.destroyPlugin('minimap');
         * @returns {this} The wavesurfer instance
         */

      }, {
        key: "destroyPlugin",
        value: function destroyPlugin(name) {
          if (!this[name]) {
            throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
          }

          if (!this.initialisedPluginList[name]) {
            throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
          }

          if (typeof this[name].destroy !== 'function') {
            throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
          }

          this[name].destroy();
          delete this.initialisedPluginList[name];
          this.fireEvent('plugin-destroyed', name);
          return this;
        }
        /**
         * Destroy all initialised plugins. Convenience function to use when
         * wavesurfer is removed
         *
         * @private
         */

      }, {
        key: "destroyAllPlugins",
        value: function destroyAllPlugins() {
          var _this4 = this;

          Object.keys(this.initialisedPluginList).forEach(function (name) {
            return _this4.destroyPlugin(name);
          });
        }
        /**
         * Create the drawer and draw the waveform
         *
         * @private
         * @emits WaveSurfer#drawer-created
         */

      }, {
        key: "createDrawer",
        value: function createDrawer() {
          var _this5 = this;

          this.drawer = new this.Drawer(this.container, this.params);
          this.drawer.init();
          this.fireEvent('drawer-created', this.drawer);

          if (this.params.responsive !== false) {
            window.addEventListener('resize', this._onResize, true);
            window.addEventListener('orientationchange', this._onResize, true);
          }

          this.drawer.on('redraw', function () {
            _this5.drawBuffer();

            _this5.drawer.progress(_this5.backend.getPlayedPercents());
          }); // Click-to-seek

          this.drawer.on('click', function (e, progress) {
            setTimeout(function () {
              return _this5.seekTo(progress);
            }, 0);
          }); // Relay the scroll event from the drawer

          this.drawer.on('scroll', function (e) {
            if (_this5.params.partialRender) {
              _this5.drawBuffer();
            }

            _this5.fireEvent('scroll', e);
          });
        }
        /**
         * Create the backend
         *
         * @private
         * @emits WaveSurfer#backend-created
         */

      }, {
        key: "createBackend",
        value: function createBackend() {
          var _this6 = this;

          if (this.backend) {
            this.backend.destroy();
          }

          this.backend = new this.Backend(this.params);
          this.backend.init();
          this.fireEvent('backend-created', this.backend);
          this.backend.on('finish', function () {
            _this6.drawer.progress(_this6.backend.getPlayedPercents());

            _this6.fireEvent('finish');
          });
          this.backend.on('play', function () {
            return _this6.fireEvent('play');
          });
          this.backend.on('pause', function () {
            return _this6.fireEvent('pause');
          });
          this.backend.on('audioprocess', function (time) {
            _this6.drawer.progress(_this6.backend.getPlayedPercents());

            _this6.fireEvent('audioprocess', time);
          }); // only needed for MediaElement and MediaElementWebAudio backend

          if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
            this.backend.on('seek', function () {
              _this6.drawer.progress(_this6.backend.getPlayedPercents());
            });
            this.backend.on('volume', function () {
              var newVolume = _this6.getVolume();

              _this6.fireEvent('volume', newVolume);

              if (_this6.backend.isMuted !== _this6.isMuted) {
                _this6.isMuted = _this6.backend.isMuted;

                _this6.fireEvent('mute', _this6.isMuted);
              }
            });
          }
        }
        /**
         * Create the peak cache
         *
         * @private
         */

      }, {
        key: "createPeakCache",
        value: function createPeakCache() {
          if (this.params.partialRender) {
            this.peakCache = new _peakcache.default();
          }
        }
        /**
         * Get the duration of the audio clip
         *
         * @example const duration = wavesurfer.getDuration();
         * @return {number} Duration in seconds
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          return this.backend.getDuration();
        }
        /**
         * Get the current playback position
         *
         * @example const currentTime = wavesurfer.getCurrentTime();
         * @return {number} Playback position in seconds
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.backend.getCurrentTime();
        }
        /**
         * Set the current play time in seconds.
         *
         * @param {number} seconds A positive number in seconds. E.g. 10 means 10
         * seconds, 60 means 1 minute
         */

      }, {
        key: "setCurrentTime",
        value: function setCurrentTime(seconds) {
          if (seconds >= this.getDuration()) {
            this.seekTo(1);
          } else {
            this.seekTo(seconds / this.getDuration());
          }
        }
        /**
         * Starts playback from the current position. Optional start and end
         * measured in seconds can be used to set the range of audio to play.
         *
         * @param {?number} start Position to start at
         * @param {?number} end Position to end at
         * @emits WaveSurfer#interaction
         * @return {Promise} Result of the backend play method
         * @example
         * // play from second 1 to 5
         * wavesurfer.play(1, 5);
         */

      }, {
        key: "play",
        value: function play(start, end) {
          var _this7 = this;

          this.fireEvent('interaction', function () {
            return _this7.play(start, end);
          });
          return this.backend.play(start, end);
        }
        /**
         * Set a point in seconds for playback to stop at.
         *
         * @param {number} position Position (in seconds) to stop at
         * @version 3.3.0
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(position) {
          this.backend.setPlayEnd(position);
        }
        /**
         * Stops and pauses playback
         *
         * @example wavesurfer.pause();
         * @return {Promise} Result of the backend pause method
         */

      }, {
        key: "pause",
        value: function pause() {
          if (!this.backend.isPaused()) {
            return this.backend.pause();
          }
        }
        /**
         * Toggle playback
         *
         * @example wavesurfer.playPause();
         * @return {Promise} Result of the backend play or pause method
         */

      }, {
        key: "playPause",
        value: function playPause() {
          return this.backend.isPaused() ? this.play() : this.pause();
        }
        /**
         * Get the current playback state
         *
         * @example const isPlaying = wavesurfer.isPlaying();
         * @return {boolean} False if paused, true if playing
         */

      }, {
        key: "isPlaying",
        value: function isPlaying() {
          return !this.backend.isPaused();
        }
        /**
         * Skip backward
         *
         * @param {?number} seconds Amount to skip back, if not specified `skipLength`
         * is used
         * @example wavesurfer.skipBackward();
         */

      }, {
        key: "skipBackward",
        value: function skipBackward(seconds) {
          this.skip(-seconds || -this.params.skipLength);
        }
        /**
         * Skip forward
         *
         * @param {?number} seconds Amount to skip back, if not specified `skipLength`
         * is used
         * @example wavesurfer.skipForward();
         */

      }, {
        key: "skipForward",
        value: function skipForward(seconds) {
          this.skip(seconds || this.params.skipLength);
        }
        /**
         * Skip a number of seconds from the current position (use a negative value
         * to go backwards).
         *
         * @param {number} offset Amount to skip back or forwards
         * @example
         * // go back 2 seconds
         * wavesurfer.skip(-2);
         */

      }, {
        key: "skip",
        value: function skip(offset) {
          var duration = this.getDuration() || 1;
          var position = this.getCurrentTime() || 0;
          position = Math.max(0, Math.min(duration, position + (offset || 0)));
          this.seekAndCenter(position / duration);
        }
        /**
         * Seeks to a position and centers the view
         *
         * @param {number} progress Between 0 (=beginning) and 1 (=end)
         * @example
         * // seek and go to the middle of the audio
         * wavesurfer.seekTo(0.5);
         */

      }, {
        key: "seekAndCenter",
        value: function seekAndCenter(progress) {
          this.seekTo(progress);
          this.drawer.recenter(progress);
        }
        /**
         * Seeks to a position
         *
         * @param {number} progress Between 0 (=beginning) and 1 (=end)
         * @emits WaveSurfer#interaction
         * @emits WaveSurfer#seek
         * @example
         * // seek to the middle of the audio
         * wavesurfer.seekTo(0.5);
         */

      }, {
        key: "seekTo",
        value: function seekTo(progress) {
          var _this8 = this;

          // return an error if progress is not a number between 0 and 1
          if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
            throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
          }

          this.fireEvent('interaction', function () {
            return _this8.seekTo(progress);
          });
          var isWebAudioBackend = this.params.backend === 'WebAudio';
          var paused = this.backend.isPaused();

          if (isWebAudioBackend && !paused) {
            this.backend.pause();
          } // avoid small scrolls while paused seeking


          var oldScrollParent = this.params.scrollParent;
          this.params.scrollParent = false;
          this.backend.seekTo(progress * this.getDuration());
          this.drawer.progress(progress);

          if (isWebAudioBackend && !paused) {
            this.backend.play();
          }

          this.params.scrollParent = oldScrollParent;
          this.fireEvent('seek', progress);
        }
        /**
         * Stops and goes to the beginning.
         *
         * @example wavesurfer.stop();
         */

      }, {
        key: "stop",
        value: function stop() {
          this.pause();
          this.seekTo(0);
          this.drawer.progress(0);
        }
        /**
         * Sets the ID of the audio device to use for output and returns a Promise.
         *
         * @param {string} deviceId String value representing underlying output
         * device
         * @returns {Promise} `Promise` that resolves to `undefined` when there are
         * no errors detected.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          return this.backend.setSinkId(deviceId);
        }
        /**
         * Set the playback volume.
         *
         * @param {number} newVolume A value between 0 and 1, 0 being no
         * volume and 1 being full volume.
         * @emits WaveSurfer#volume
         */

      }, {
        key: "setVolume",
        value: function setVolume(newVolume) {
          this.backend.setVolume(newVolume);
          this.fireEvent('volume', newVolume);
        }
        /**
         * Get the playback volume.
         *
         * @return {number} A value between 0 and 1, 0 being no
         * volume and 1 being full volume.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.backend.getVolume();
        }
        /**
         * Set the playback rate.
         *
         * @param {number} rate A positive number. E.g. 0.5 means half the normal
         * speed, 2 means double speed and so on.
         * @example wavesurfer.setPlaybackRate(2);
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(rate) {
          this.backend.setPlaybackRate(rate);
        }
        /**
         * Get the playback rate.
         *
         * @return {number} The current playback rate.
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.backend.getPlaybackRate();
        }
        /**
         * Toggle the volume on and off. If not currently muted it will save the
         * current volume value and turn the volume off. If currently muted then it
         * will restore the volume to the saved value, and then rest the saved
         * value.
         *
         * @example wavesurfer.toggleMute();
         */

      }, {
        key: "toggleMute",
        value: function toggleMute() {
          this.setMute(!this.isMuted);
        }
        /**
         * Enable or disable muted audio
         *
         * @param {boolean} mute Specify `true` to mute audio.
         * @emits WaveSurfer#volume
         * @emits WaveSurfer#mute
         * @example
         * // unmute
         * wavesurfer.setMute(false);
         * console.log(wavesurfer.getMute()) // logs false
         */

      }, {
        key: "setMute",
        value: function setMute(mute) {
          // ignore all muting requests if the audio is already in that state
          if (mute === this.isMuted) {
            this.fireEvent('mute', this.isMuted);
            return;
          }

          if (this.backend.setMute) {
            // Backends such as the MediaElement backend have their own handling
            // of mute, let them handle it.
            this.backend.setMute(mute);
            this.isMuted = mute;
          } else {
            if (mute) {
              // If currently not muted then save current volume,
              // turn off the volume and update the mute properties
              this.savedVolume = this.backend.getVolume();
              this.backend.setVolume(0);
              this.isMuted = true;
              this.fireEvent('volume', 0);
            } else {
              // If currently muted then restore to the saved volume
              // and update the mute properties
              this.backend.setVolume(this.savedVolume);
              this.isMuted = false;
              this.fireEvent('volume', this.savedVolume);
            }
          }

          this.fireEvent('mute', this.isMuted);
        }
        /**
         * Get the current mute status.
         *
         * @example const isMuted = wavesurfer.getMute();
         * @return {boolean} Current mute status
         */

      }, {
        key: "getMute",
        value: function getMute() {
          return this.isMuted;
        }
        /**
         * Get the list of current set filters as an array.
         *
         * Filters must be set with setFilters method first
         *
         * @return {array} List of enabled filters
         */

      }, {
        key: "getFilters",
        value: function getFilters() {
          return this.backend.filters || [];
        }
        /**
         * Toggles `scrollParent` and redraws
         *
         * @example wavesurfer.toggleScroll();
         */

      }, {
        key: "toggleScroll",
        value: function toggleScroll() {
          this.params.scrollParent = !this.params.scrollParent;
          this.drawBuffer();
        }
        /**
         * Toggle mouse interaction
         *
         * @example wavesurfer.toggleInteraction();
         */

      }, {
        key: "toggleInteraction",
        value: function toggleInteraction() {
          this.params.interact = !this.params.interact;
        }
        /**
         * Get the fill color of the waveform after the cursor.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getWaveColor",
        value: function getWaveColor() {
          return this.params.waveColor;
        }
        /**
         * Set the fill color of the waveform after the cursor.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setWaveColor('#ddd');
         */

      }, {
        key: "setWaveColor",
        value: function setWaveColor(color) {
          this.params.waveColor = color;
          this.drawBuffer();
        }
        /**
         * Get the fill color of the waveform behind the cursor.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getProgressColor",
        value: function getProgressColor() {
          return this.params.progressColor;
        }
        /**
         * Set the fill color of the waveform behind the cursor.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setProgressColor('#400');
         */

      }, {
        key: "setProgressColor",
        value: function setProgressColor(color) {
          this.params.progressColor = color;
          this.drawBuffer();
        }
        /**
         * Get the background color of the waveform container.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getBackgroundColor",
        value: function getBackgroundColor() {
          return this.params.backgroundColor;
        }
        /**
         * Set the background color of the waveform container.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setBackgroundColor('#FF00FF');
         */

      }, {
        key: "setBackgroundColor",
        value: function setBackgroundColor(color) {
          this.params.backgroundColor = color;
          util.style(this.container, {
            background: this.params.backgroundColor
          });
        }
        /**
         * Get the fill color of the cursor indicating the playhead
         * position.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getCursorColor",
        value: function getCursorColor() {
          return this.params.cursorColor;
        }
        /**
         * Set the fill color of the cursor indicating the playhead
         * position.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setCursorColor('#222');
         */

      }, {
        key: "setCursorColor",
        value: function setCursorColor(color) {
          this.params.cursorColor = color;
          this.drawer.updateCursor();
        }
        /**
         * Get the height of the waveform.
         *
         * @return {number} Height measured in pixels.
         */

      }, {
        key: "getHeight",
        value: function getHeight() {
          return this.params.height;
        }
        /**
         * Set the height of the waveform.
         *
         * @param {number} height Height measured in pixels.
         * @example wavesurfer.setHeight(200);
         */

      }, {
        key: "setHeight",
        value: function setHeight(height) {
          this.params.height = height;
          this.drawer.setHeight(height * this.params.pixelRatio);
          this.drawBuffer();
        }
        /**
         * Hide channels from being drawn on the waveform if splitting channels.
         *
         * For example, if we want to draw only the peaks for the right stereo channel:
         *
         * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
         * wavesurfer.load('stereo_audio.mp3');
         *
         * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
         *
         * @param {array} channelIndices Channels to be filtered out from drawing.
         * @version 4.0.0
         */

      }, {
        key: "setFilteredChannels",
        value: function setFilteredChannels(channelIndices) {
          this.params.splitChannelsOptions.filterChannels = channelIndices;
          this.drawBuffer();
        }
        /**
         * Get the correct peaks for current wave view-port and render wave
         *
         * @private
         * @emits WaveSurfer#redraw
         */

      }, {
        key: "drawBuffer",
        value: function drawBuffer() {
          var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
          var parentWidth = this.drawer.getWidth();
          var width = nominalWidth; // always start at 0 after zooming for scrolling : issue redraw left part

          var start = 0;
          var end = Math.max(start + parentWidth, width); // Fill container

          if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
            width = parentWidth;
            start = 0;
            end = width;
          }

          var peaks;

          if (this.params.partialRender) {
            var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
            var i;

            for (i = 0; i < newRanges.length; i++) {
              peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
              this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
            }
          } else {
            peaks = this.backend.getPeaks(width, start, end);
            this.drawer.drawPeaks(peaks, width, start, end);
          }

          this.fireEvent('redraw', peaks, width);
        }
        /**
         * Horizontally zooms the waveform in and out. It also changes the parameter
         * `minPxPerSec` and enables the `scrollParent` option. Calling the function
         * with a falsey parameter will reset the zoom state.
         *
         * @param {?number} pxPerSec Number of horizontal pixels per second of
         * audio, if none is set the waveform returns to unzoomed state
         * @emits WaveSurfer#zoom
         * @example wavesurfer.zoom(20);
         */

      }, {
        key: "zoom",
        value: function zoom(pxPerSec) {
          if (!pxPerSec) {
            this.params.minPxPerSec = this.defaultParams.minPxPerSec;
            this.params.scrollParent = false;
          } else {
            this.params.minPxPerSec = pxPerSec;
            this.params.scrollParent = true;
          }

          this.drawBuffer();
          this.drawer.progress(this.backend.getPlayedPercents());
          this.drawer.recenter(this.getCurrentTime() / this.getDuration());
          this.fireEvent('zoom', pxPerSec);
        }
        /**
         * Decode buffer and load
         *
         * @private
         * @param {ArrayBuffer} arraybuffer Buffer to process
         */

      }, {
        key: "loadArrayBuffer",
        value: function loadArrayBuffer(arraybuffer) {
          var _this9 = this;

          this.decodeArrayBuffer(arraybuffer, function (data) {
            if (!_this9.isDestroyed) {
              _this9.loadDecodedBuffer(data);
            }
          });
        }
        /**
         * Directly load an externally decoded AudioBuffer
         *
         * @private
         * @param {AudioBuffer} buffer Buffer to process
         * @emits WaveSurfer#ready
         */

      }, {
        key: "loadDecodedBuffer",
        value: function loadDecodedBuffer(buffer) {
          this.backend.load(buffer);
          this.drawBuffer();
          this.isReady = true;
          this.fireEvent('ready');
        }
        /**
         * Loads audio data from a Blob or File object
         *
         * @param {Blob|File} blob Audio data
         * @example
         */

      }, {
        key: "loadBlob",
        value: function loadBlob(blob) {
          var _this10 = this;

          // Create file reader
          var reader = new FileReader();
          reader.addEventListener('progress', function (e) {
            return _this10.onProgress(e);
          });
          reader.addEventListener('load', function (e) {
            return _this10.loadArrayBuffer(e.target.result);
          });
          reader.addEventListener('error', function () {
            return _this10.fireEvent('error', 'Error reading file');
          });
          reader.readAsArrayBuffer(blob);
          this.empty();
        }
        /**
         * Loads audio and re-renders the waveform.
         *
         * @param {string|HTMLMediaElement} url The url of the audio file or the
         * audio element with the audio
         * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
         * the audio to render the waveform if this is specified
         * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
         * `'none'|'metadata'|'auto'` Preload attribute for the media element
         * @param {?number} duration The duration of the audio. This is used to
         * render the peaks data in the correct size for the audio duration (as
         * befits the current `minPxPerSec` and zoom value) without having to decode
         * the audio.
         * @returns {void}
         * @throws Will throw an error if the `url` argument is empty.
         * @example
         * // uses fetch or media element to load file (depending on backend)
         * wavesurfer.load('http://example.com/demo.wav');
         *
         * // setting preload attribute with media element backend and supplying
         * // peaks
         * wavesurfer.load(
         *   'http://example.com/demo.wav',
         *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
         *   true
         * );
         */

      }, {
        key: "load",
        value: function load(url, peaks, preload, duration) {
          if (!url) {
            throw new Error('url parameter cannot be empty');
          }

          this.empty();

          if (preload) {
            // check whether the preload attribute will be usable and if not log
            // a warning listing the reasons why not and nullify the variable
            var preloadIgnoreReasons = {
              "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
              'Peaks are not provided': !peaks,
              "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
              'Url is not of type string': typeof url !== 'string'
            };
            var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
              return preloadIgnoreReasons[reason];
            });

            if (activeReasons.length) {
              // eslint-disable-next-line no-console
              console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- ')); // stop invalid values from being used

              preload = null;
            }
          } // loadBuffer(url, peaks, duration) requires that url is a string
          // but users can pass in a HTMLMediaElement to WaveSurfer


          if (this.params.backend === 'WebAudio' && url instanceof HTMLMediaElement) {
            url = url.src;
          }

          switch (this.params.backend) {
            case 'WebAudio':
              return this.loadBuffer(url, peaks, duration);

            case 'MediaElement':
            case 'MediaElementWebAudio':
              return this.loadMediaElement(url, peaks, preload, duration);
          }
        }
        /**
         * Loads audio using Web Audio buffer backend.
         *
         * @private
         * @emits WaveSurfer#waveform-ready
         * @param {string} url URL of audio file
         * @param {number[]|Number.<Array[]>} peaks Peaks data
         * @param {?number} duration Optional duration of audio file
         * @returns {void}
         */

      }, {
        key: "loadBuffer",
        value: function loadBuffer(url, peaks, duration) {
          var _this11 = this;

          var load = function load(action) {
            if (action) {
              _this11.tmpEvents.push(_this11.once('ready', action));
            }

            return _this11.getArrayBuffer(url, function (data) {
              return _this11.loadArrayBuffer(data);
            });
          };

          if (peaks) {
            this.backend.setPeaks(peaks, duration);
            this.drawBuffer();
            this.fireEvent('waveform-ready');
            this.tmpEvents.push(this.once('interaction', load));
          } else {
            return load();
          }
        }
        /**
         * Either create a media element, or load an existing media element.
         *
         * @private
         * @emits WaveSurfer#waveform-ready
         * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
         * existing HTML5 Audio/Video Element
         * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
         * dependency
         * @param {?boolean} preload Set to true if the preload attribute of the
         * audio element should be enabled
         * @param {?number} duration Optional duration of audio file
         */

      }, {
        key: "loadMediaElement",
        value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
          var _this12 = this;

          var url = urlOrElt;

          if (typeof urlOrElt === 'string') {
            this.backend.load(url, this.mediaContainer, peaks, preload);
          } else {
            var elt = urlOrElt;
            this.backend.loadElt(elt, peaks); // If peaks are not provided,
            // url = element.src so we can get peaks with web audio

            url = elt.src;
          }

          this.tmpEvents.push(this.backend.once('canplay', function () {
            // ignore when backend was already destroyed
            if (!_this12.backend.destroyed) {
              _this12.drawBuffer();

              _this12.isReady = true;

              _this12.fireEvent('ready');
            }
          }), this.backend.once('error', function (err) {
            return _this12.fireEvent('error', err);
          })); // If peaks are provided, render them and fire the `waveform-ready` event.

          if (peaks) {
            this.backend.setPeaks(peaks, duration);
            this.drawBuffer();
            this.fireEvent('waveform-ready');
          } // If no pre-decoded peaks are provided, or are provided with
          // forceDecode flag, attempt to download the audio file and decode it
          // with Web Audio.


          if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
            this.getArrayBuffer(url, function (arraybuffer) {
              _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
                _this12.backend.buffer = buffer;

                _this12.backend.setPeaks(null);

                _this12.drawBuffer();

                _this12.fireEvent('waveform-ready');
              });
            });
          }
        }
        /**
         * Decode an array buffer and pass data to a callback
         *
         * @private
         * @param {Object} arraybuffer The array buffer to decode
         * @param {function} callback The function to call on complete
         */

      }, {
        key: "decodeArrayBuffer",
        value: function decodeArrayBuffer(arraybuffer, callback) {
          var _this13 = this;

          this.arraybuffer = arraybuffer;
          this.backend.decodeArrayBuffer(arraybuffer, function (data) {
            // Only use the decoded data if we haven't been destroyed or
            // another decode started in the meantime
            if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
              callback(data);
              _this13.arraybuffer = null;
            }
          }, function () {
            return _this13.fireEvent('error', 'Error decoding audiobuffer');
          });
        }
        /**
         * Load an array buffer using fetch and pass the result to a callback
         *
         * @param {string} url The URL of the file object
         * @param {function} callback The function to call on complete
         * @returns {util.fetchFile} fetch call
         * @private
         */

      }, {
        key: "getArrayBuffer",
        value: function getArrayBuffer(url, callback) {
          var _this14 = this;

          var options = Object.assign({
            url: url,
            responseType: 'arraybuffer'
          }, this.params.xhr);
          var request = util.fetchFile(options);
          this.currentRequest = request;
          this.tmpEvents.push(request.on('progress', function (e) {
            _this14.onProgress(e);
          }), request.on('success', function (data) {
            callback(data);
            _this14.currentRequest = null;
          }), request.on('error', function (e) {
            _this14.fireEvent('error', e);

            _this14.currentRequest = null;
          }));
          return request;
        }
        /**
         * Called while the audio file is loading
         *
         * @private
         * @param {Event} e Progress event
         * @emits WaveSurfer#loading
         */

      }, {
        key: "onProgress",
        value: function onProgress(e) {
          var percentComplete;

          if (e.lengthComputable) {
            percentComplete = e.loaded / e.total;
          } else {
            // Approximate progress with an asymptotic
            // function, and assume downloads in the 1-3 MB range.
            percentComplete = e.loaded / (e.loaded + 1000000);
          }

          this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
        }
        /**
         * Exports PCM data into a JSON array and optionally opens in a new window
         * as valid JSON Blob instance.
         *
         * @param {number} length=1024 The scale in which to export the peaks
         * @param {number} accuracy=10000
         * @param {?boolean} noWindow Set to true to disable opening a new
         * window with the JSON
         * @param {number} start Start index
         * @param {number} end End index
         * @return {Promise} Promise that resolves with array of peaks
         */

      }, {
        key: "exportPCM",
        value: function exportPCM(length, accuracy, noWindow, start, end) {
          length = length || 1024;
          start = start || 0;
          accuracy = accuracy || 10000;
          noWindow = noWindow || false;
          var peaks = this.backend.getPeaks(length, start, end);
          var arr = [].map.call(peaks, function (val) {
            return Math.round(val * accuracy) / accuracy;
          });
          return new Promise(function (resolve, reject) {
            if (!noWindow) {
              var blobJSON = new Blob([JSON.stringify(arr)], {
                type: 'application/json;charset=utf-8'
              });
              var objURL = URL.createObjectURL(blobJSON);
              window.open(objURL);
              URL.revokeObjectURL(objURL);
            }

            resolve(arr);
          });
        }
        /**
         * Save waveform image as data URI.
         *
         * The default format is `'image/png'`. Other supported types are
         * `'image/jpeg'` and `'image/webp'`.
         *
         * @param {string} format='image/png' A string indicating the image format.
         * The default format type is `'image/png'`.
         * @param {number} quality=1 A number between 0 and 1 indicating the image
         * quality to use for image formats that use lossy compression such as
         * `'image/jpeg'`` and `'image/webp'`.
         * @param {string} type Image data type to return. Either 'dataURL' (default)
         * or 'blob'.
         * @return {string|string[]|Promise} When using `'dataURL'` type this returns
         * a single data URL or an array of data URLs, one for each canvas. When using
         * `'blob'` type this returns a `Promise` resolving with an array of `Blob`
         * instances, one for each canvas.
         */

      }, {
        key: "exportImage",
        value: function exportImage(format, quality, type) {
          if (!format) {
            format = 'image/png';
          }

          if (!quality) {
            quality = 1;
          }

          if (!type) {
            type = 'dataURL';
          }

          return this.drawer.getImage(format, quality, type);
        }
        /**
         * Cancel any fetch request currently in progress
         */

      }, {
        key: "cancelAjax",
        value: function cancelAjax() {
          if (this.currentRequest && this.currentRequest.controller) {
            // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
            // See: Wavesurfer issue #2042
            // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
            if (this.currentRequest._reader) {
              // Ignoring exceptions thrown by call to cancel()
              this.currentRequest._reader.cancel().catch(function (err) {});
            }

            this.currentRequest.controller.abort();
            this.currentRequest = null;
          }
        }
        /**
         * @private
         */

      }, {
        key: "clearTmpEvents",
        value: function clearTmpEvents() {
          this.tmpEvents.forEach(function (e) {
            return e.un();
          });
        }
        /**
         * Display empty waveform.
         */

      }, {
        key: "empty",
        value: function empty() {
          if (!this.backend.isPaused()) {
            this.stop();
            this.backend.disconnectSource();
          }

          this.isReady = false;
          this.cancelAjax();
          this.clearTmpEvents(); // empty drawer

          this.drawer.progress(0);
          this.drawer.setWidth(0);
          this.drawer.drawPeaks({
            length: this.drawer.getWidth()
          }, 0);
        }
        /**
         * Remove events, elements and disconnect WebAudio nodes.
         *
         * @emits WaveSurfer#destroy
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.destroyAllPlugins();
          this.fireEvent('destroy');
          this.cancelAjax();
          this.clearTmpEvents();
          this.unAll();

          if (this.params.responsive !== false) {
            window.removeEventListener('resize', this._onResize, true);
            window.removeEventListener('orientationchange', this._onResize, true);
          }

          if (this.backend) {
            this.backend.destroy(); // clears memory usage

            this.backend = null;
          }

          if (this.drawer) {
            this.drawer.destroy();
          }

          this.isDestroyed = true;
          this.isReady = false;
          this.arraybuffer = null;
        }
      }], [{
        key: "create",
        value:
        /** @private */

        /** @private */

        /**
         * Instantiate this class, call its `init` function and returns it
         *
         * @param {WavesurferParams} params The wavesurfer parameters
         * @return {Object} WaveSurfer instance
         * @example const wavesurfer = WaveSurfer.create(params);
         */
        function create(params) {
          var wavesurfer = new WaveSurfer(params);
          return wavesurfer.init();
        }
        /**
         * The library version number is available as a static property of the
         * WaveSurfer class
         *
         * @type {String}
         * @example
         * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
         */

      }]);

      return WaveSurfer;
    }(util.Observer);

    exports.default = WaveSurfer;
    WaveSurfer.VERSION = "5.1.0";
    WaveSurfer.util = util;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/webaudio.js":
    /*!*************************!*\
      !*** ./src/webaudio.js ***!
      \*************************/
    /***/ ((module, exports, __webpack_require__) => {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", ({
      value: true
    }));
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

    function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    // using constants to prevent someone writing the string wrong
    var PLAYING = 'playing';
    var PAUSED = 'paused';
    var FINISHED = 'finished';
    /**
     * WebAudio backend
     *
     * @extends {Observer}
     */

    var WebAudio = /*#__PURE__*/function (_util$Observer) {
      _inherits(WebAudio, _util$Observer);

      var _super = _createSuper(WebAudio);

      /**
       * Construct the backend
       *
       * @param {WavesurferParams} params Wavesurfer parameters
       */
      function WebAudio(params) {
        var _this$stateBehaviors, _this$states;

        var _this;

        _classCallCheck(this, WebAudio);

        _this = _super.call(this);
        /** @private */

        _this.audioContext = null;
        _this.offlineAudioContext = null;
        _this.stateBehaviors = (_this$stateBehaviors = {}, _defineProperty(_this$stateBehaviors, PLAYING, {
          init: function init() {
            this.addOnAudioProcess();
          },
          getPlayedPercents: function getPlayedPercents() {
            var duration = this.getDuration();
            return this.getCurrentTime() / duration || 0;
          },
          getCurrentTime: function getCurrentTime() {
            return this.startPosition + this.getPlayedTime();
          }
        }), _defineProperty(_this$stateBehaviors, PAUSED, {
          init: function init() {
            this.removeOnAudioProcess();
          },
          getPlayedPercents: function getPlayedPercents() {
            var duration = this.getDuration();
            return this.getCurrentTime() / duration || 0;
          },
          getCurrentTime: function getCurrentTime() {
            return this.startPosition;
          }
        }), _defineProperty(_this$stateBehaviors, FINISHED, {
          init: function init() {
            this.removeOnAudioProcess();
            this.fireEvent('finish');
          },
          getPlayedPercents: function getPlayedPercents() {
            return 1;
          },
          getCurrentTime: function getCurrentTime() {
            return this.getDuration();
          }
        }), _this$stateBehaviors);
        _this.params = params;
        /** ac: Audio Context instance */

        _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
        /**@private */

        _this.lastPlay = _this.ac.currentTime;
        /** @private */

        _this.startPosition = 0;
        /** @private */

        _this.scheduledPause = null;
        /** @private */

        _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
        /** @private */

        _this.buffer = null;
        /** @private */

        _this.filters = [];
        /** gainNode: allows to control audio volume */

        _this.gainNode = null;
        /** @private */

        _this.mergedPeaks = null;
        /** @private */

        _this.offlineAc = null;
        /** @private */

        _this.peaks = null;
        /** @private */

        _this.playbackRate = 1;
        /** analyser: provides audio analysis information */

        _this.analyser = null;
        /** scriptNode: allows processing audio */

        _this.scriptNode = null;
        /** @private */

        _this.source = null;
        /** @private */

        _this.splitPeaks = [];
        /** @private */

        _this.state = null;
        /** @private */

        _this.explicitDuration = params.duration;
        /**
         * Boolean indicating if the backend was destroyed.
         */

        _this.destroyed = false;
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(WebAudio, [{
        key: "supportsWebAudio",
        value:
        /** scriptBufferSize: size of the processing buffer */

        /** audioContext: allows to process audio with WebAudio API */

        /** @private */

        /** @private */

        /**
         * Does the browser support this backend
         *
         * @return {boolean} Whether or not this browser supports this backend
         */
        function supportsWebAudio() {
          return !!(window.AudioContext || window.webkitAudioContext);
        }
        /**
         * Get the audio context used by this backend or create one
         *
         * @return {AudioContext} Existing audio context, or creates a new one
         */

      }, {
        key: "getAudioContext",
        value: function getAudioContext() {
          if (!window.WaveSurferAudioContext) {
            window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          return window.WaveSurferAudioContext;
        }
        /**
         * Get the offline audio context used by this backend or create one
         *
         * @param {number} sampleRate The sample rate to use
         * @return {OfflineAudioContext} Existing offline audio context, or creates
         * a new one
         */

      }, {
        key: "getOfflineAudioContext",
        value: function getOfflineAudioContext(sampleRate) {
          if (!window.WaveSurferOfflineAudioContext) {
            window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
          }

          return window.WaveSurferOfflineAudioContext;
        }
      }, {
        key: "init",
        value: function init() {
          this.createVolumeNode();
          this.createScriptNode();
          this.createAnalyserNode();
          this.setState(PAUSED);
          this.setPlaybackRate(this.params.audioRate);
          this.setLength(0);
        }
        /** @private */

      }, {
        key: "disconnectFilters",
        value: function disconnectFilters() {
          if (this.filters) {
            this.filters.forEach(function (filter) {
              filter && filter.disconnect();
            });
            this.filters = null; // Reconnect direct path

            this.analyser.connect(this.gainNode);
          }
        }
        /**
         * @private
         *
         * @param {string} state The new state
         */

      }, {
        key: "setState",
        value: function setState(state) {
          if (this.state !== this.states[state]) {
            this.state = this.states[state];
            this.state.init.call(this);
          }
        }
        /**
         * Unpacked `setFilters()`
         *
         * @param {...AudioNode} filters One or more filters to set
         */

      }, {
        key: "setFilter",
        value: function setFilter() {
          for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
            filters[_key] = arguments[_key];
          }

          this.setFilters(filters);
        }
        /**
         * Insert custom Web Audio nodes into the graph
         *
         * @param {AudioNode[]} filters Packed filters array
         * @example
         * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
         * wavesurfer.backend.setFilter(lowpass);
         */

      }, {
        key: "setFilters",
        value: function setFilters(filters) {
          // Remove existing filters
          this.disconnectFilters(); // Insert filters if filter array not empty

          if (filters && filters.length) {
            this.filters = filters; // Disconnect direct path before inserting filters

            this.analyser.disconnect(); // Connect each filter in turn

            filters.reduce(function (prev, curr) {
              prev.connect(curr);
              return curr;
            }, this.analyser).connect(this.gainNode);
          }
        }
        /** Create ScriptProcessorNode to process audio */

      }, {
        key: "createScriptNode",
        value: function createScriptNode() {
          if (this.params.audioScriptProcessor) {
            this.scriptNode = this.params.audioScriptProcessor;
          } else {
            if (this.ac.createScriptProcessor) {
              this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
            } else {
              this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
            }
          }

          this.scriptNode.connect(this.ac.destination);
        }
        /** @private */

      }, {
        key: "addOnAudioProcess",
        value: function addOnAudioProcess() {
          var _this2 = this;

          this.scriptNode.onaudioprocess = function () {
            var time = _this2.getCurrentTime();

            if (time >= _this2.getDuration()) {
              _this2.setState(FINISHED);

              _this2.fireEvent('pause');
            } else if (time >= _this2.scheduledPause) {
              _this2.pause();
            } else if (_this2.state === _this2.states[PLAYING]) {
              _this2.fireEvent('audioprocess', time);
            }
          };
        }
        /** @private */

      }, {
        key: "removeOnAudioProcess",
        value: function removeOnAudioProcess() {
          this.scriptNode.onaudioprocess = null;
        }
        /** Create analyser node to perform audio analysis */

      }, {
        key: "createAnalyserNode",
        value: function createAnalyserNode() {
          this.analyser = this.ac.createAnalyser();
          this.analyser.connect(this.gainNode);
        }
        /**
         * Create the gain node needed to control the playback volume.
         *
         */

      }, {
        key: "createVolumeNode",
        value: function createVolumeNode() {
          // Create gain node using the AudioContext
          if (this.ac.createGain) {
            this.gainNode = this.ac.createGain();
          } else {
            this.gainNode = this.ac.createGainNode();
          } // Add the gain node to the graph


          this.gainNode.connect(this.ac.destination);
        }
        /**
         * Set the sink id for the media player
         *
         * @param {string} deviceId String value representing audio device id.
         * @returns {Promise} A Promise that resolves to `undefined` when there
         * are no errors.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          if (deviceId) {
            /**
             * The webaudio API doesn't currently support setting the device
             * output. Here we create an HTMLAudioElement, connect the
             * webaudio stream to that element and setSinkId there.
             */
            var audio = new window.Audio();

            if (!audio.setSinkId) {
              return Promise.reject(new Error('setSinkId is not supported in your browser'));
            }

            audio.autoplay = true;
            var dest = this.ac.createMediaStreamDestination();
            this.gainNode.disconnect();
            this.gainNode.connect(dest);
            audio.srcObject = dest.stream;
            return audio.setSinkId(deviceId);
          } else {
            return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
          }
        }
        /**
         * Set the audio volume
         *
         * @param {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "setVolume",
        value: function setVolume(value) {
          this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
        }
        /**
         * Get the current volume
         *
         * @return {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.gainNode.gain.value;
        }
        /**
         * Decode an array buffer and pass data to a callback
         *
         * @private
         * @param {ArrayBuffer} arraybuffer The array buffer to decode
         * @param {function} callback The function to call on complete.
         * @param {function} errback The function to call on error.
         */

      }, {
        key: "decodeArrayBuffer",
        value: function decodeArrayBuffer(arraybuffer, callback, errback) {
          if (!this.offlineAc) {
            this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
          }

          if ('webkitAudioContext' in window) {
            // Safari: no support for Promise-based decodeAudioData enabled
            // Enable it in Safari using the Experimental Features > Modern WebAudio API option
            this.offlineAc.decodeAudioData(arraybuffer, function (data) {
              return callback(data);
            }, errback);
          } else {
            this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
              return callback(data);
            }).catch(function (err) {
              return errback(err);
            });
          }
        }
        /**
         * Set pre-decoded peaks
         *
         * @param {number[]|Number.<Array[]>} peaks Peaks data
         * @param {?number} duration Explicit duration
         */

      }, {
        key: "setPeaks",
        value: function setPeaks(peaks, duration) {
          if (duration != null) {
            this.explicitDuration = duration;
          }

          this.peaks = peaks;
        }
        /**
         * Set the rendered length (different from the length of the audio)
         *
         * @param {number} length The rendered length
         */

      }, {
        key: "setLength",
        value: function setLength(length) {
          // No resize, we can preserve the cached peaks.
          if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
            return;
          }

          this.splitPeaks = [];
          this.mergedPeaks = []; // Set the last element of the sparse array so the peak arrays are
          // appropriately sized for other calculations.

          var channels = this.buffer ? this.buffer.numberOfChannels : 1;
          var c;

          for (c = 0; c < channels; c++) {
            this.splitPeaks[c] = [];
            this.splitPeaks[c][2 * (length - 1)] = 0;
            this.splitPeaks[c][2 * (length - 1) + 1] = 0;
          }

          this.mergedPeaks[2 * (length - 1)] = 0;
          this.mergedPeaks[2 * (length - 1) + 1] = 0;
        }
        /**
         * Compute the max and min value of the waveform when broken into <length> subranges.
         *
         * @param {number} length How many subranges to break the waveform into.
         * @param {number} first First sample in the required range.
         * @param {number} last Last sample in the required range.
         * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
         * peaks consisting of (max, min) values for each subrange.
         */

      }, {
        key: "getPeaks",
        value: function getPeaks(length, first, last) {
          if (this.peaks) {
            return this.peaks;
          }

          if (!this.buffer) {
            return [];
          }

          first = first || 0;
          last = last || length - 1;
          this.setLength(length);

          if (!this.buffer) {
            return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
          }
          /**
           * The following snippet fixes a buffering data issue on the Safari
           * browser which returned undefined It creates the missing buffer based
           * on 1 channel, 4096 samples and the sampleRate from the current
           * webaudio context 4096 samples seemed to be the best fit for rendering
           * will review this code once a stable version of Safari TP is out
           */


          if (!this.buffer.length) {
            var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
            this.buffer = newBuffer.buffer;
          }

          var sampleSize = this.buffer.length / length;
          var sampleStep = ~~(sampleSize / 10) || 1;
          var channels = this.buffer.numberOfChannels;
          var c;

          for (c = 0; c < channels; c++) {
            var peaks = this.splitPeaks[c];
            var chan = this.buffer.getChannelData(c);
            var i = void 0;

            for (i = first; i <= last; i++) {
              var start = ~~(i * sampleSize);
              var end = ~~(start + sampleSize);
              /**
               * Initialize the max and min to the first sample of this
               * subrange, so that even if the samples are entirely
               * on one side of zero, we still return the true max and
               * min values in the subrange.
               */

              var min = chan[start];
              var max = min;
              var j = void 0;

              for (j = start; j < end; j += sampleStep) {
                var value = chan[j];

                if (value > max) {
                  max = value;
                }

                if (value < min) {
                  min = value;
                }
              }

              peaks[2 * i] = max;
              peaks[2 * i + 1] = min;

              if (c == 0 || max > this.mergedPeaks[2 * i]) {
                this.mergedPeaks[2 * i] = max;
              }

              if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
                this.mergedPeaks[2 * i + 1] = min;
              }
            }
          }

          return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
        }
        /**
         * Get the position from 0 to 1
         *
         * @return {number} Position
         */

      }, {
        key: "getPlayedPercents",
        value: function getPlayedPercents() {
          return this.state.getPlayedPercents.call(this);
        }
        /** @private */

      }, {
        key: "disconnectSource",
        value: function disconnectSource() {
          if (this.source) {
            this.source.disconnect();
          }
        }
        /**
         * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
         */

      }, {
        key: "destroyWebAudio",
        value: function destroyWebAudio() {
          this.disconnectFilters();
          this.disconnectSource();
          this.gainNode.disconnect();
          this.scriptNode.disconnect();
          this.analyser.disconnect(); // close the audioContext if closeAudioContext option is set to true

          if (this.params.closeAudioContext) {
            // check if browser supports AudioContext.close()
            if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
              this.ac.close();
            } // clear the reference to the audiocontext


            this.ac = null; // clear the actual audiocontext, either passed as param or the
            // global singleton

            if (!this.params.audioContext) {
              window.WaveSurferAudioContext = null;
            } else {
              this.params.audioContext = null;
            } // clear the offlineAudioContext


            window.WaveSurferOfflineAudioContext = null;
          }
        }
        /**
         * This is called when wavesurfer is destroyed
         */

      }, {
        key: "destroy",
        value: function destroy() {
          if (!this.isPaused()) {
            this.pause();
          }

          this.unAll();
          this.buffer = null;
          this.destroyed = true;
          this.destroyWebAudio();
        }
        /**
         * Loaded a decoded audio buffer
         *
         * @param {Object} buffer Decoded audio buffer to load
         */

      }, {
        key: "load",
        value: function load(buffer) {
          this.startPosition = 0;
          this.lastPlay = this.ac.currentTime;
          this.buffer = buffer;
          this.createSource();
        }
        /** @private */

      }, {
        key: "createSource",
        value: function createSource() {
          this.disconnectSource();
          this.source = this.ac.createBufferSource(); // adjust for old browsers

          this.source.start = this.source.start || this.source.noteGrainOn;
          this.source.stop = this.source.stop || this.source.noteOff;
          this.setPlaybackRate(this.playbackRate);
          this.source.buffer = this.buffer;
          this.source.connect(this.analyser);
        }
        /**
         * @private
         *
         * some browsers require an explicit call to #resume before they will play back audio
         */

      }, {
        key: "resumeAudioContext",
        value: function resumeAudioContext() {
          if (this.ac.state == 'suspended') {
            this.ac.resume && this.ac.resume();
          }
        }
        /**
         * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
         *
         * @return {boolean} Whether or not this backend is currently paused
         */

      }, {
        key: "isPaused",
        value: function isPaused() {
          return this.state !== this.states[PLAYING];
        }
        /**
         * Used by `wavesurfer.getDuration()`
         *
         * @return {number} Duration of loaded buffer
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          if (this.explicitDuration) {
            return this.explicitDuration;
          }

          if (!this.buffer) {
            return 0;
          }

          return this.buffer.duration;
        }
        /**
         * Used by `wavesurfer.seekTo()`
         *
         * @param {number} start Position to start at in seconds
         * @param {number} end Position to end at in seconds
         * @return {{start: number, end: number}} Object containing start and end
         * positions
         */

      }, {
        key: "seekTo",
        value: function seekTo(start, end) {
          if (!this.buffer) {
            return;
          }

          this.scheduledPause = null;

          if (start == null) {
            start = this.getCurrentTime();

            if (start >= this.getDuration()) {
              start = 0;
            }
          }

          if (end == null) {
            end = this.getDuration();
          }

          this.startPosition = start;
          this.lastPlay = this.ac.currentTime;

          if (this.state === this.states[FINISHED]) {
            this.setState(PAUSED);
          }

          return {
            start: start,
            end: end
          };
        }
        /**
         * Get the playback position in seconds
         *
         * @return {number} The playback position in seconds
         */

      }, {
        key: "getPlayedTime",
        value: function getPlayedTime() {
          return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
        }
        /**
         * Plays the loaded audio region.
         *
         * @param {number} start Start offset in seconds, relative to the beginning
         * of a clip.
         * @param {number} end When to stop relative to the beginning of a clip.
         */

      }, {
        key: "play",
        value: function play(start, end) {
          if (!this.buffer) {
            return;
          } // need to re-create source on each playback


          this.createSource();
          var adjustedTime = this.seekTo(start, end);
          start = adjustedTime.start;
          end = adjustedTime.end;
          this.scheduledPause = end;
          this.source.start(0, start);
          this.resumeAudioContext();
          this.setState(PLAYING);
          this.fireEvent('play');
        }
        /**
         * Pauses the loaded audio.
         */

      }, {
        key: "pause",
        value: function pause() {
          this.scheduledPause = null;
          this.startPosition += this.getPlayedTime();
          this.source && this.source.stop(0);
          this.setState(PAUSED);
          this.fireEvent('pause');
        }
        /**
         * Returns the current time in seconds relative to the audio-clip's
         * duration.
         *
         * @return {number} The current time in seconds
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.state.getCurrentTime.call(this);
        }
        /**
         * Returns the current playback rate. (0=no playback, 1=normal playback)
         *
         * @return {number} The current playback rate
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.playbackRate;
        }
        /**
         * Set the audio source playback rate.
         *
         * @param {number} value The playback rate to use
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(value) {
          this.playbackRate = value || 1;
          this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
        }
        /**
         * Set a point in seconds for playback to stop at.
         *
         * @param {number} end Position to end at
         * @version 3.3.0
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(end) {
          this.scheduledPause = end;
        }
      }]);

      return WebAudio;
    }(util.Observer);

    exports.default = WebAudio;
    WebAudio.scriptBufferSize = 256;
    module.exports = exports.default;

    /***/ }),

    /***/ "./node_modules/debounce/index.js":
    /*!****************************************!*\
      !*** ./node_modules/debounce/index.js ***!
      \****************************************/
    /***/ ((module) => {

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing. The function also has a property 'clear' 
     * that is a function which will clear the timer to prevent previously scheduled executions. 
     *
     * @source underscore.js
     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
     * @param {Function} function to wrap
     * @param {Number} timeout in ms (`100`)
     * @param {Boolean} whether to execute at the beginning (`false`)
     * @api public
     */
    function debounce(func, wait, immediate){
      var timeout, args, context, timestamp, result;
      if (null == wait) wait = 100;

      function later() {
        var last = Date.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function(){
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };

      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          
          clearTimeout(timeout);
          timeout = null;
        }
      };

      return debounced;
    }
    // Adds compatibility for ES modules
    debounce.debounce = debounce;

    module.exports = debounce;


    /***/ })

    /******/ 	});
    /************************************************************************/
    /******/ 	// The module cache
    /******/ 	var __webpack_module_cache__ = {};
    /******/ 	
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/ 		// Check if module is in cache
    /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
    /******/ 		if (cachedModule !== undefined) {
    /******/ 			return cachedModule.exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = __webpack_module_cache__[moduleId] = {
    /******/ 			// no module.id needed
    /******/ 			// no module.loaded needed
    /******/ 			exports: {}
    /******/ 		};
    /******/ 	
    /******/ 		// Execute the module function
    /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    /******/ 	
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/ 	
    /************************************************************************/
    /******/ 	
    /******/ 	// startup
    /******/ 	// Load entry module and return exports
    /******/ 	// This entry module is referenced by other modules so it can't be inlined
    /******/ 	var __webpack_exports__ = __webpack_require__("./src/wavesurfer.js");
    /******/ 	
    /******/ 	return __webpack_exports__;
    /******/ })()
    ;
    });

    });

    var WaveSurfer = /*@__PURE__*/getDefaultExportFromCjs(wavesurfer);

    /**
     * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
     * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
     *
     * Copyright 2008-2020 Brian Turek, 1998-2009 Paul Johnston & Contributors
     * Distributed under the BSD License
     * See http://caligatio.github.com/jsSHA/ for more information
     */
    const t$2="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function r$1(t,r,n,i){let e,s,o;const h=r||[0],u=(n=n||0)>>>3,f=-1===i?3:0;for(e=0;e<t.length;e+=1)o=e+u,s=o>>>2,h.length<=s&&h.push(0),h[s]|=t[e]<<8*(f+i*(o%4));return {value:h,binLen:8*t.length+n}}function n$2(n,i,e){switch(i){case"UTF8":case"UTF16BE":case"UTF16LE":break;default:throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")}switch(n){case"HEX":return function(t,r,n){return function(t,r,n,i){let e,s,o,h;if(0!=t.length%2)throw new Error("String of HEX type must be in byte increments");const u=r||[0],f=(n=n||0)>>>3,c=-1===i?3:0;for(e=0;e<t.length;e+=2){if(s=parseInt(t.substr(e,2),16),isNaN(s))throw new Error("String of HEX type contains invalid characters");for(h=(e>>>1)+f,o=h>>>2;u.length<=o;)u.push(0);u[o]|=s<<8*(c+i*(h%4));}return {value:u,binLen:4*t.length+n}}(t,r,n,e)};case"TEXT":return function(t,r,n){return function(t,r,n,i,e){let s,o,h,u,f,c,a,w,E=0;const l=n||[0],A=(i=i||0)>>>3;if("UTF8"===r)for(a=-1===e?3:0,h=0;h<t.length;h+=1)for(s=t.charCodeAt(h),o=[],128>s?o.push(s):2048>s?(o.push(192|s>>>6),o.push(128|63&s)):55296>s||57344<=s?o.push(224|s>>>12,128|s>>>6&63,128|63&s):(h+=1,s=65536+((1023&s)<<10|1023&t.charCodeAt(h)),o.push(240|s>>>18,128|s>>>12&63,128|s>>>6&63,128|63&s)),u=0;u<o.length;u+=1){for(c=E+A,f=c>>>2;l.length<=f;)l.push(0);l[f]|=o[u]<<8*(a+e*(c%4)),E+=1;}else for(a=-1===e?2:0,w="UTF16LE"===r&&1!==e||"UTF16LE"!==r&&1===e,h=0;h<t.length;h+=1){for(s=t.charCodeAt(h),!0===w&&(u=255&s,s=u<<8|s>>>8),c=E+A,f=c>>>2;l.length<=f;)l.push(0);l[f]|=s<<8*(a+e*(c%4)),E+=2;}return {value:l,binLen:8*E+i}}(t,i,r,n,e)};case"B64":return function(r,n,i){return function(r,n,i,e){let s,o,h,u,f,c,a,w=0;const E=n||[0],l=(i=i||0)>>>3,A=-1===e?3:0,p=r.indexOf("=");if(-1===r.search(/^[a-zA-Z0-9=+/]+$/))throw new Error("Invalid character in base-64 string");if(r=r.replace(/=/g,""),-1!==p&&p<r.length)throw new Error("Invalid '=' found in base-64 string");for(o=0;o<r.length;o+=4){for(f=r.substr(o,4),u=0,h=0;h<f.length;h+=1)s=t$2.indexOf(f.charAt(h)),u|=s<<18-6*h;for(h=0;h<f.length-1;h+=1){for(a=w+l,c=a>>>2;E.length<=c;)E.push(0);E[c]|=(u>>>16-8*h&255)<<8*(A+e*(a%4)),w+=1;}}return {value:E,binLen:8*w+i}}(r,n,i,e)};case"BYTES":return function(t,r,n){return function(t,r,n,i){let e,s,o,h;const u=r||[0],f=(n=n||0)>>>3,c=-1===i?3:0;for(s=0;s<t.length;s+=1)e=t.charCodeAt(s),h=s+f,o=h>>>2,u.length<=o&&u.push(0),u[o]|=e<<8*(c+i*(h%4));return {value:u,binLen:8*t.length+n}}(t,r,n,e)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error("ARRAYBUFFER not supported by this environment")}return function(t,n,i){return function(t,n,i,e){return r$1(new Uint8Array(t),n,i,e)}(t,n,i,e)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error("UINT8ARRAY not supported by this environment")}return function(t,n,i){return r$1(t,n,i,e)};default:throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}function i$3(r,n,i,e){switch(r){case"HEX":return function(t){return function(t,r,n,i){let e,s,o="";const h=r/8,u=-1===n?3:0;for(e=0;e<h;e+=1)s=t[e>>>2]>>>8*(u+n*(e%4)),o+="0123456789abcdef".charAt(s>>>4&15)+"0123456789abcdef".charAt(15&s);return i.outputUpper?o.toUpperCase():o}(t,n,i,e)};case"B64":return function(r){return function(r,n,i,e){let s,o,h,u,f,c="";const a=n/8,w=-1===i?3:0;for(s=0;s<a;s+=3)for(u=s+1<a?r[s+1>>>2]:0,f=s+2<a?r[s+2>>>2]:0,h=(r[s>>>2]>>>8*(w+i*(s%4))&255)<<16|(u>>>8*(w+i*((s+1)%4))&255)<<8|f>>>8*(w+i*((s+2)%4))&255,o=0;o<4;o+=1)c+=8*s+6*o<=n?t$2.charAt(h>>>6*(3-o)&63):e.b64Pad;return c}(r,n,i,e)};case"BYTES":return function(t){return function(t,r,n){let i,e,s="";const o=r/8,h=-1===n?3:0;for(i=0;i<o;i+=1)e=t[i>>>2]>>>8*(h+n*(i%4))&255,s+=String.fromCharCode(e);return s}(t,n,i)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error("ARRAYBUFFER not supported by this environment")}return function(t){return function(t,r,n){let i;const e=r/8,s=new ArrayBuffer(e),o=new Uint8Array(s),h=-1===n?3:0;for(i=0;i<e;i+=1)o[i]=t[i>>>2]>>>8*(h+n*(i%4))&255;return s}(t,n,i)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error("UINT8ARRAY not supported by this environment")}return function(t){return function(t,r,n){let i;const e=r/8,s=-1===n?3:0,o=new Uint8Array(e);for(i=0;i<e;i+=1)o[i]=t[i>>>2]>>>8*(s+n*(i%4))&255;return o}(t,n,i)};default:throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}function e$1(t){const r={outputUpper:!1,b64Pad:"=",outputLen:-1},n=t||{},i="Output length must be a multiple of 8";if(r.outputUpper=n.outputUpper||!1,n.b64Pad&&(r.b64Pad=n.b64Pad),n.outputLen){if(n.outputLen%8!=0)throw new Error(i);r.outputLen=n.outputLen;}else if(n.shakeLen){if(n.shakeLen%8!=0)throw new Error(i);r.outputLen=n.shakeLen;}if("boolean"!=typeof r.outputUpper)throw new Error("Invalid outputUpper formatting option");if("string"!=typeof r.b64Pad)throw new Error("Invalid b64Pad formatting option");return r}function s$2(t,r){return t<<r|t>>>32-r}function o$1(t,r,n){return t^r^n}function h$2(t,r,n){return t&r^t&n^r&n}function u$1(t,r){const n=(65535&t)+(65535&r);return (65535&(t>>>16)+(r>>>16)+(n>>>16))<<16|65535&n}function f$2(t,r,n,i,e){const s=(65535&t)+(65535&r)+(65535&n)+(65535&i)+(65535&e);return (65535&(t>>>16)+(r>>>16)+(n>>>16)+(i>>>16)+(e>>>16)+(s>>>16))<<16|65535&s}function c$2(t){return [1732584193,4023233417,2562383102,271733878,3285377520]}function a$1(t,r){let n,i,e,c,a,w,E;const l=[];for(n=r[0],i=r[1],e=r[2],c=r[3],a=r[4],E=0;E<80;E+=1)l[E]=E<16?t[E]:s$2(l[E-3]^l[E-8]^l[E-14]^l[E-16],1),w=E<20?f$2(s$2(n,5),(A=i)&e^~A&c,a,1518500249,l[E]):E<40?f$2(s$2(n,5),o$1(i,e,c),a,1859775393,l[E]):E<60?f$2(s$2(n,5),h$2(i,e,c),a,2400959708,l[E]):f$2(s$2(n,5),o$1(i,e,c),a,3395469782,l[E]),a=c,c=e,e=s$2(i,30),i=n,n=w;var A;return r[0]=u$1(n,r[0]),r[1]=u$1(i,r[1]),r[2]=u$1(e,r[2]),r[3]=u$1(c,r[3]),r[4]=u$1(a,r[4]),r}function w$2(t,r,n,i){let e;const s=15+(r+65>>>9<<4),o=r+n;for(;t.length<=s;)t.push(0);for(t[r>>>5]|=128<<24-r%32,t[s]=4294967295&o,t[s-1]=o/4294967296|0,e=0;e<t.length;e+=16)i=a$1(t.slice(e,e+16),i);return i}class JsSHA$1 extends class{constructor(t,r,n){const i=n||{};if(this.t=r,this.i=i.encoding||"UTF8",this.numRounds=i.numRounds||1,isNaN(this.numRounds)||this.numRounds!==parseInt(this.numRounds,10)||1>this.numRounds)throw new Error("numRounds must a integer >= 1");this.s=t,this.o=[],this.h=0,this.u=!1,this.l=0,this.A=!1,this.p=[],this.R=[];}update(t){let r,n=0;const i=this.U>>>5,e=this.T(t,this.o,this.h),s=e.binLen,o=e.value,h=s>>>5;for(r=0;r<h;r+=i)n+this.U<=s&&(this.F=this.m(o.slice(r,r+i),this.F),n+=this.U);this.l+=n,this.o=o.slice(n>>>5),this.h=s%this.U,this.u=!0;}getHash(t,r){let n,s,o=this.g;const h=e$1(r);if(this.B){if(-1===h.outputLen)throw new Error("Output length must be specified in options");o=h.outputLen;}const u=i$3(t,o,this.v,h);if(this.A&&this.Y)return u(this.Y(h));for(s=this.H(this.o.slice(),this.h,this.l,this.C(this.F),o),n=1;n<this.numRounds;n+=1)this.B&&o%32!=0&&(s[s.length-1]&=16777215>>>24-o%32),s=this.H(s,o,0,this.I(this.s),o);return u(s)}setHMACKey(t,r,i){if(!this.L)throw new Error("Variant does not support HMAC");if(this.u)throw new Error("Cannot set MAC key after calling update");const e=n$2(r,(i||{}).encoding||"UTF8",this.v);this.M(e(t));}M(t){const r=this.U>>>3,n=r/4-1;let i;if(1!==this.numRounds)throw new Error("Cannot set numRounds with MAC");if(this.A)throw new Error("MAC key already set");for(r<t.binLen/8&&(t.value=this.H(t.value,t.binLen,0,this.I(this.s),this.g));t.value.length<=n;)t.value.push(0);for(i=0;i<=n;i+=1)this.p[i]=909522486^t.value[i],this.R[i]=1549556828^t.value[i];this.F=this.m(this.p,this.F),this.l=this.U,this.A=!0;}getHMAC(t,r){const n=e$1(r);return i$3(t,this.g,this.v,n)(this.N())}N(){let t;if(!this.A)throw new Error("Cannot call getHMAC without first setting MAC key");const r=this.H(this.o.slice(),this.h,this.l,this.C(this.F),this.g);return t=this.m(this.R,this.I(this.s)),t=this.H(r,this.g,this.U,t,this.g),t}}{constructor(t,r,i){if("SHA-1"!==t)throw new Error("Chosen SHA variant is not supported");super(t,r,i);const e=i||{};this.L=!0,this.Y=this.N,this.v=-1,this.T=n$2(this.t,this.i,this.v),this.m=a$1,this.C=function(t){return t.slice()},this.I=c$2,this.H=w$2,this.F=[1732584193,4023233417,2562383102,271733878,3285377520],this.U=512,this.g=160,this.B=!1,e.hmacKey&&this.M(function(t,r,i,e){const s=t+" must include a value and format";if(!r){if(!e)throw new Error(s);return e}if(void 0===r.value||!r.format)throw new Error(s);return n$2(r.format,r.encoding||"UTF8",i)(r.value)}("hmacKey",e.hmacKey,this.v));}}

    /*! Fast Average Color | © 2021 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */
    function toHex(num) {
        const str = num.toString(16);

        return str.length === 1 ? '0' + str : str;
    }

    function arrayToHex(arr) {
        return '#' + arr.map(toHex).join('');
    }

    function isDark(color) {
        // http://www.w3.org/TR/AERT#color-contrast
        const result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;

        return result < 128;
    }

    function prepareIgnoredColor(color) {
        if (!color) { return color; }

        if (Array.isArray(color)) {
            return typeof color[0] === 'number' ? [color.slice()] : color;
        }

        return [color];
    }

    function isIgnoredColor(data, index, ignoredColor) {
        for (let i = 0; i < ignoredColor.length; i++) {
            if (isIgnoredColorAsNumbers(data, index, ignoredColor[i])) {
                return true;
            }
        }

        return false;
    }

    function isIgnoredColorAsNumbers(data, index, ignoredColor) {
        switch (ignoredColor.length) {
            case 3:
                // [red, green, blue]
                if (isIgnoredRGBColor(data, index, ignoredColor)) {
                    return true;
                }

                break;
            case 4:
                // [red, green, blue, alpha]
                if (isIgnoredRGBAColor(data, index, ignoredColor)) {
                    return true;
                }

                break;
            case 5:
                // [red, green, blue, alpha, threshold]
                if (isIgnoredRGBAColorWithThreshold(data, index, ignoredColor)) {
                    return true;
                }

                break;
            default:
                return false;
        }
    }

    function isIgnoredRGBColor(data, index, ignoredColor) {
        // Ignore if the pixel are transparent.
        if (data[index + 3] !== 255) {
            return true;
        }

        if (data[index] === ignoredColor[0] &&
            data[index + 1] === ignoredColor[1] &&
            data[index + 2] === ignoredColor[2]
        ) {
            return true;
        }

        return false;
    }

    function isIgnoredRGBAColor(data, index, ignoredColor) {
        if (data[index + 3] && ignoredColor[3]) {
            return data[index] === ignoredColor[0] &&
                data[index + 1] === ignoredColor[1] &&
                data[index + 2] === ignoredColor[2] &&
                data[index + 3] === ignoredColor[3];
        }

        // Ignore rgb components if the pixel are fully transparent.
        return data[index + 3] === ignoredColor[3];
    }

    function inRange(colorComponent, ignoredColorComponent, value) {
        return colorComponent >= (ignoredColorComponent - value) &&
            colorComponent <= (ignoredColorComponent + value);
    }

    function isIgnoredRGBAColorWithThreshold(data, index, ignoredColor) {
        const redIgnored = ignoredColor[0];
        const greenIgnored = ignoredColor[1];
        const blueIgnored = ignoredColor[2];
        const alphaIgnored = ignoredColor[3];
        const threshold = ignoredColor[4];
        const alphaData = data[index + 3];

        const alphaInRange = inRange(alphaData, alphaIgnored, threshold);
        if (!alphaIgnored) {
            return alphaInRange;
        }

        if (!alphaData && alphaInRange) {
            return true;
        }

        if (inRange(data[index], redIgnored, threshold) &&
            inRange(data[index + 1], greenIgnored, threshold) &&
            inRange(data[index + 2], blueIgnored, threshold) &&
            alphaInRange
        ) {
            return true;
        }

        return false;
    }

    function dominantAlgorithm(arr, len, options) {
        const colorHash = {};
        const divider = 24;
        const ignoredColor = options.ignoredColor;
        const step = options.step;
        let max = [0, 0, 0, 0, 0];
        
        for (let i = 0; i < len; i += step) {
            const red = arr[i];
            const green = arr[i + 1];
            const blue = arr[i + 2];
            const alpha = arr[i + 3];

            if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {
                continue;
            }

            const key = Math.round(red / divider) + ',' +
                    Math.round(green / divider) + ',' +
                    Math.round(blue / divider);

            if (colorHash[key]) {
                colorHash[key] = [
                    colorHash[key][0] + red * alpha,
                    colorHash[key][1] + green * alpha,
                    colorHash[key][2] + blue * alpha,
                    colorHash[key][3] + alpha,
                    colorHash[key][4] + 1
                ];
            } else {
                colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];
            }
            
            if (max[4] < colorHash[key][4]) {
                max = colorHash[key];
            }
        }

        const redTotal = max[0];
        const greenTotal = max[1];
        const blueTotal = max[2];

        const alphaTotal = max[3];
        const count = max[4];

        return alphaTotal ? [
            Math.round(redTotal / alphaTotal),
            Math.round(greenTotal / alphaTotal),
            Math.round(blueTotal / alphaTotal),
            Math.round(alphaTotal / count)
        ] : options.defaultColor;
    }

    function simpleAlgorithm(arr, len, options) {
        let redTotal = 0;
        let greenTotal = 0;
        let blueTotal = 0;
        let alphaTotal = 0;
        let count = 0;

        const ignoredColor = options.ignoredColor;
        const step = options.step;

        for (let i = 0; i < len; i += step) {
            const alpha = arr[i + 3];
            const red = arr[i] * alpha;
            const green = arr[i + 1] * alpha;
            const blue = arr[i + 2] * alpha;

            if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {
                continue;
            }

            redTotal += red;
            greenTotal += green;
            blueTotal += blue;
            alphaTotal += alpha;

            count++;
        }

        return alphaTotal ? [
            Math.round(redTotal / alphaTotal),
            Math.round(greenTotal / alphaTotal),
            Math.round(blueTotal / alphaTotal),
            Math.round(alphaTotal / count)
        ] : options.defaultColor;
    }

    function sqrtAlgorithm(arr, len, options) {
        let redTotal = 0;
        let greenTotal = 0;
        let blueTotal = 0;
        let alphaTotal = 0;
        let count = 0;

        const ignoredColor = options.ignoredColor;
        const step = options.step;

        for (let i = 0; i < len; i += step) {
            const red = arr[i];
            const green = arr[i + 1];
            const blue = arr[i + 2];
            const alpha = arr[i + 3];

            if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {
                continue;
            }

            redTotal += red * red * alpha;
            greenTotal += green * green * alpha;
            blueTotal += blue * blue * alpha;
            alphaTotal += alpha;

            count++;
        }

        return alphaTotal ? [
            Math.round(Math.sqrt(redTotal / alphaTotal)),
            Math.round(Math.sqrt(greenTotal / alphaTotal)),
            Math.round(Math.sqrt(blueTotal / alphaTotal)),
            Math.round(alphaTotal / count)
        ] : options.defaultColor;
    }

    function getDefaultColor(options) {
        return getOption(options, 'defaultColor', [0, 0, 0, 0]);
    }

    function getOption(options, name, defaultValue) {
        return typeof options[name] === 'undefined' ? defaultValue : options[name];
    }

    const MIN_SIZE = 10;
    const MAX_SIZE = 100;

    function isSvg(filename) {
        return filename.search(/\.svg(\?|$)/i) !== -1;
    }

    function getOriginalSize(resource) {
        if (resource instanceof HTMLImageElement) {
            let width = resource.naturalWidth;
            let height = resource.naturalHeight;

            // For SVG images with only viewBox attr.
            if (!resource.naturalWidth && isSvg(resource.src)) {
                width = height = MAX_SIZE;
            }

            return {
                width,
                height,
            };
        }

        if (resource instanceof HTMLVideoElement) {
            return {
                width: resource.videoWidth,
                height: resource.videoHeight
            };
        }

        return {
            width: resource.width,
            height: resource.height
        };
    }

    function prepareSizeAndPosition(originalSize, options) {
        const srcLeft = getOption(options, 'left', 0);
        const srcTop = getOption(options, 'top', 0);
        const srcWidth = getOption(options, 'width', originalSize.width);
        const srcHeight = getOption(options, 'height', originalSize.height);

        let destWidth = srcWidth;
        let destHeight = srcHeight;

        if (options.mode === 'precision') {
            return {
                srcLeft,
                srcTop,
                srcWidth,
                srcHeight,
                destWidth,
                destHeight
            };
        }

        let factor;

        if (srcWidth > srcHeight) {
            factor = srcWidth / srcHeight;
            destWidth = MAX_SIZE;
            destHeight = Math.round(destWidth / factor);
        } else {
            factor = srcHeight / srcWidth;
            destHeight = MAX_SIZE;
            destWidth = Math.round(destHeight / factor);
        }

        if (
            destWidth > srcWidth || destHeight > srcHeight ||
            destWidth < MIN_SIZE || destHeight < MIN_SIZE
        ) {
            destWidth = srcWidth;
            destHeight = srcHeight;
        }

        return {
            srcLeft,
            srcTop,
            srcWidth,
            srcHeight,
            destWidth,
            destHeight
        };
    }

    function makeCanvas() {
        return typeof window === 'undefined' ?
            new OffscreenCanvas(1, 1) :
            document.createElement('canvas');
    }

    const ERROR_PREFIX = 'FastAverageColor: ';

    function outputError(options, text, details) {
        if (!options.silent) {
            console.error(ERROR_PREFIX + text);

            if (details) {
                console.error(details);
            }
        }
    }

    function getError(text) {
        return Error(ERROR_PREFIX + text);
    }

    class FastAverageColor {
        /**
         * Get asynchronously the average color from not loaded image.
         *
         * @param {string | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource
         * @param {FastAverageColorOptions} [options]
         *
         * @returns {Promise<FastAverageColorOptions>}
         */
        getColorAsync(resource, options) {
            if (!resource) {
                return Promise.reject(getError('call .getColorAsync() without resource.'));
            }

            if (typeof resource === 'string') {
                const img = new Image();
                img.crossOrigin = '';
                img.src = resource;

                return this._bindImageEvents(img, options);
            } else if (resource instanceof Image && !resource.complete) {
                return this._bindImageEvents(resource, options);
            } else {
                const result = this.getColor(resource, options);

                return result.error ? Promise.reject(result.error) : Promise.resolve(result);
            }
        }

        /**
         * Get the average color from images, videos and canvas.
         *
         * @param {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource
         * @param {FastAverageColorOptions} [options]
         *
         * @returns {FastAverageColorResult}
         */
        getColor(resource, options) {
            options = options || {};

            const defaultColor = getDefaultColor(options);

            if (!resource) {
                outputError(options, 'call .getColor(null) without resource.');

                return this.prepareResult(defaultColor);
            }

            const originalSize = getOriginalSize(resource);
            const size = prepareSizeAndPosition(originalSize, options);

            if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {
                outputError(options, `incorrect sizes for resource "${resource.src}".`);

                return this.prepareResult(defaultColor);
            }

            if (!this._ctx) {
                this._canvas = makeCanvas();
                this._ctx = this._canvas.getContext && this._canvas.getContext('2d');

                if (!this._ctx) {
                    outputError(options, 'Canvas Context 2D is not supported in this browser.');

                    return this.prepareResult(defaultColor);
                }
            }

            this._canvas.width = size.destWidth;
            this._canvas.height = size.destHeight;

            let value = defaultColor;

            try {
                this._ctx.clearRect(0, 0, size.destWidth, size.destHeight);
                this._ctx.drawImage(
                    resource,
                    size.srcLeft, size.srcTop,
                    size.srcWidth, size.srcHeight,
                    0, 0,
                    size.destWidth, size.destHeight
                );

                const bitmapData = this._ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;
                value = this.getColorFromArray4(bitmapData, options);
            } catch (e) {
                outputError(options, `security error (CORS) for resource ${resource.src}.\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image`, e);
            }

            return this.prepareResult(value);
        }

        /**
         * Get the average color from a array when 1 pixel is 4 bytes.
         *
         * @param {number[]|Uint8Array|Uint8ClampedArray} arr
         * @param {Object} [options]
         * @param {string} [options.algorithm="sqrt"] "simple", "sqrt" or "dominant"
         * @param {number[]}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]
         * @param {number[]}  [options.ignoredColor] [red, green, blue, alpha]
         * @param {number} [options.step=1]
         *
         * @returns {number[]} [red (0-255), green (0-255), blue (0-255), alpha (0-255)]
         */
        getColorFromArray4(arr, options) {
            options = options || {};

            const bytesPerPixel = 4;
            const arrLength = arr.length;
            const defaultColor = getDefaultColor(options);

            if (arrLength < bytesPerPixel) {
                return defaultColor;
            }

            const len = arrLength - arrLength % bytesPerPixel;
            const step = (options.step || 1) * bytesPerPixel;

            let algorithm;

            switch (options.algorithm || 'sqrt') {
                case 'simple':
                    algorithm = simpleAlgorithm;
                    break;
                case 'sqrt':
                    algorithm = sqrtAlgorithm;
                    break;
                case 'dominant':
                    algorithm = dominantAlgorithm;
                    break;
                default:
                    throw getError(`${options.algorithm} is unknown algorithm.`);
            }

            return algorithm(arr, len, {
                defaultColor,
                ignoredColor: prepareIgnoredColor(options.ignoredColor),
                step
            });
        }

        /**
         * Get color data from value ([r, g, b, a]).
         *
         * @param {number[]} value
         *
         * @returns {FastAverageColorResult}
         */
        prepareResult(value) {
            const rgb = value.slice(0, 3);
            const rgba = [].concat(rgb, value[3] / 255);
            const isDarkColor = isDark(value);

            return {
                value,
                rgb: 'rgb(' + rgb.join(',') + ')',
                rgba: 'rgba(' + rgba.join(',') + ')',
                hex: arrayToHex(rgb),
                hexa: arrayToHex(value),
                isDark: isDarkColor,
                isLight: !isDarkColor
            };
        }

        /**
         * Destroy the instance.
         */
        destroy() {
            delete this._canvas;
            delete this._ctx;
        }

        _bindImageEvents(resource, options) {
            return new Promise((resolve, reject) => {
                const onload = () => {
                    unbindEvents();

                    const result = this.getColor(resource, options);

                    if (result.error) {
                        reject(result.error);
                    } else {
                        resolve(result);
                    }
                };

                const onerror = () => {
                    unbindEvents();

                    reject(getError(`Error loading image "${resource.src}".`));
                };

                const onabort = () => {
                    unbindEvents();

                    reject(getError(`Image "${resource.src}" loading aborted.`));
                };

                const unbindEvents = () => {
                    resource.removeEventListener('load', onload);
                    resource.removeEventListener('error', onerror);
                    resource.removeEventListener('abort', onabort);
                };

                resource.addEventListener('load', onload);
                resource.addEventListener('error', onerror);
                resource.addEventListener('abort', onabort);
            });
        }
    }

    function n$1(n){if(!("number"==typeof n?0<=n&&n<=255:n.every((function(n){return 0<=n&&n<=255}))))throw new RangeError("RGB channel value shoud be in range [0, 255].")}function t$1(n){return n.map((function(n){return function(n,r,t){return void 0===t&&(t=0),Math.min(Math.max(n,t),r)}(n,255)}))}var i$2=24389/27,c$1=216/24389,f$1=[.96422,1,.82521],s$1=Math.pow,h$1=Math.cbrt;function v(r){return n$1(r),t=function(n){var r=function(n){return n.map((function(n){var r=n/255;return r<.04045?r/12.92:s$1((r+.055)/1.055,2.4)}))}(n),t=r[0],a=r[1],u=r[2];return [.4360747*t+.3850649*a+.1430804*u,.2225045*t+.7168786*a+.0606169*u,.0139322*t+.0971045*a+.7141733*u]}(r),[116*(a=t.map((function(n,r){return n/f$1[r]})).map((function(n){return n>c$1?h$1(n):(i$2*n+16)/116})))[1]-16,500*(a[0]-a[1]),200*(a[1]-a[2])];var t,a;}function l$1(n){if(n<0||n>=360)throw new RangeError("Hue channel value shoud be in range [0, 360).")}function m(n){if(n<0)throw new RangeError("CIE lightness channel value shoud be positive.")}var M=Math.atan2,b=Math.PI,g=Math.sqrt,w$1=Math.pow;function T(n){var r=n[0],t=n[1],a=n[2];m(r);var u=180*M(a,t)/b;return [r,g(w$1(t,2)+w$1(a,2)),u>=0?u:u+360]}function d$1(n){return T(v(n))}var U$1=Math.cos,$=Math.sin,z=Math.PI;function D(n){var r=n[0],t=n[1],a=n[2];return l$1(a),[r,t*U$1(a*z/180),t*$(a*z/180)]}var F=Math.pow;function J(n){return m(n[0]),t$1(function(n){var r=n[0],t=n[1],a=n[2];return [3.1338561*r+-1.6168667*t+-.4906146*a,-.9787684*r+1.9161415*t+.033454*a,.0719453*r+-.2289914*t+1.4052427*a]}((a=(r=n)[0],u=r[1],e=r[2],h=(o=(a+16)/116)-e/200,[F(s=u/500+o,3)>c$1?F(s,3):(116*s-16)/i$2,a>8?F((a+16)/116,3):a/i$2,F(h,3)>c$1?F(h,3):(116*h-16)/i$2].map((function(n,r){return n*f$1[r]})))).map((function(n){return 255*(n>.0031308?1.055*F(n,1/2.4)-.055:12.92*n)})));var r,a,u,e,o,s,h;}function K(n){return l$1(n[2]),J(D(n))}

    let debugEnabled = get_store_value(debugMode);

    /**
     * Output debug lines if enabled
     * @param val
     * @param description
     */
    const debugHelper = (val, description = "--") => {
        if (debugEnabled) {
            console.log(description, val);
        }
    };

    const shuffleArray = (arr) => {
        for (let i = 0; i < arr.length; i++) {
            const j = Math.floor(Math.random() * i);
            const temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

        return arr;
    };

    /**
     * Format seconds into an hours:mins:secs string
     * @param {number} secs
     * @returns {string}
     */
    const formatTotalTime = (secs) => {
        return new Date(secs * 1000).toISOString().substr(11, 8).replace(/^0+\:?/, '');
    };

    /**
     * Format seconds into track length string
     * @param {number} secs
     * @returns {*}
     */
    // Courtesy of https://stackoverflow.com/a/37770048
    const formatSongLength = (secs) => {
        return (secs - (secs %= 60)) / 60 + (9 < Math.floor(secs) ? ':' : ':0') + Math.floor(secs);
    };

    /**
     * Format seconds into readable duration
     * @param {number} secs
     * @returns {*}
     */
    // Courtesy of https://stackoverflow.com/a/52387803/4968507
    const formatTimeToReadable = (secs) => {
        secs = Number(secs);
        let d = Math.floor(secs / (3600*24));
        let h = Math.floor(secs % (3600*24) / 3600);
        let m = Math.floor(secs % 3600 / 60);
        let s = Math.floor(secs % 60);

        let dDisplay = d > 0 ? d + (d === 1 ? " day, " : " days, ") : "";
        let hDisplay = h > 0 ? h + (h === 1 ? " hour, " : " hours, ") : "";
        let mDisplay = m > 0 ? m + (m === 1 ? " minute, " : " minutes, ") : "";
        let sDisplay = s > 0 ? s + (s === 1 ? " second" : " seconds") : "";
        return (dDisplay + hDisplay + mDisplay + sDisplay).replace(/,\s*$/, "");
    };

    // Courtesy of https://stackoverflow.com/a/23352499
    const timeSince = (timeStamp) => {
        let now = new Date(),
            secondsPast = (now.getTime() - timeStamp.getTime() ) / 1000;

        if (secondsPast < 60) { // seconds
            // return parseInt(secondsPast) + 's';
            return "<1m";
        }
        if (secondsPast < 3600 * 2) { // minutes, use minutes for the first 2 hours
            return parseInt(secondsPast/60) + 'm';
        }
        if (secondsPast <= 86400) { // hours
            return parseInt(secondsPast/3600) + 'h';
        }
        if (secondsPast > 86400) {
            let day = timeStamp.getDate();
            let month = timeStamp.toDateString().match(/ [a-zA-Z]*/)[0].replace(" ","");
            let year = timeStamp.getFullYear() === now.getFullYear() ? "" :  " "+timeStamp.getFullYear();
            return day + " " + month + year;
        }
    };

    /**
     * Generate a random integer
     * @param max
     * @returns {number}
     */
    function getRandomInt(max) {
        return Math.floor(Math.random() * max);
    }

    /**
     Get hash of image and compare it to the placeholder art
     Based on https://stackoverflow.com/a/16566198/4968507
     */
    async function placeholderArtCheck(url) {
        // Calculate placeholder hash each time as canvas results can and do differ
        // across sessions, making it impractical to hardcode results
        let results = [];
        let images = [
            get_store_value(serverURL) + '/image.php?object_id=0&object_type=album&thumb=10',
            url
        ];

        try {
            for (let i = 0; i < images.length; i++) {
                let img = new Image();
                img.setAttribute('crossOrigin', 'anonymous');
                img.src = images[i];
                await img.decode(); // this is key as it waits until the image is ready

                let canvas = document.createElement("canvas");
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                let ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                let dataURL = canvas.toDataURL("image/png");
                let shaObj = new JsSHA$1("SHA-1", "TEXT", { encoding: "UTF8" });
                shaObj.update(dataURL);

                let backgroundHash = shaObj.getHash("HEX");
                results[i] = backgroundHash;

                debugHelper(backgroundHash, "placeholderArtCheck");
            }

            return results[0] !== results[1];
        } catch (e) {
            console.warn('error during placeholder art check', e);
            return false;
        }
    }

    /**
     Get dominant color from image
     */
    async function getAverageColor(url) {
        let finalColor;
        const img = new Image();
        const fac = new FastAverageColor();

        img.setAttribute('crossOrigin', 'anonymous');
        img.src = url;
        await img.decode();

        finalColor = fac.getColor(img, {
            ignoredColor: [
                [255, 255, 255, 255, 128], // white, with threshold
                [0, 0, 0, 255, 30] // black, with threshold
            ]
        });

        debugHelper(finalColor, "getAverageColor");

        return finalColor;
    }

    /**
     * Expects Lch colorArray
     * @param color
     * @returns {boolean}
     */
    function colorIsAcceptable(color) {
        // If not enough color
        if (color.chroma < 10) {
            debugHelper(color, "not enough color");
            return false;
        }

        // If too dark
        if (color.lightness < 10) {
            debugHelper(color, "too dark");
            return false;
        }

        return true;
    }

    /**
     Turn color into legible versions
     */
    async function getLegibleColors(color) {
        let colorArray = [];
        let legibleColor = {
            light: [],
            dark: []
        };

        // Convert RGB (normalized to 0-1) to Lch
        let lchColor = d$1([color[0], color[1], color[2]]);

        colorArray.lightness = lchColor[0];
        colorArray.chroma    = lchColor[1];
        colorArray.hue       = lchColor[2];

        if (!colorIsAcceptable(colorArray)) {
            return;
        }

        // DEFAULTS
        legibleColor.light.nearWhite      = [97,  2,  colorArray.hue];
        legibleColor.light.highlight      = [50,  49, colorArray.hue];
        legibleColor.light.foreground     = [7,   35, colorArray.hue];
        legibleColor.light.interface      = [95,  5,  colorArray.hue];
        legibleColor.light.interfaceHover = [100, 5,  colorArray.hue];
        legibleColor.light.background     = [85,  3,  colorArray.hue];

        legibleColor.dark.nearWhite      = [90, 50, colorArray.hue];
        legibleColor.dark.highlight      = [73, 84, colorArray.hue];
        legibleColor.dark.foreground     = [90, 30, colorArray.hue];
        legibleColor.dark.interface      = [12, 15, colorArray.hue];
        legibleColor.dark.interfaceHover = [20, 15, colorArray.hue];
        legibleColor.dark.background     = [3,  3,  colorArray.hue];

        // convert to a usable format
        for (let [key, value] of Object.entries(legibleColor)) {
            for (let [key2, value2] of Object.entries(value)) {
                // convert back to RBG
                legibleColor[key][key2] = K([legibleColor[key][key2][0], legibleColor[key][key2][1], legibleColor[key][key2][2]]);
            }
        }

        debugHelper(legibleColor, "getLegibleColors");

        document.body.classList.add('useCustomColors');

        return legibleColor;
    }

    let NowPlayingQueue = writable([]);
    let NowPlayingIndex = writable(0);

    let IsPlaying = writable(false);
    let IsMuted = writable(false);
    let CurrentSong = writable(null);

    let SearchQuery = writable('');
    let ShowSearch = writable(false);

    let RepeatEnabled = writable(JSON.parse(localStorage.getItem('RepeatEnabled')) || false);
    let VolumeNormalizationEnabled = writable(JSON.parse(localStorage.getItem('VolumeNormalizationEnabled')) || false);
    let DynamicsCompressorEnabled = writable(JSON.parse(localStorage.getItem('DynamicsCompressorEnabled')) || false);

    let AutoPlayEnabled = writable(JSON.parse(localStorage.getItem('AutoPlayEnabled')) || false);
    let AutoPlayPlaylist = writable(JSON.parse(localStorage.getItem('AutoPlayPlaylist')) || null);

    let ShowExpandedAlbums = writable(false);
    let ShowAlbumArtistsOnly = writable(true);

    let ThemeIsLight = writable(JSON.parse(localStorage.getItem('AmpleThemeIsLight')) || false);

    /**
     * Interface with wavesurfer.js
     */
    class Player$1 {
        /**
         * Initialize data
         */
        constructor() {
            this.wavesurfer = null;
            this.defaultTitle = document.title;
            this.id = null;
            this.stopQueued = false;
            this.globalVolume = 0.5;

            // volume normalization
            this.targetVolume = parseInt(-14);
            this.masteredVolume = null;
            this.gainNeeded = null;
            this.gainValue = null;
            this.gainType = null;
            this.gainTagValue = null;

            // filter nodes
            this.activeFilters = [];
            this.filterGain = null;
            this.filterCompressor = null;
            this.filterBiquad = null; //(for testing only)

            NowPlayingQueue.subscribe(value => {
                this.nowPlayingQueue = value;
            });

            NowPlayingIndex.subscribe(value => {
                this.nowPlayingIndex = value;
            });

            IsPlaying.subscribe(value => {
                this.isPlaying = value;
            });

            IsMuted.subscribe(value => {
                this.isMuted = value;
            });

            VolumeNormalizationEnabled.subscribe(value => {
                this.volumeNormalizationEnabled = value;
            });

            DynamicsCompressorEnabled.subscribe(value => {
                this.dynamicsCompressorEnabled = value;
            });

            CurrentSong.subscribe(value => {
                this.currentSong = value;
            });

            RepeatEnabled.subscribe(value => {
                this.repeatEnabled = value;
            });
        }

        async setWaveColors() {
            if (this.wavesurfer) {
                await tick();
                this.wavesurfer.setProgressColor(getComputedStyle(document.body).getPropertyValue('--color-waveform-progress'));
                this.wavesurfer.setWaveColor(getComputedStyle(document.body).getPropertyValue('--color-waveform-wave'));
            }
        }

        initFilters() {
            if (this.wavesurfer) {
                this.filterGain = this.wavesurfer.backend.ac.createGain();

                this.filterCompressor = this.wavesurfer.backend.ac.createDynamicsCompressor();
                this.filterCompressor.threshold.value = -50;
                this.filterCompressor.knee.value = 0.0;
                this.filterCompressor.ratio.value = 20.0;
                this.filterCompressor.attack.value = 0.005; // 5ms
                this.filterCompressor.release.value = 0.050; // 50ms

                this.filterBiquad = this.wavesurfer.backend.ac.createBiquadFilter();
            }
        }

        async updateFilters() {
            if (this.wavesurfer) {
                await tick();
                this.activeFilters = [];

                // 1. gain
                if (this.volumeNormalizationEnabled && this.gainType !== "None") {
                    this.activeFilters.push(this.filterGain);
                }

                // 2. dynamics compressor
                if (this.dynamicsCompressorEnabled) {
                    this.activeFilters.push(this.filterCompressor);
                }

                // last. biquad (for testing only)
                // this.activeFilters.push(this.filterBiquad);

                debugHelper(this.activeFilters, 'Active filters');

                // finally, apply any filters
                this.wavesurfer.backend.setFilters(this.activeFilters);

                // redraw waveform regardless
                this.wavesurfer.drawBuffer();
            }
        }

        /**
         * Clear the queue
         */
        clearQueue() {
            this.stopQueued = true;
            this.stop();
            CurrentSong.set(null);
            NowPlayingQueue.set([]);
            NowPlayingIndex.set(0);
            IsPlaying.set(false);
        }

        /**
         * Restart the queue
         */
        restartQueue() {
            if (this.repeatEnabled) {
                debugHelper('queue restarted');
                NowPlayingIndex.set(0);
                this.start(this.nowPlayingQueue[0]);
            } else {
                this.clearQueue();
            }
        }

        /**
         * Create wavesurfer and begin playing
         */
        async start(song) {
            let self = this;

            debugHelper('start!');

            // Load from queue if no song is directly passed
            if (!song) {
                song = this.nowPlayingQueue[this.nowPlayingIndex];
            }

            if (song) {
                CurrentSong.set(song);
                document.title = song.title + " - " + song.artist.name;
            } else {
                debugHelper('No song IDs could be found');
                document.title = this.defaultTitle;
                this.clearQueue();
                return false;
            }

            try {
                this.wavesurfer = WaveSurfer.create({
                    backend: 'MediaElementWebAudio',
                    container: '#waveform',
                    height: document.querySelector(".site-player__waveform").offsetHeight,
                    barMinHeight: 1,
                    cursorWidth: 0,
                    normalize: true,
                    responsive: true,
                    hideScrollbar: true,
                });

                this.initFilters();
                this.filterGain.gain.value = this.calculateGain();
                this.wavesurfer.setVolume(this.globalVolume);
                this.wavesurfer.load(this.currentSong.url);

                await this.updateFilters();

                this.wavesurfer.on('play', function () {
                    debugHelper('Wavesurfer playing');
                    IsPlaying.set(true);
                    self.recordLastPlayed();
                });

                this.wavesurfer.on('pause', function () {
                    debugHelper('Wavesurfer paused');
                    IsPlaying.set(false);
                });

                this.wavesurfer.on('finish', function () {
                    debugHelper('Wavesurfer finished');
                    self.next();
                });

                this.wavesurfer.on('ready', function () {
                    debugHelper('Wavesurfer ready');

                    self.setWaveColors();

                    if (self.stopQueued) {
                        self.stop();
                    }
                });

                this.wavesurfer.on('volume', function (e) {
                    debugHelper('Wavesurfer volume updated');
                    self.globalVolume = e;
                });

                this.wavesurfer.on('error', function (e) {
                    debugHelper('Wavesurfer play error', e);

                    // TODO clarify these errors
                    // IsPlaying.set(false);

                    if (e !== null) {
                        debugHelper('Wavesurfer load error?', e);
                        // self.next();
                    }
                });

                this.wavesurfer.play();
            } catch (e) {
                console.warn('Something went wrong during start', e);
                self.next();
            }
        }

        recordLastPlayed() {
            let self = this;

            if (this.wavesurfer && this.wavesurfer.getCurrentTime() > 3) {
                // add/update lastPlayed property
                this.nowPlayingQueue[this.nowPlayingIndex].lastPlayed = Date.now();

                // update the store with our modified object
                NowPlayingQueue.set(this.nowPlayingQueue);
            } else {
                window.setTimeout(function() {
                    self.recordLastPlayed();
                }, 500);
            }
        }

        /**
         * Stop playback and destroy wavesurfer
         */
        stop() {
            if (this.wavesurfer) {
                this.wavesurfer.cancelAjax();
                delete this.wavesurfer.backend.buffer;
                this.wavesurfer.destroy();
                this.wavesurfer = null;
            }

            this.stopQueued = false;
        }

        /**
         * Play/pause Howl
         */
        playPause() {
            debugHelper('play/pause!');

            if (this.wavesurfer) {
                if (this.wavesurfer.isPlaying()) {
                    this.wavesurfer.pause();
                } else {
                    this.wavesurfer.play();
                }
            } else {
                this.start();
            }
        }

        /**
         * Play previous song
         */
        previous() {
            debugHelper('previous!');

            if (this.nowPlayingIndex > -1) {

                // If playback has passed a certain point, restart song instead
                if (this.wavesurfer.getCurrentTime() < 3) {
                    NowPlayingIndex.update(n => n - 1);
                }
            }

            this.stop();
            this.start(this.nowPlayingQueue[this.nowPlayingIndex]);
        }

        /**
         * Play next song
         */
        next() {
            debugHelper('next!');

            this.stop();

            // Increment index and play next
            if (this.nowPlayingIndex + 1 < this.nowPlayingQueue.length) {
                NowPlayingIndex.update(n => n + 1);
                this.start(this.nowPlayingQueue[this.nowPlayingIndex]);
            } else {
                this.restartQueue();
            }
        }

        /**
         * Shuffle all existing songs in queue
         */
        shuffle() {
            let tempArray = get_store_value(NowPlayingQueue);

            this.clearQueue();

            tempArray = shuffleArray(tempArray);

            NowPlayingQueue.set(tempArray);
            NowPlayingIndex.set(0);
            this.start();
        }

        /**
         * Toggle repeat of queue
         */
        repeat() {
            let inverted = !this.repeatEnabled;
            localStorage.setItem('RepeatEnabled', JSON.stringify(inverted));
            RepeatEnabled.set(inverted);
            debugHelper('repeat: ' + this.repeatEnabled);
        }

        /**
         * Replace queue with selected songs
         * @param {object} songs
         */
        playNow(songs) {
            this.clearQueue();
            NowPlayingQueue.set(songs);
            this.start();
        }

        /**
         * Insert songs after currently playing song
         * @param {object} songs
         */
        playNext(songs) {
            let tempArray = get_store_value(NowPlayingQueue);
            let queueLength = tempArray.length;
            tempArray.splice(this.nowPlayingIndex + 1, 0, ...songs);
            NowPlayingQueue.set(tempArray);

            // Start playing if queue was empty
            if (queueLength === 0) {
                this.start();
            }
        }

        /**
         * Add songs to the end of the queue
         * @param {object} songs
         */
        playLast(songs) {
            let tempArray = get_store_value(NowPlayingQueue);
            let queueLength = tempArray.length;
            tempArray.push(...songs);
            NowPlayingQueue.set(tempArray);

            // Start playing if queue was empty
            if (queueLength === 0) {
                this.start();
            }
        }

        /**
         * Play song at this index
         * @param {number} index
         */
        playSelected(index) {
            if (this.wavesurfer) {
                this.wavesurfer.destroy();
            }

            NowPlayingIndex.set(index);

            this.start();
        }

        /**
         * Calculate gain (R128 & ReplayGain)
         * @returns {number} gainLevel
         */
        calculateGain() {
            // defaults
            let gainLevel = 0;
            let replayGain = 0;

            this.masteredVolume = 0;
            this.gainNeeded = 0;

            let r128_track_gain = this.currentSong.r128_track_gain;
            let rg_track_gain = this.currentSong.replaygain_track_gain;

            if (r128_track_gain !== null) { // R128 PREFERRED
                this.gainType = 'EBU R128';

                replayGain = parseInt(r128_track_gain / 256); // LU/dB away from baseline of -23 LUFS/dB, stored as Q7.8 (2 ^ 8) https://datatracker.ietf.org/doc/html/rfc7845.html#section-5.2.1
                const referenceLevel = parseInt(-23); // LUFS https://en.wikipedia.org/wiki/EBU_R_128#Specification
                let masteredVolume = referenceLevel - replayGain;
                let difference = this.targetVolume - masteredVolume;

                gainLevel = difference;

                this.masteredVolume = masteredVolume;
                this.gainNeeded = gainLevel.toFixed(2);

                gainLevel = Math.pow(10, (gainLevel / 20));
            } else if (rg_track_gain !== null) { // Replay Gain fallback
                this.gainType = 'ReplayGain';

                replayGain = parseFloat(rg_track_gain);
                this.gainTagValue = replayGain;

                gainLevel = replayGain;

                this.gainNeeded = gainLevel.toFixed(2);

                gainLevel = Math.pow(10, (gainLevel / 20));
            } else {
                this.gainType = 'None';
            }

            return gainLevel;
        }
    }

    let ampleVersion = readable("0.8.0");

    let MediaPlayer = writable(new Player$1);

    let customColors = writable(null);

    /**
     * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
     * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
     *
     * Copyright 2008-2020 Brian Turek, 1998-2009 Paul Johnston & Contributors
     * Distributed under the BSD License
     * See http://caligatio.github.com/jsSHA/ for more information
     */
    const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function r(t,r,n,i){let e,s,o;const h=r||[0],u=(n=n||0)>>>3,f=-1===i?3:0;for(e=0;e<t.length;e+=1)o=e+u,s=o>>>2,h.length<=s&&h.push(0),h[s]|=t[e]<<8*(f+i*(o%4));return {value:h,binLen:8*t.length+n}}function n(n,i,e){switch(i){case"UTF8":case"UTF16BE":case"UTF16LE":break;default:throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")}switch(n){case"HEX":return function(t,r,n){return function(t,r,n,i){let e,s,o,h;if(0!=t.length%2)throw new Error("String of HEX type must be in byte increments");const u=r||[0],f=(n=n||0)>>>3,c=-1===i?3:0;for(e=0;e<t.length;e+=2){if(s=parseInt(t.substr(e,2),16),isNaN(s))throw new Error("String of HEX type contains invalid characters");for(h=(e>>>1)+f,o=h>>>2;u.length<=o;)u.push(0);u[o]|=s<<8*(c+i*(h%4));}return {value:u,binLen:4*t.length+n}}(t,r,n,e)};case"TEXT":return function(t,r,n){return function(t,r,n,i,e){let s,o,h,u,f,c,a,w,A=0;const E=n||[0],l=(i=i||0)>>>3;if("UTF8"===r)for(a=-1===e?3:0,h=0;h<t.length;h+=1)for(s=t.charCodeAt(h),o=[],128>s?o.push(s):2048>s?(o.push(192|s>>>6),o.push(128|63&s)):55296>s||57344<=s?o.push(224|s>>>12,128|s>>>6&63,128|63&s):(h+=1,s=65536+((1023&s)<<10|1023&t.charCodeAt(h)),o.push(240|s>>>18,128|s>>>12&63,128|s>>>6&63,128|63&s)),u=0;u<o.length;u+=1){for(c=A+l,f=c>>>2;E.length<=f;)E.push(0);E[f]|=o[u]<<8*(a+e*(c%4)),A+=1;}else for(a=-1===e?2:0,w="UTF16LE"===r&&1!==e||"UTF16LE"!==r&&1===e,h=0;h<t.length;h+=1){for(s=t.charCodeAt(h),!0===w&&(u=255&s,s=u<<8|s>>>8),c=A+l,f=c>>>2;E.length<=f;)E.push(0);E[f]|=s<<8*(a+e*(c%4)),A+=2;}return {value:E,binLen:8*A+i}}(t,i,r,n,e)};case"B64":return function(r,n,i){return function(r,n,i,e){let s,o,h,u,f,c,a,w=0;const A=n||[0],E=(i=i||0)>>>3,l=-1===e?3:0,p=r.indexOf("=");if(-1===r.search(/^[a-zA-Z0-9=+/]+$/))throw new Error("Invalid character in base-64 string");if(r=r.replace(/=/g,""),-1!==p&&p<r.length)throw new Error("Invalid '=' found in base-64 string");for(o=0;o<r.length;o+=4){for(f=r.substr(o,4),u=0,h=0;h<f.length;h+=1)s=t.indexOf(f.charAt(h)),u|=s<<18-6*h;for(h=0;h<f.length-1;h+=1){for(a=w+E,c=a>>>2;A.length<=c;)A.push(0);A[c]|=(u>>>16-8*h&255)<<8*(l+e*(a%4)),w+=1;}}return {value:A,binLen:8*w+i}}(r,n,i,e)};case"BYTES":return function(t,r,n){return function(t,r,n,i){let e,s,o,h;const u=r||[0],f=(n=n||0)>>>3,c=-1===i?3:0;for(s=0;s<t.length;s+=1)e=t.charCodeAt(s),h=s+f,o=h>>>2,u.length<=o&&u.push(0),u[o]|=e<<8*(c+i*(h%4));return {value:u,binLen:8*t.length+n}}(t,r,n,e)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error("ARRAYBUFFER not supported by this environment")}return function(t,n,i){return function(t,n,i,e){return r(new Uint8Array(t),n,i,e)}(t,n,i,e)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error("UINT8ARRAY not supported by this environment")}return function(t,n,i){return r(t,n,i,e)};default:throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}function i$1(r,n,i,e){switch(r){case"HEX":return function(t){return function(t,r,n,i){let e,s,o="";const h=r/8,u=-1===n?3:0;for(e=0;e<h;e+=1)s=t[e>>>2]>>>8*(u+n*(e%4)),o+="0123456789abcdef".charAt(s>>>4&15)+"0123456789abcdef".charAt(15&s);return i.outputUpper?o.toUpperCase():o}(t,n,i,e)};case"B64":return function(r){return function(r,n,i,e){let s,o,h,u,f,c="";const a=n/8,w=-1===i?3:0;for(s=0;s<a;s+=3)for(u=s+1<a?r[s+1>>>2]:0,f=s+2<a?r[s+2>>>2]:0,h=(r[s>>>2]>>>8*(w+i*(s%4))&255)<<16|(u>>>8*(w+i*((s+1)%4))&255)<<8|f>>>8*(w+i*((s+2)%4))&255,o=0;o<4;o+=1)c+=8*s+6*o<=n?t.charAt(h>>>6*(3-o)&63):e.b64Pad;return c}(r,n,i,e)};case"BYTES":return function(t){return function(t,r,n){let i,e,s="";const o=r/8,h=-1===n?3:0;for(i=0;i<o;i+=1)e=t[i>>>2]>>>8*(h+n*(i%4))&255,s+=String.fromCharCode(e);return s}(t,n,i)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error("ARRAYBUFFER not supported by this environment")}return function(t){return function(t,r,n){let i;const e=r/8,s=new ArrayBuffer(e),o=new Uint8Array(s),h=-1===n?3:0;for(i=0;i<e;i+=1)o[i]=t[i>>>2]>>>8*(h+n*(i%4))&255;return s}(t,n,i)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error("UINT8ARRAY not supported by this environment")}return function(t){return function(t,r,n){let i;const e=r/8,s=-1===n?3:0,o=new Uint8Array(e);for(i=0;i<e;i+=1)o[i]=t[i>>>2]>>>8*(s+n*(i%4))&255;return o}(t,n,i)};default:throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}const e=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],s=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],o=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];function h(t){const r={outputUpper:!1,b64Pad:"=",outputLen:-1},n=t||{},i="Output length must be a multiple of 8";if(r.outputUpper=n.outputUpper||!1,n.b64Pad&&(r.b64Pad=n.b64Pad),n.outputLen){if(n.outputLen%8!=0)throw new Error(i);r.outputLen=n.outputLen;}else if(n.shakeLen){if(n.shakeLen%8!=0)throw new Error(i);r.outputLen=n.shakeLen;}if("boolean"!=typeof r.outputUpper)throw new Error("Invalid outputUpper formatting option");if("string"!=typeof r.b64Pad)throw new Error("Invalid b64Pad formatting option");return r}function u(t,r){return t>>>r|t<<32-r}function f(t,r){return t>>>r}function c(t,r,n){return t&r^~t&n}function a(t,r,n){return t&r^t&n^r&n}function w(t){return u(t,2)^u(t,13)^u(t,22)}function A(t,r){const n=(65535&t)+(65535&r);return (65535&(t>>>16)+(r>>>16)+(n>>>16))<<16|65535&n}function E(t,r,n,i){const e=(65535&t)+(65535&r)+(65535&n)+(65535&i);return (65535&(t>>>16)+(r>>>16)+(n>>>16)+(i>>>16)+(e>>>16))<<16|65535&e}function l(t,r,n,i,e){const s=(65535&t)+(65535&r)+(65535&n)+(65535&i)+(65535&e);return (65535&(t>>>16)+(r>>>16)+(n>>>16)+(i>>>16)+(e>>>16)+(s>>>16))<<16|65535&s}function p(t){return u(t,7)^u(t,18)^f(t,3)}function R(t){return u(t,6)^u(t,11)^u(t,25)}function d(t){let r;return r="SHA-224"==t?s.slice():o.slice(),r}function U(t,r){let n,i,s,o,h,d,U,y,T,b,F;const m=[];for(n=r[0],i=r[1],s=r[2],o=r[3],h=r[4],d=r[5],U=r[6],y=r[7],F=0;F<64;F+=1)m[F]=F<16?t[F]:E(u(g=m[F-2],17)^u(g,19)^f(g,10),m[F-7],p(m[F-15]),m[F-16]),T=l(y,R(h),c(h,d,U),e[F],m[F]),b=A(w(n),a(n,i,s)),y=U,U=d,d=h,h=A(o,T),o=s,s=i,i=n,n=A(T,b);var g;return r[0]=A(n,r[0]),r[1]=A(i,r[1]),r[2]=A(s,r[2]),r[3]=A(o,r[3]),r[4]=A(h,r[4]),r[5]=A(d,r[5]),r[6]=A(U,r[6]),r[7]=A(y,r[7]),r}class JsSHA extends class{constructor(t,r,n){const i=n||{};if(this.t=r,this.i=i.encoding||"UTF8",this.numRounds=i.numRounds||1,isNaN(this.numRounds)||this.numRounds!==parseInt(this.numRounds,10)||1>this.numRounds)throw new Error("numRounds must a integer >= 1");this.s=t,this.o=[],this.h=0,this.u=!1,this.A=0,this.l=!1,this.p=[],this.R=[];}update(t){let r,n=0;const i=this.U>>>5,e=this.T(t,this.o,this.h),s=e.binLen,o=e.value,h=s>>>5;for(r=0;r<h;r+=i)n+this.U<=s&&(this.F=this.m(o.slice(r,r+i),this.F),n+=this.U);this.A+=n,this.o=o.slice(n>>>5),this.h=s%this.U,this.u=!0;}getHash(t,r){let n,e,s=this.g;const o=h(r);if(this.B){if(-1===o.outputLen)throw new Error("Output length must be specified in options");s=o.outputLen;}const u=i$1(t,s,this.H,o);if(this.l&&this.v)return u(this.v(o));for(e=this.Y(this.o.slice(),this.h,this.A,this.C(this.F),s),n=1;n<this.numRounds;n+=1)this.B&&s%32!=0&&(e[e.length-1]&=16777215>>>24-s%32),e=this.Y(e,s,0,this.S(this.s),s);return u(e)}setHMACKey(t,r,i){if(!this.I)throw new Error("Variant does not support HMAC");if(this.u)throw new Error("Cannot set MAC key after calling update");const e=n(r,(i||{}).encoding||"UTF8",this.H);this.L(e(t));}L(t){const r=this.U>>>3,n=r/4-1;let i;if(1!==this.numRounds)throw new Error("Cannot set numRounds with MAC");if(this.l)throw new Error("MAC key already set");for(r<t.binLen/8&&(t.value=this.Y(t.value,t.binLen,0,this.S(this.s),this.g));t.value.length<=n;)t.value.push(0);for(i=0;i<=n;i+=1)this.p[i]=909522486^t.value[i],this.R[i]=1549556828^t.value[i];this.F=this.m(this.p,this.F),this.A=this.U,this.l=!0;}getHMAC(t,r){const n=h(r);return i$1(t,this.g,this.H,n)(this.M())}M(){let t;if(!this.l)throw new Error("Cannot call getHMAC without first setting MAC key");const r=this.Y(this.o.slice(),this.h,this.A,this.C(this.F),this.g);return t=this.m(this.R,this.S(this.s)),t=this.Y(r,this.g,this.U,t,this.g),t}}{constructor(t,r,i){if("SHA-224"!==t&&"SHA-256"!==t)throw new Error("Chosen SHA variant is not supported");super(t,r,i);const e=i||{};this.v=this.M,this.I=!0,this.H=-1,this.T=n(this.t,this.i,this.H),this.m=U,this.C=function(t){return t.slice()},this.S=d,this.Y=function(r,n,i,e){return function(t,r,n,i,e){let s,o;const h=15+(r+65>>>9<<4),u=r+n;for(;t.length<=h;)t.push(0);for(t[r>>>5]|=128<<24-r%32,t[h]=4294967295&u,t[h-1]=u/4294967296|0,s=0;s<t.length;s+=16)i=U(t.slice(s,s+16),i);return o="SHA-224"===e?[i[0],i[1],i[2],i[3],i[4],i[5],i[6]]:i,o}(r,n,i,e,t)},this.F=d(t),this.U=512,this.g="SHA-224"===t?224:256,this.B=!1,e.hmacKey&&this.L(function(t,r,i,e){const s=t+" must include a value and format";if(!r){if(!e)throw new Error(s);return e}if(void 0===r.value||!r.format)throw new Error(s);return n(r.format,r.encoding||"UTF8",i)(r.value)}("hmacKey",e.hmacKey,this.H));}}

    let serverURL_value$7 = get_store_value(serverURL);

    /**
     * Get SHA256 of input as hex string
     * @param {string} text
     * @returns {string}
     */
    function getSHA256(text) {
        let shaObj = new JsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
        shaObj.update(text);

        return shaObj.getHash("HEX");
    }

    /**
     * Handshake with username/password to Ampache server for authentication
     * @param {string} username
     * @param {string} password
     * @returns {Promise<void>}
     */
    let handshake = async (username, password) => {
        let time = Math.floor(new Date().getTime() / 1000);
        let key = getSHA256(password);
        let passphrase = getSHA256(time + key);

        let fullURL = serverURL_value$7 + "/server/json.server.php?action=handshake&auth=" + passphrase + "&timestamp=" + time + "&version=" + get_store_value(APIVersion) + "&user=" + username;

        let result = await fetch(fullURL)
            .then(response => response.json())
            .then(data => {
                debugHelper(data, "handshake");
                serverTotals.set(data);

                if (data.auth) {
                    login(data.auth, username);
                    return 'Login successful';
                } else {
                    if (data.error) {
                        return data.error.errorMessage;
                    } else {
                        return 'Unknown login error';
                    }
                }
            })
            .catch(err => {
                console.log("Error reading data " + err);
                return err;
            });

        return result;
    };

    /**
     * Handshake with API key to Ampache server for authentication
     * @param {string} apikey
     * @returns {Promise<void>}
     */
    let handshakeAPI = async (apikey) => {
        let fullURL = serverURL_value$7 + "/server/json.server.php?action=handshake&auth=" + apikey + "&version=" + get_store_value(APIVersion);

        let result = await fetch(fullURL)
            .then(response => response.json())
            .then(data => {
                debugHelper(data, "handshakeAPI");

                serverTotals.set(data);

                if (data.auth) {
                    login(data.auth);
                    return 'Login successful';
                } else {
                    if (data.error) {
                        return data.error.errorMessage;
                    } else {
                        return 'Unknown login error';
                    }
                }
            })
            .catch(err => {
                console.log("Error reading data " + err);
                return err;
            });

        return result;
    };

    /**
     * Set all the required data after authentication
     * @param {string} token
     * @param {string} user
     */
    let login = (token, user) => {
        userToken.set(token);

        let userInfo = {
            userName: null,
            userToken: token
        };

        if (user) {
            userName.set(user);
            userInfo.userName = user;
        }

        localStorage.setItem('AmpleAuth', JSON.stringify(userInfo));
        isLoggedIn.set(true);
    };

    /**
     * Clear all login related data
     */
    let logout = () => {
        localStorage.setItem('AmpleAuth', null);
        userName.set(null);
        isLoggedIn.set(false);
    };

    /**
     * Check if our auth token is still valid
     */
    let validateAuthToken = () => {
        let cachedUserInfo = JSON.parse(localStorage.getItem('AmpleAuth'));

        if (cachedUserInfo === null) {
            logout();
            return;
        }

        let fullURL = serverURL_value$7 + "/server/json.server.php?action=ping&auth=" + cachedUserInfo.userToken;

        fetch(fullURL)
            .then(response => response.json())
            .then(data => {
                serverTotals.set(data);

                if (data.session_expire) {
                    userToken.set(cachedUserInfo.userToken);
                    userName.set(cachedUserInfo.userName);
                    isLoggedIn.set(true);
                } else {
                    logout();
                }

                APIVersion.set(data.version);
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Extend an existing session by pinging the server
     */
    let extendSession = () => {
        let fullURL = serverURL_value$7 + "/server/json.server.php?action=ping&auth=" +  get_store_value(userToken);

        fetch(fullURL)
            .then(response => response.json())
            .then(data => {
                serverTotals.set(data);

                if (data.session_expire) ; else {
                    logout();
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    let serverURL_value$6 = get_store_value(serverURL);

    /**
     * Make API request for server data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchServerData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.preference) ? data.preference : data[0];
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Get a single user preference by name
     * @returns {Promise<*>}
     */
    const getUserPreference = (name) => {
        let queryURL = serverURL_value$6 + "/server/json.server.php?action=user_preference";
        queryURL += "&filter=" + name;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getUserPreference");
        return fetchServerData(queryURL);
    };

    /**
     * Get server version
     * @returns {Promise<*>}
     */
    const getServerVersion = async () => {
        let queryURL = serverURL_value$6 + "/server/json.server.php?action=ping";

        let version = await fetch(queryURL)
            .then(response => response.json())
            .then(data => {
                if (data.version) {
                    return data.version
                } else {
                    return '';
                }
            })
            .catch(err => {
                console.log("Error reading data " + err);
                return err;
            });

        debugHelper(version, "getServerVersion");
        return version;
    };

    // external events
    const FINALIZE_EVENT_NAME = "finalize";
    const CONSIDER_EVENT_NAME = "consider";

    /**
     * @typedef {Object} Info
     * @property {string} trigger
     * @property {string} id
     * @property {string} source
     * @param {Node} el
     * @param {Array} items
     * @param {Info} info
     */
    function dispatchFinalizeEvent(el, items, info) {
        el.dispatchEvent(
            new CustomEvent(FINALIZE_EVENT_NAME, {
                detail: {items, info}
            })
        );
    }

    /**
     * Dispatches a consider event
     * @param {Node} el
     * @param {Array} items
     * @param {Info} info
     */
    function dispatchConsiderEvent(el, items, info) {
        el.dispatchEvent(
            new CustomEvent(CONSIDER_EVENT_NAME, {
                detail: {items, info}
            })
        );
    }

    // internal events
    const DRAGGED_ENTERED_EVENT_NAME = "draggedEntered";
    const DRAGGED_LEFT_EVENT_NAME = "draggedLeft";
    const DRAGGED_OVER_INDEX_EVENT_NAME = "draggedOverIndex";
    const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = "draggedLeftDocument";

    const DRAGGED_LEFT_TYPES = {
        LEFT_FOR_ANOTHER: "leftForAnother",
        OUTSIDE_OF_ANY: "outsideOfAny"
    };

    function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {
        containerEl.dispatchEvent(
            new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {
                detail: {indexObj, draggedEl}
            })
        );
    }

    /**
     * @param containerEl - the dropzone the element left
     * @param draggedEl - the dragged element
     * @param theOtherDz - the new dropzone the element entered
     */
    function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {
        containerEl.dispatchEvent(
            new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
                detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}
            })
        );
    }

    function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {
        containerEl.dispatchEvent(
            new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
                detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}
            })
        );
    }
    function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {
        containerEl.dispatchEvent(
            new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {
                detail: {indexObj, draggedEl}
            })
        );
    }
    function dispatchDraggedLeftDocument(draggedEl) {
        window.dispatchEvent(
            new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {
                detail: {draggedEl}
            })
        );
    }

    const TRIGGERS = {
        DRAG_STARTED: "dragStarted",
        DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,
        DRAGGED_ENTERED_ANOTHER: "dragEnteredAnother",
        DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,
        DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,
        DRAGGED_LEFT_ALL: "draggedLeftAll",
        DROPPED_INTO_ZONE: "droppedIntoZone",
        DROPPED_INTO_ANOTHER: "droppedIntoAnother",
        DROPPED_OUTSIDE_OF_ANY: "droppedOutsideOfAny",
        DRAG_STOPPED: "dragStopped"
    };

    const SOURCES = {
        POINTER: "pointer",
        KEYBOARD: "keyboard"
    };

    const SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
    const SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
    const SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
    const DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";

    let ITEM_ID_KEY = "id";
    let activeDndZoneCount = 0;
    function incrementActiveDropZoneCount() {
        activeDndZoneCount++;
    }
    function decrementActiveDropZoneCount() {
        if (activeDndZoneCount === 0) {
            throw new Error("Bug! trying to decrement when there are no dropzones");
        }
        activeDndZoneCount--;
    }

    /**
     * Allows using another key instead of "id" in the items data. This is global and applies to all dndzones.
     * Has to be called when there are no rendered dndzones whatsoever.
     * @param {String} newKeyName
     * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)
     */
    function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {
        if (activeDndZoneCount > 0) {
            throw new Error("can only override the id key before initialising any dndzone");
        }
        if (typeof newKeyName !== "string") {
            throw new Error("item id key has to be a string");
        }
        ITEM_ID_KEY = newKeyName;
    }

    const isOnServer = typeof window === "undefined";

    // This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601
    // It removes the transforms that are potentially applied by the flip animations
    /**
     * Gets the bounding rect but removes transforms (ex: flip animation)
     * @param {HTMLElement} el
     * @return {{top: number, left: number, bottom: number, right: number}}
     */
    function getBoundingRectNoTransforms(el) {
        let ta;
        const rect = el.getBoundingClientRect();
        const style = getComputedStyle(el);
        const tx = style.transform;

        if (tx) {
            let sx, sy, dx, dy;
            if (tx.startsWith("matrix3d(")) {
                ta = tx.slice(9, -1).split(/, /);
                sx = +ta[0];
                sy = +ta[5];
                dx = +ta[12];
                dy = +ta[13];
            } else if (tx.startsWith("matrix(")) {
                ta = tx.slice(7, -1).split(/, /);
                sx = +ta[0];
                sy = +ta[3];
                dx = +ta[4];
                dy = +ta[5];
            } else {
                return rect;
            }

            const to = style.transformOrigin;
            const x = rect.x - dx - (1 - sx) * parseFloat(to);
            const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
            const w = sx ? rect.width / sx : el.offsetWidth;
            const h = sy ? rect.height / sy : el.offsetHeight;
            return {
                x: x,
                y: y,
                width: w,
                height: h,
                top: y,
                right: x + w,
                bottom: y + h,
                left: x
            };
        } else {
            return rect;
        }
    }

    /**
     * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)
     * @param {HTMLElement} el
     * @return {{top: number, left: number, bottom: number, right: number}}
     */
    function getAbsoluteRectNoTransforms(el) {
        const rect = getBoundingRectNoTransforms(el);
        return {
            top: rect.top + window.scrollY,
            bottom: rect.bottom + window.scrollY,
            left: rect.left + window.scrollX,
            right: rect.right + window.scrollX
        };
    }

    /**
     * Gets the absolute bounding rect (accounts for the window's scroll position)
     * @param {HTMLElement} el
     * @return {{top: number, left: number, bottom: number, right: number}}
     */
    function getAbsoluteRect(el) {
        const rect = el.getBoundingClientRect();
        return {
            top: rect.top + window.scrollY,
            bottom: rect.bottom + window.scrollY,
            left: rect.left + window.scrollX,
            right: rect.right + window.scrollX
        };
    }

    /**
     * finds the center :)
     * @typedef {Object} Rect
     * @property {number} top
     * @property {number} bottom
     * @property {number} left
     * @property {number} right
     * @param {Rect} rect
     * @return {{x: number, y: number}}
     */
    function findCenter(rect) {
        return {
            x: (rect.left + rect.right) / 2,
            y: (rect.top + rect.bottom) / 2
        };
    }

    /**
     * @typedef {Object} Point
     * @property {number} x
     * @property {number} y
     * @param {Point} pointA
     * @param {Point} pointB
     * @return {number}
     */
    function calcDistance(pointA, pointB) {
        return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
    }

    /**
     * @param {Point} point
     * @param {Rect} rect
     * @return {boolean|boolean}
     */
    function isPointInsideRect(point, rect) {
        return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;
    }

    /**
     * find the absolute coordinates of the center of a dom element
     * @param el {HTMLElement}
     * @returns {{x: number, y: number}}
     */
    function findCenterOfElement(el) {
        return findCenter(getAbsoluteRect(el));
    }

    /**
     * @param {HTMLElement} elA
     * @param {HTMLElement} elB
     * @return {boolean}
     */
    function isCenterOfAInsideB(elA, elB) {
        const centerOfA = findCenterOfElement(elA);
        const rectOfB = getAbsoluteRectNoTransforms(elB);
        return isPointInsideRect(centerOfA, rectOfB);
    }

    /**
     * @param {HTMLElement|ChildNode} elA
     * @param {HTMLElement|ChildNode} elB
     * @return {number}
     */
    function calcDistanceBetweenCenters(elA, elB) {
        const centerOfA = findCenterOfElement(elA);
        const centerOfB = findCenterOfElement(elB);
        return calcDistance(centerOfA, centerOfB);
    }

    /**
     * @param {HTMLElement} el - the element to check
     * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)
     */
    function isElementOffDocument(el) {
        const rect = getAbsoluteRect(el);
        return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
    }

    /**
     * If the point is inside the element returns its distances from the sides, otherwise returns null
     * @param {Point} point
     * @param {HTMLElement} el
     * @return {null|{top: number, left: number, bottom: number, right: number}}
     */
    function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
        const rect = getAbsoluteRect(el);
        if (!isPointInsideRect(point, rect)) {
            return null;
        }
        return {
            top: point.y - rect.top,
            bottom: rect.bottom - point.y,
            left: point.x - rect.left,
            // TODO - figure out what is so special about right (why the rect is too big)
            right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
        };
    }

    let dzToShadowIndexToRect;

    /**
     * Resets the cache that allows for smarter "would be index" resolution. Should be called after every drag operation
     */
    function resetIndexesCache() {
        dzToShadowIndexToRect = new Map();
    }
    resetIndexesCache();

    /**
     * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.
     * Helpful in order to determine "would be index" more effectively
     * @param {HTMLElement} dz
     * @return {number} - the shadow element index
     */
    function cacheShadowRect(dz) {
        const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));
        if (shadowElIndex >= 0) {
            if (!dzToShadowIndexToRect.has(dz)) {
                dzToShadowIndexToRect.set(dz, new Map());
            }
            dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));
            return shadowElIndex;
        }
        return undefined;
    }

    /**
     * @typedef {Object} Index
     * @property {number} index - the would be index
     * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest
     */
    /**
     * Find the index for the dragged element in the list it is dragged over
     * @param {HTMLElement} floatingAboveEl
     * @param {HTMLElement} collectionBelowEl
     * @returns {Index|null} -  if the element is over the container the Index object otherwise null
     */
    function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
        if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {
            return null;
        }
        const children = collectionBelowEl.children;
        // the container is empty, floating element should be the first
        if (children.length === 0) {
            return {index: 0, isProximityBased: true};
        }
        const shadowElIndex = cacheShadowRect(collectionBelowEl);

        // the search could be more efficient but keeping it simple for now
        // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there
        for (let i = 0; i < children.length; i++) {
            if (isCenterOfAInsideB(floatingAboveEl, children[i])) {
                const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);
                if (cachedShadowRect) {
                    if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {
                        return {index: shadowElIndex, isProximityBased: false};
                    }
                }
                return {index: i, isProximityBased: false};
            }
        }
        // this can happen if there is space around the children so the floating element has
        //entered the container but not any of the children, in this case we will find the nearest child
        let minDistanceSoFar = Number.MAX_VALUE;
        let indexOfMin = undefined;
        // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from
        for (let i = 0; i < children.length; i++) {
            const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);
            if (distance < minDistanceSoFar) {
                minDistanceSoFar = distance;
                indexOfMin = i;
            }
        }
        return {index: indexOfMin, isProximityBased: true};
    }

    const SCROLL_ZONE_PX = 25;

    function makeScroller() {
        let scrollingInfo;
        function resetScrolling() {
            scrollingInfo = {directionObj: undefined, stepPx: 0};
        }
        resetScrolling();
        // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x
        function scrollContainer(containerEl) {
            const {directionObj, stepPx} = scrollingInfo;
            if (directionObj) {
                containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
                window.requestAnimationFrame(() => scrollContainer(containerEl));
            }
        }
        function calcScrollStepPx(distancePx) {
            return SCROLL_ZONE_PX - distancePx;
        }

        /**
         * If the pointer is next to the sides of the element to scroll, will trigger scrolling
         * Can be called repeatedly with updated pointer and elementToScroll values without issues
         * @return {boolean} - true if scrolling was needed
         */
        function scrollIfNeeded(pointer, elementToScroll) {
            if (!elementToScroll) {
                return false;
            }
            const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
            if (distances === null) {
                resetScrolling();
                return false;
            }
            const isAlreadyScrolling = !!scrollingInfo.directionObj;
            let [scrollingVertically, scrollingHorizontally] = [false, false];
            // vertical
            if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
                if (distances.bottom < SCROLL_ZONE_PX) {
                    scrollingVertically = true;
                    scrollingInfo.directionObj = {x: 0, y: 1};
                    scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
                } else if (distances.top < SCROLL_ZONE_PX) {
                    scrollingVertically = true;
                    scrollingInfo.directionObj = {x: 0, y: -1};
                    scrollingInfo.stepPx = calcScrollStepPx(distances.top);
                }
                if (!isAlreadyScrolling && scrollingVertically) {
                    scrollContainer(elementToScroll);
                    return true;
                }
            }
            // horizontal
            if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
                if (distances.right < SCROLL_ZONE_PX) {
                    scrollingHorizontally = true;
                    scrollingInfo.directionObj = {x: 1, y: 0};
                    scrollingInfo.stepPx = calcScrollStepPx(distances.right);
                } else if (distances.left < SCROLL_ZONE_PX) {
                    scrollingHorizontally = true;
                    scrollingInfo.directionObj = {x: -1, y: 0};
                    scrollingInfo.stepPx = calcScrollStepPx(distances.left);
                }
                if (!isAlreadyScrolling && scrollingHorizontally) {
                    scrollContainer(elementToScroll);
                    return true;
                }
            }
            resetScrolling();
            return false;
        }

        return {
            scrollIfNeeded,
            resetScrolling
        };
    }

    /**
     * @param {Object} object
     * @return {string}
     */
    function toString(object) {
        return JSON.stringify(object, null, 2);
    }

    /**
     * Finds the depth of the given node in the DOM tree
     * @param {HTMLElement} node
     * @return {number} - the depth of the node
     */
    function getDepth(node) {
        if (!node) {
            throw new Error("cannot get depth of a falsy node");
        }
        return _getDepth(node, 0);
    }
    function _getDepth(node, countSoFar = 0) {
        if (!node.parentElement) {
            return countSoFar - 1;
        }
        return _getDepth(node.parentElement, countSoFar + 1);
    }

    /**
     * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in
     * @param {Object} objA
     * @param {Object} objB
     * @return {boolean} - true if objA and objB are shallow equal
     */
    function areObjectsShallowEqual(objA, objB) {
        if (Object.keys(objA).length !== Object.keys(objB).length) {
            return false;
        }
        for (const keyA in objA) {
            if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Shallow compares two arrays
     * @param arrA
     * @param arrB
     * @return {boolean} - whether the arrays are shallow equal
     */
    function areArraysShallowEqualSameOrder(arrA, arrB) {
        if (arrA.length !== arrB.length) {
            return false;
        }
        for (let i = 0; i < arrA.length; i++) {
            if (arrA[i] !== arrB[i]) {
                return false;
            }
        }
        return true;
    }

    const INTERVAL_MS$1 = 200;
    const TOLERANCE_PX = 10;
    const {scrollIfNeeded: scrollIfNeeded$1, resetScrolling: resetScrolling$1} = makeScroller();
    let next$1;

    /**
     * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)
     * @param {Set<HTMLElement>} dropZones
     * @param {HTMLElement} draggedEl
     * @param {number} [intervalMs = INTERVAL_MS]
     */
    function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS$1) {
        // initialization
        let lastDropZoneFound;
        let lastIndexFound;
        let lastIsDraggedInADropZone = false;
        let lastCentrePositionOfDragged;
        // We are sorting to make sure that in case of nested zones of the same type the one "on top" is considered first
        const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));

        /**
         * The main function in this module. Tracks where everything is/ should be a take the actions
         */
        function andNow() {
            const currentCenterOfDragged = findCenterOfElement(draggedEl);
            const scrolled = scrollIfNeeded$1(currentCenterOfDragged, lastDropZoneFound);
            // we only want to make a new decision after the element was moved a bit to prevent flickering
            if (
                !scrolled &&
                lastCentrePositionOfDragged &&
                Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&
                Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX
            ) {
                next$1 = window.setTimeout(andNow, intervalMs);
                return;
            }
            if (isElementOffDocument(draggedEl)) {
                dispatchDraggedLeftDocument(draggedEl);
                return;
            }

            lastCentrePositionOfDragged = currentCenterOfDragged;
            // this is a simple algorithm, potential improvement: first look at lastDropZoneFound
            let isDraggedInADropZone = false;
            for (const dz of dropZonesFromDeepToShallow) {
                const indexObj = findWouldBeIndex(draggedEl, dz);
                if (indexObj === null) {
                    // it is not inside
                    continue;
                }
                const {index} = indexObj;
                isDraggedInADropZone = true;
                // the element is over a container
                if (dz !== lastDropZoneFound) {
                    lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);
                    dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);
                    lastDropZoneFound = dz;
                } else if (index !== lastIndexFound) {
                    dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);
                    lastIndexFound = index;
                }
                // we handle looping with the 'continue' statement above
                break;
            }
            // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in
            if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {
                dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);
                lastDropZoneFound = undefined;
                lastIndexFound = undefined;
                lastIsDraggedInADropZone = false;
            } else {
                lastIsDraggedInADropZone = true;
            }
            next$1 = window.setTimeout(andNow, intervalMs);
        }
        andNow();
    }

    // assumption - we can only observe one dragged element at a time, this could be changed in the future
    function unobserve() {
        clearTimeout(next$1);
        resetScrolling$1();
        resetIndexesCache();
    }

    const INTERVAL_MS = 300;
    let mousePosition;

    /**
     * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners
     * // TODO - make private (remove export)
     * @param {{clientX: number, clientY: number}} e
     */
    function updateMousePosition(e) {
        const c = e.touches ? e.touches[0] : e;
        mousePosition = {x: c.clientX, y: c.clientY};
    }
    const {scrollIfNeeded, resetScrolling} = makeScroller();
    let next;

    function loop() {
        if (mousePosition) {
            scrollIfNeeded(mousePosition, document.documentElement);
        }
        next = window.setTimeout(loop, INTERVAL_MS);
    }

    /**
     * will start watching the mouse pointer and scroll the window if it goes next to the edges
     */
    function armWindowScroller() {
        window.addEventListener("mousemove", updateMousePosition);
        window.addEventListener("touchmove", updateMousePosition);
        loop();
    }

    /**
     * will stop watching the mouse pointer and won't scroll the window anymore
     */
    function disarmWindowScroller() {
        window.removeEventListener("mousemove", updateMousePosition);
        window.removeEventListener("touchmove", updateMousePosition);
        mousePosition = undefined;
        window.clearTimeout(next);
        resetScrolling();
    }

    const TRANSITION_DURATION_SECONDS = 0.2;

    /**
     * private helper function - creates a transition string for a property
     * @param {string} property
     * @return {string} - the transition string
     */
    function trs(property) {
        return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;
    }
    /**
     * clones the given element and applies proper styles and transitions to the dragged element
     * @param {HTMLElement} originalElement
     * @param {Point} [positionCenterOnXY]
     * @return {Node} - the cloned, styled element
     */
    function createDraggedElementFrom(originalElement, positionCenterOnXY) {
        const rect = originalElement.getBoundingClientRect();
        const draggedEl = originalElement.cloneNode(true);
        copyStylesFromTo(originalElement, draggedEl);
        draggedEl.id = DRAGGED_ELEMENT_ID;
        draggedEl.style.position = "fixed";
        let elTopPx = rect.top;
        let elLeftPx = rect.left;
        draggedEl.style.top = `${elTopPx}px`;
        draggedEl.style.left = `${elLeftPx}px`;
        if (positionCenterOnXY) {
            const center = findCenter(rect);
            elTopPx -= center.y - positionCenterOnXY.y;
            elLeftPx -= center.x - positionCenterOnXY.x;
            window.setTimeout(() => {
                draggedEl.style.top = `${elTopPx}px`;
                draggedEl.style.left = `${elLeftPx}px`;
            }, 0);
        }
        draggedEl.style.margin = "0";
        // we can't have relative or automatic height and width or it will break the illusion
        draggedEl.style.boxSizing = "border-box";
        draggedEl.style.height = `${rect.height}px`;
        draggedEl.style.width = `${rect.width}px`;
        draggedEl.style.transition = `${trs("top")}, ${trs("left")}, ${trs("background-color")}, ${trs("opacity")}, ${trs("color")} `;
        // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time
        window.setTimeout(() => (draggedEl.style.transition += `, ${trs("width")}, ${trs("height")}`), 0);
        draggedEl.style.zIndex = "9999";
        draggedEl.style.cursor = "grabbing";

        return draggedEl;
    }

    /**
     * styles the dragged element to a 'dropped' state
     * @param {HTMLElement} draggedEl
     */
    function moveDraggedElementToWasDroppedState(draggedEl) {
        draggedEl.style.cursor = "grab";
    }

    /**
     * Morphs the dragged element style, maintains the mouse pointer within the element
     * @param {HTMLElement} draggedEl
     * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element
     * @param {number} currentMouseX
     * @param {number} currentMouseY
     * @param {function} transformDraggedElement - function to transform the dragged element, does nothing by default.
     */
    function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY, transformDraggedElement) {
        const newRect = copyFromEl.getBoundingClientRect();
        const draggedElRect = draggedEl.getBoundingClientRect();
        const widthChange = newRect.width - draggedElRect.width;
        const heightChange = newRect.height - draggedElRect.height;
        if (widthChange || heightChange) {
            const relativeDistanceOfMousePointerFromDraggedSides = {
                left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
                top: (currentMouseY - draggedElRect.top) / draggedElRect.height
            };
            draggedEl.style.height = `${newRect.height}px`;
            draggedEl.style.width = `${newRect.width}px`;
            draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;
            draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;
        }

        /// other properties
        copyStylesFromTo(copyFromEl, draggedEl);
        transformDraggedElement();
    }

    /**
     * @param {HTMLElement} copyFromEl
     * @param {HTMLElement} copyToEl
     */
    function copyStylesFromTo(copyFromEl, copyToEl) {
        const computedStyle = window.getComputedStyle(copyFromEl);
        Array.from(computedStyle)
            .filter(
                s =>
                    s.startsWith("background") ||
                    s.startsWith("padding") ||
                    s.startsWith("font") ||
                    s.startsWith("text") ||
                    s.startsWith("align") ||
                    s.startsWith("justify") ||
                    s.startsWith("display") ||
                    s.startsWith("flex") ||
                    s.startsWith("border") ||
                    s === "opacity" ||
                    s === "color" ||
                    s === "list-style-type"
            )
            .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));
    }

    /**
     * makes the element compatible with being draggable
     * @param {HTMLElement} draggableEl
     * @param {boolean} dragDisabled
     */
    function styleDraggable(draggableEl, dragDisabled) {
        draggableEl.draggable = false;
        draggableEl.ondragstart = () => false;
        if (!dragDisabled) {
            draggableEl.style.userSelect = "none";
            draggableEl.style.WebkitUserSelect = "none";
            draggableEl.style.cursor = "grab";
        } else {
            draggableEl.style.userSelect = "";
            draggableEl.style.WebkitUserSelect = "";
            draggableEl.style.cursor = "";
        }
    }

    /**
     * Hides the provided element so that it can stay in the dom without interrupting
     * @param {HTMLElement} dragTarget
     */
    function hideOriginalDragTarget(dragTarget) {
        dragTarget.style.display = "none";
        dragTarget.style.position = "fixed";
        dragTarget.style.zIndex = "-5";
    }

    /**
     * styles the shadow element
     * @param {HTMLElement} shadowEl
     */
    function decorateShadowEl(shadowEl) {
        shadowEl.style.visibility = "hidden";
        shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, "true");
    }

    /**
     * undo the styles the shadow element
     * @param {HTMLElement} shadowEl
     */
    function unDecorateShadowElement(shadowEl) {
        shadowEl.style.visibility = "";
        shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
    }

    /**
     * will mark the given dropzones as visually active
     * @param {Array<HTMLElement>} dropZones
     * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)
     * @param {Function} getClasses - maps a dropzone to a classList
     */
    function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {
        dropZones.forEach(dz => {
            const styles = getStyles(dz);
            Object.keys(styles).forEach(style => {
                dz.style[style] = styles[style];
            });
            getClasses(dz).forEach(c => dz.classList.add(c));
        });
    }

    /**
     * will remove the 'active' styling from given dropzones
     * @param {Array<HTMLElement>} dropZones
     * @param {Function} getStyles - maps a dropzone to a styles object
     * @param {Function} getClasses - maps a dropzone to a classList
     */
    function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {
        dropZones.forEach(dz => {
            const styles = getStyles(dz);
            Object.keys(styles).forEach(style => {
                dz.style[style] = "";
            });
            getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));
        });
    }

    /**
     * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values
     * @param {HTMLElement} el
     * @return {function(): void} - run this function to undo the operation and restore the original values
     */
    function preventShrinking(el) {
        const originalMinHeight = el.style.minHeight;
        el.style.minHeight = window.getComputedStyle(el).getPropertyValue("height");
        const originalMinWidth = el.style.minWidth;
        el.style.minWidth = window.getComputedStyle(el).getPropertyValue("width");
        return function undo() {
            el.style.minHeight = originalMinHeight;
            el.style.minWidth = originalMinWidth;
        };
    }

    const DEFAULT_DROP_ZONE_TYPE$1 = "--any--";
    const MIN_OBSERVATION_INTERVAL_MS = 100;
    const MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
    const DEFAULT_DROP_TARGET_STYLE$1 = {
        outline: "rgba(255, 255, 102, 0.7) solid 2px"
    };

    let originalDragTarget;
    let draggedEl;
    let draggedElData;
    let draggedElType;
    let originDropZone;
    let originIndex;
    let shadowElData;
    let shadowElDropZone;
    let dragStartMousePosition;
    let currentMousePosition;
    let isWorkingOnPreviousDrag = false;
    let finalizingPreviousDrag = false;
    let unlockOriginDzMinDimensions;
    let isDraggedOutsideOfAnyDz = false;

    // a map from type to a set of drop-zones
    const typeToDropZones$1 = new Map();
    // important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners
    const dzToConfig$1 = new Map();
    // this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)
    const elToMouseDownListener = new WeakMap();

    /* drop-zones registration management */
    function registerDropZone$1(dropZoneEl, type) {
        if (!typeToDropZones$1.has(type)) {
            typeToDropZones$1.set(type, new Set());
        }
        if (!typeToDropZones$1.get(type).has(dropZoneEl)) {
            typeToDropZones$1.get(type).add(dropZoneEl);
            incrementActiveDropZoneCount();
        }
    }
    function unregisterDropZone$1(dropZoneEl, type) {
        typeToDropZones$1.get(type).delete(dropZoneEl);
        decrementActiveDropZoneCount();
        if (typeToDropZones$1.get(type).size === 0) {
            typeToDropZones$1.delete(type);
        }
    }

    /* functions to manage observing the dragged element and trigger custom drag-events */
    function watchDraggedElement() {
        armWindowScroller();
        const dropZones = typeToDropZones$1.get(draggedElType);
        for (const dz of dropZones) {
            dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
            dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
            dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
        }
        window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
        // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth
        const observationIntervalMs = Math.max(
            MIN_OBSERVATION_INTERVAL_MS,
            ...Array.from(dropZones.keys()).map(dz => dzToConfig$1.get(dz).dropAnimationDurationMs)
        );
        observe(draggedEl, dropZones, observationIntervalMs * 1.07);
    }
    function unWatchDraggedElement() {
        disarmWindowScroller();
        const dropZones = typeToDropZones$1.get(draggedElType);
        for (const dz of dropZones) {
            dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
            dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
            dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
        }
        window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
        unobserve();
    }

    // finds the initial placeholder that is placed there on drag start
    function findShadowPlaceHolderIdx(items) {
        return items.findIndex(item => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);
    }
    function findShadowElementIdx(items) {
        // checking that the id is not the placeholder's for Dragula like usecases
        return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);
    }

    /* custom drag-events handlers */
    function handleDraggedEntered(e) {
        let {items, dropFromOthersDisabled} = dzToConfig$1.get(e.currentTarget);
        if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
            return;
        }
        isDraggedOutsideOfAnyDz = false;
        // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet
        items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);

        if (originDropZone !== e.currentTarget) {
            const originZoneItems = dzToConfig$1.get(originDropZone).items;
            const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);
            dispatchConsiderEvent(originDropZone, newOriginZoneItems, {
                trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,
                id: draggedElData[ITEM_ID_KEY],
                source: SOURCES.POINTER
            });
        } else {
            const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
            if (shadowPlaceHolderIdx !== -1) {
                items.splice(shadowPlaceHolderIdx, 1);
            }
        }

        const {index, isProximityBased} = e.detail.indexObj;
        const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
        shadowElDropZone = e.currentTarget;
        items.splice(shadowElIdx, 0, shadowElData);
        dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});
    }

    function handleDraggedLeft(e) {
        // dealing with a rare race condition on extremely rapid clicking and dropping
        if (!isWorkingOnPreviousDrag) return;
        const {items, dropFromOthersDisabled} = dzToConfig$1.get(e.currentTarget);
        if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
            return;
        }
        const shadowElIdx = findShadowElementIdx(items);
        const shadowItem = items.splice(shadowElIdx, 1)[0];
        shadowElDropZone = undefined;
        const {type, theOtherDz} = e.detail;
        if (
            type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||
            (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig$1.get(theOtherDz).dropFromOthersDisabled)
        ) {
            isDraggedOutsideOfAnyDz = true;
            shadowElDropZone = originDropZone;
            const originZoneItems = dzToConfig$1.get(originDropZone).items;
            originZoneItems.splice(originIndex, 0, shadowItem);
            dispatchConsiderEvent(originDropZone, originZoneItems, {
                trigger: TRIGGERS.DRAGGED_LEFT_ALL,
                id: draggedElData[ITEM_ID_KEY],
                source: SOURCES.POINTER
            });
        }
        // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity
        dispatchConsiderEvent(e.currentTarget, items, {
            trigger: TRIGGERS.DRAGGED_LEFT,
            id: draggedElData[ITEM_ID_KEY],
            source: SOURCES.POINTER
        });
    }
    function handleDraggedIsOverIndex(e) {
        const {items, dropFromOthersDisabled} = dzToConfig$1.get(e.currentTarget);
        if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
            return;
        }
        isDraggedOutsideOfAnyDz = false;
        const {index} = e.detail.indexObj;
        const shadowElIdx = findShadowElementIdx(items);
        items.splice(shadowElIdx, 1);
        items.splice(index, 0, shadowElData);
        dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});
    }

    // Global mouse/touch-events handlers
    function handleMouseMove(e) {
        e.preventDefault();
        const c = e.touches ? e.touches[0] : e;
        currentMousePosition = {x: c.clientX, y: c.clientY};
        draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${
        currentMousePosition.y - dragStartMousePosition.y
    }px, 0)`;
    }

    function handleDrop$1() {
        finalizingPreviousDrag = true;
        // cleanup
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("touchmove", handleMouseMove);
        window.removeEventListener("mouseup", handleDrop$1);
        window.removeEventListener("touchend", handleDrop$1);
        unWatchDraggedElement();
        moveDraggedElementToWasDroppedState(draggedEl);

        if (!shadowElDropZone) {
            shadowElDropZone = originDropZone;
        }
        let {items, type} = dzToConfig$1.get(shadowElDropZone);
        styleInactiveDropZones(
            typeToDropZones$1.get(type),
            dz => dzToConfig$1.get(dz).dropTargetStyle,
            dz => dzToConfig$1.get(dz).dropTargetClasses
        );
        let shadowElIdx = findShadowElementIdx(items);
        // the handler might remove the shadow element, ex: dragula like copy on drag
        if (shadowElIdx === -1) shadowElIdx = originIndex;
        items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));
        function finalizeWithinZone() {
            unlockOriginDzMinDimensions();
            dispatchFinalizeEvent(shadowElDropZone, items, {
                trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,
                id: draggedElData[ITEM_ID_KEY],
                source: SOURCES.POINTER
            });
            if (shadowElDropZone !== originDropZone) {
                // letting the origin drop zone know the element was permanently taken away
                dispatchFinalizeEvent(originDropZone, dzToConfig$1.get(originDropZone).items, {
                    trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
                    id: draggedElData[ITEM_ID_KEY],
                    source: SOURCES.POINTER
                });
            }
            unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
            cleanupPostDrop();
        }
        animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
    }

    // helper function for handleDrop
    function animateDraggedToFinalPosition(shadowElIdx, callback) {
        const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
        const newTransform = {
            x: shadowElRect.left - parseFloat(draggedEl.style.left),
            y: shadowElRect.top - parseFloat(draggedEl.style.top)
        };
        const {dropAnimationDurationMs} = dzToConfig$1.get(shadowElDropZone);
        const transition = `transform ${dropAnimationDurationMs}ms ease`;
        draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
        draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;
        window.setTimeout(callback, dropAnimationDurationMs);
    }

    /* cleanup */
    function cleanupPostDrop() {
        draggedEl.remove();
        originalDragTarget.remove();
        draggedEl = undefined;
        originalDragTarget = undefined;
        draggedElData = undefined;
        draggedElType = undefined;
        originDropZone = undefined;
        originIndex = undefined;
        shadowElData = undefined;
        shadowElDropZone = undefined;
        dragStartMousePosition = undefined;
        currentMousePosition = undefined;
        isWorkingOnPreviousDrag = false;
        finalizingPreviousDrag = false;
        unlockOriginDzMinDimensions = undefined;
        isDraggedOutsideOfAnyDz = false;
    }

    function dndzone$2(node, options) {
        const config = {
            items: undefined,
            type: undefined,
            flipDurationMs: 0,
            dragDisabled: false,
            morphDisabled: false,
            dropFromOthersDisabled: false,
            dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,
            dropTargetClasses: [],
            transformDraggedElement: () => {},
            centreDraggedOnCursor: false
        };
        let elToIdx = new Map();

        function addMaybeListeners() {
            window.addEventListener("mousemove", handleMouseMoveMaybeDragStart, {passive: false});
            window.addEventListener("touchmove", handleMouseMoveMaybeDragStart, {passive: false, capture: false});
            window.addEventListener("mouseup", handleFalseAlarm, {passive: false});
            window.addEventListener("touchend", handleFalseAlarm, {passive: false});
        }
        function removeMaybeListeners() {
            window.removeEventListener("mousemove", handleMouseMoveMaybeDragStart);
            window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
            window.removeEventListener("mouseup", handleFalseAlarm);
            window.removeEventListener("touchend", handleFalseAlarm);
        }
        function handleFalseAlarm() {
            removeMaybeListeners();
            originalDragTarget = undefined;
            dragStartMousePosition = undefined;
            currentMousePosition = undefined;
        }

        function handleMouseMoveMaybeDragStart(e) {
            e.preventDefault();
            const c = e.touches ? e.touches[0] : e;
            currentMousePosition = {x: c.clientX, y: c.clientY};
            if (
                Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||
                Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX
            ) {
                removeMaybeListeners();
                handleDragStart();
            }
        }
        function handleMouseDown(e) {
            // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense
            if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {
                return;
            }
            // prevents responding to any button but left click which equals 0 (which is falsy)
            if (e.button) {
                return;
            }
            if (isWorkingOnPreviousDrag) {
                return;
            }
            e.stopPropagation();
            const c = e.touches ? e.touches[0] : e;
            dragStartMousePosition = {x: c.clientX, y: c.clientY};
            currentMousePosition = {...dragStartMousePosition};
            originalDragTarget = e.currentTarget;
            addMaybeListeners();
        }

        function handleDragStart() {
            isWorkingOnPreviousDrag = true;

            // initialising globals
            const currentIdx = elToIdx.get(originalDragTarget);
            originIndex = currentIdx;
            originDropZone = originalDragTarget.parentElement;
            const {items, type, centreDraggedOnCursor} = config;
            draggedElData = {...items[currentIdx]};
            draggedElType = type;
            shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true};
            // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues
            const placeHolderElData = {...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};

            // creating the draggable element
            draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
            // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it
            function keepOriginalElementInDom() {
                if (!draggedEl.parentElement) {
                    document.body.appendChild(draggedEl);
                    // to prevent the outline from disappearing
                    draggedEl.focus();
                    watchDraggedElement();
                    hideOriginalDragTarget(originalDragTarget);
                    document.body.appendChild(originalDragTarget);
                } else {
                    window.requestAnimationFrame(keepOriginalElementInDom);
                }
            }
            window.requestAnimationFrame(keepOriginalElementInDom);

            styleActiveDropZones(
                Array.from(typeToDropZones$1.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig$1.get(dz).dropFromOthersDisabled),
                dz => dzToConfig$1.get(dz).dropTargetStyle,
                dz => dzToConfig$1.get(dz).dropTargetClasses
            );

            // removing the original element by removing its data entry
            items.splice(currentIdx, 1, placeHolderElData);
            unlockOriginDzMinDimensions = preventShrinking(originDropZone);

            dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});

            // handing over to global handlers - starting to watch the element
            window.addEventListener("mousemove", handleMouseMove, {passive: false});
            window.addEventListener("touchmove", handleMouseMove, {passive: false, capture: false});
            window.addEventListener("mouseup", handleDrop$1, {passive: false});
            window.addEventListener("touchend", handleDrop$1, {passive: false});
        }

        function configure({
            items = undefined,
            flipDurationMs: dropAnimationDurationMs = 0,
            type: newType = DEFAULT_DROP_ZONE_TYPE$1,
            dragDisabled = false,
            morphDisabled = false,
            dropFromOthersDisabled = false,
            dropTargetStyle = DEFAULT_DROP_TARGET_STYLE$1,
            dropTargetClasses = [],
            transformDraggedElement = () => {},
            centreDraggedOnCursor = false
        }) {
            config.dropAnimationDurationMs = dropAnimationDurationMs;
            if (config.type && newType !== config.type) {
                unregisterDropZone$1(node, config.type);
            }
            config.type = newType;
            registerDropZone$1(node, newType);

            config.items = [...items];
            config.dragDisabled = dragDisabled;
            config.morphDisabled = morphDisabled;
            config.transformDraggedElement = transformDraggedElement;
            config.centreDraggedOnCursor = centreDraggedOnCursor;

            // realtime update for dropTargetStyle
            if (
                isWorkingOnPreviousDrag &&
                !finalizingPreviousDrag &&
                (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||
                    !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))
            ) {
                styleInactiveDropZones(
                    [node],
                    () => config.dropTargetStyle,
                    () => dropTargetClasses
                );
                styleActiveDropZones(
                    [node],
                    () => dropTargetStyle,
                    () => dropTargetClasses
                );
            }
            config.dropTargetStyle = dropTargetStyle;
            config.dropTargetClasses = [...dropTargetClasses];

            // realtime update for dropFromOthersDisabled
            function getConfigProp(dz, propName) {
                return dzToConfig$1.get(dz) ? dzToConfig$1.get(dz)[propName] : config[propName];
            }
            if (isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {
                if (dropFromOthersDisabled) {
                    styleInactiveDropZones(
                        [node],
                        dz => getConfigProp(dz, "dropTargetStyle"),
                        dz => getConfigProp(dz, "dropTargetClasses")
                    );
                } else {
                    styleActiveDropZones(
                        [node],
                        dz => getConfigProp(dz, "dropTargetStyle"),
                        dz => getConfigProp(dz, "dropTargetClasses")
                    );
                }
            }
            config.dropFromOthersDisabled = dropFromOthersDisabled;

            dzToConfig$1.set(node, config);
            const shadowElIdx = findShadowElementIdx(config.items);
            for (let idx = 0; idx < node.children.length; idx++) {
                const draggableEl = node.children[idx];
                styleDraggable(draggableEl, dragDisabled);
                if (idx === shadowElIdx) {
                    if (!morphDisabled) {
                        morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y, () =>
                            config.transformDraggedElement(draggedEl, draggedElData, idx)
                        );
                    }
                    decorateShadowEl(draggableEl);
                    continue;
                }
                draggableEl.removeEventListener("mousedown", elToMouseDownListener.get(draggableEl));
                draggableEl.removeEventListener("touchstart", elToMouseDownListener.get(draggableEl));
                if (!dragDisabled) {
                    draggableEl.addEventListener("mousedown", handleMouseDown);
                    draggableEl.addEventListener("touchstart", handleMouseDown);
                    elToMouseDownListener.set(draggableEl, handleMouseDown);
                }
                // updating the idx
                elToIdx.set(draggableEl, idx);
            }
        }
        configure(options);

        return {
            update: newOptions => {
                configure(newOptions);
            },
            destroy: () => {
                unregisterDropZone$1(node, config.type);
                dzToConfig$1.delete(node);
            }
        };
    }

    const INSTRUCTION_IDs$1 = {
        DND_ZONE_ACTIVE: "dnd-zone-active",
        DND_ZONE_DRAG_DISABLED: "dnd-zone-drag-disabled"
    };
    const ID_TO_INSTRUCTION = {
        [INSTRUCTION_IDs$1.DND_ZONE_ACTIVE]: "Tab to one the items and press space-bar or enter to start dragging it",
        [INSTRUCTION_IDs$1.DND_ZONE_DRAG_DISABLED]: "This is a disabled drag and drop list"
    };

    const ALERT_DIV_ID = "dnd-action-aria-alert";
    let alertsDiv;

    function initAriaOnBrowser() {
        // setting the dynamic alerts
        alertsDiv = document.createElement("div");
        (function initAlertsDiv() {
            alertsDiv.id = ALERT_DIV_ID;
            // tab index -1 makes the alert be read twice on chrome for some reason
            //alertsDiv.tabIndex = -1;
            alertsDiv.style.position = "fixed";
            alertsDiv.style.bottom = "0";
            alertsDiv.style.left = "0";
            alertsDiv.style.zIndex = "-5";
            alertsDiv.style.opacity = "0";
            alertsDiv.style.height = "0";
            alertsDiv.style.width = "0";
            alertsDiv.setAttribute("role", "alert");
        })();
        document.body.prepend(alertsDiv);

        // setting the instructions
        Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));
    }

    /**
     * Initializes the static aria instructions so they can be attached to zones
     * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server
     */
    function initAria() {
        if (isOnServer) return null;
        if (document.readyState === "complete") {
            initAriaOnBrowser();
        } else {
            window.addEventListener("DOMContentLoaded", initAriaOnBrowser);
        }
        return {...INSTRUCTION_IDs$1};
    }
    function instructionToHiddenDiv(id, txt) {
        const div = document.createElement("div");
        div.id = id;
        div.innerHTML = `<p>${txt}</p>`;
        div.style.display = "none";
        div.style.position = "fixed";
        div.style.zIndex = "-5";
        return div;
    }

    /**
     * Will make the screen reader alert the provided text to the user
     * @param {string} txt
     */
    function alertToScreenReader(txt) {
        alertsDiv.innerHTML = "";
        const alertText = document.createTextNode(txt);
        alertsDiv.appendChild(alertText);
        // this is needed for Safari
        alertsDiv.style.display = "none";
        alertsDiv.style.display = "inline";
    }

    const DEFAULT_DROP_ZONE_TYPE = "--any--";
    const DEFAULT_DROP_TARGET_STYLE = {
        outline: "rgba(255, 255, 102, 0.7) solid 2px"
    };

    let isDragging = false;
    let draggedItemType;
    let focusedDz;
    let focusedDzLabel = "";
    let focusedItem;
    let focusedItemId;
    let focusedItemLabel = "";
    const allDragTargets = new WeakSet();
    const elToKeyDownListeners = new WeakMap();
    const elToFocusListeners = new WeakMap();
    const dzToHandles = new Map();
    const dzToConfig = new Map();
    const typeToDropZones = new Map();

    /* TODO (potentially)
     * what's the deal with the black border of voice-reader not following focus?
     * maybe keep focus on the last dragged item upon drop?
     */

    const INSTRUCTION_IDs = initAria();

    /* drop-zones registration management */
    function registerDropZone(dropZoneEl, type) {
        if (typeToDropZones.size === 0) {
            window.addEventListener("keydown", globalKeyDownHandler);
            window.addEventListener("click", globalClickHandler);
        }
        if (!typeToDropZones.has(type)) {
            typeToDropZones.set(type, new Set());
        }
        if (!typeToDropZones.get(type).has(dropZoneEl)) {
            typeToDropZones.get(type).add(dropZoneEl);
            incrementActiveDropZoneCount();
        }
    }
    function unregisterDropZone(dropZoneEl, type) {
        if (focusedDz === dropZoneEl) {
            handleDrop();
        }
        typeToDropZones.get(type).delete(dropZoneEl);
        decrementActiveDropZoneCount();
        if (typeToDropZones.get(type).size === 0) {
            typeToDropZones.delete(type);
        }
        if (typeToDropZones.size === 0) {
            window.removeEventListener("keydown", globalKeyDownHandler);
            window.removeEventListener("click", globalClickHandler);
        }
    }

    function globalKeyDownHandler(e) {
        if (!isDragging) return;
        switch (e.key) {
            case "Escape": {
                handleDrop();
                break;
            }
        }
    }

    function globalClickHandler() {
        if (!isDragging) return;
        if (!allDragTargets.has(document.activeElement)) {
            handleDrop();
        }
    }

    function handleZoneFocus(e) {
        if (!isDragging) return;
        const newlyFocusedDz = e.currentTarget;
        if (newlyFocusedDz === focusedDz) return;

        focusedDzLabel = newlyFocusedDz.getAttribute("aria-label") || "";
        const {items: originItems} = dzToConfig.get(focusedDz);
        const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);
        const originIdx = originItems.indexOf(originItem);
        const itemToMove = originItems.splice(originIdx, 1)[0];
        const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);
        if (
            newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||
            newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left
        ) {
            targetItems.push(itemToMove);
            if (!autoAriaDisabled) {
                alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);
            }
        } else {
            targetItems.unshift(itemToMove);
            if (!autoAriaDisabled) {
                alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);
            }
        }
        const dzFrom = focusedDz;
        dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});
        dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});
        focusedDz = newlyFocusedDz;
    }

    function triggerAllDzsUpdate() {
        dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));
    }

    function handleDrop(dispatchConsider = true) {
        if (!dzToConfig.get(focusedDz).autoAriaDisabled) {
            alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);
        }
        if (allDragTargets.has(document.activeElement)) {
            document.activeElement.blur();
        }
        if (dispatchConsider) {
            dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {
                trigger: TRIGGERS.DRAG_STOPPED,
                id: focusedItemId,
                source: SOURCES.KEYBOARD
            });
        }
        styleInactiveDropZones(
            typeToDropZones.get(draggedItemType),
            dz => dzToConfig.get(dz).dropTargetStyle,
            dz => dzToConfig.get(dz).dropTargetClasses
        );
        focusedItem = null;
        focusedItemId = null;
        focusedItemLabel = "";
        draggedItemType = null;
        focusedDz = null;
        focusedDzLabel = "";
        isDragging = false;
        triggerAllDzsUpdate();
    }
    //////
    function dndzone$1(node, options) {
        const config = {
            items: undefined,
            type: undefined,
            dragDisabled: false,
            dropFromOthersDisabled: false,
            dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
            dropTargetClasses: [],
            autoAriaDisabled: false
        };

        function swap(arr, i, j) {
            if (arr.length <= 1) return;
            arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);
        }

        function handleKeyDown(e) {
            switch (e.key) {
                case "Enter":
                case " ": {
                    // we don't want to affect nested input elements or clickable elements
                    if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {
                        return;
                    }
                    e.preventDefault(); // preventing scrolling on spacebar
                    e.stopPropagation();
                    if (isDragging) {
                        // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?
                        handleDrop();
                    } else {
                        // drag start
                        handleDragStart(e);
                    }
                    break;
                }
                case "ArrowDown":
                case "ArrowRight": {
                    if (!isDragging) return;
                    e.preventDefault(); // prevent scrolling
                    e.stopPropagation();
                    const {items} = dzToConfig.get(node);
                    const children = Array.from(node.children);
                    const idx = children.indexOf(e.currentTarget);
                    if (idx < children.length - 1) {
                        if (!config.autoAriaDisabled) {
                            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);
                        }
                        swap(items, idx, idx + 1);
                        dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});
                    }
                    break;
                }
                case "ArrowUp":
                case "ArrowLeft": {
                    if (!isDragging) return;
                    e.preventDefault(); // prevent scrolling
                    e.stopPropagation();
                    const {items} = dzToConfig.get(node);
                    const children = Array.from(node.children);
                    const idx = children.indexOf(e.currentTarget);
                    if (idx > 0) {
                        if (!config.autoAriaDisabled) {
                            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);
                        }
                        swap(items, idx, idx - 1);
                        dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});
                    }
                    break;
                }
            }
        }
        function handleDragStart(e) {
            setCurrentFocusedItem(e.currentTarget);
            focusedDz = node;
            draggedItemType = config.type;
            isDragging = true;
            const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);
            styleActiveDropZones(
                dropTargets,
                dz => dzToConfig.get(dz).dropTargetStyle,
                dz => dzToConfig.get(dz).dropTargetClasses
            );
            if (!config.autoAriaDisabled) {
                let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;
                if (dropTargets.length > 1) {
                    msg += `, or tab to another list in order to move the item into it`;
                }
                alertToScreenReader(msg);
            }
            dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});
            triggerAllDzsUpdate();
        }

        function handleClick(e) {
            if (!isDragging) return;
            if (e.currentTarget === focusedItem) return;
            e.stopPropagation();
            handleDrop(false);
            handleDragStart(e);
        }
        function setCurrentFocusedItem(draggableEl) {
            const {items} = dzToConfig.get(node);
            const children = Array.from(node.children);
            const focusedItemIdx = children.indexOf(draggableEl);
            focusedItem = draggableEl;
            focusedItem.tabIndex = 0;
            focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
            focusedItemLabel = children[focusedItemIdx].getAttribute("aria-label") || "";
        }

        function configure({
            items = [],
            type: newType = DEFAULT_DROP_ZONE_TYPE,
            dragDisabled = false,
            dropFromOthersDisabled = false,
            dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,
            dropTargetClasses = [],
            autoAriaDisabled = false
        }) {
            config.items = [...items];
            config.dragDisabled = dragDisabled;
            config.dropFromOthersDisabled = dropFromOthersDisabled;
            config.dropTargetStyle = dropTargetStyle;
            config.dropTargetClasses = dropTargetClasses;
            config.autoAriaDisabled = autoAriaDisabled;
            if (!autoAriaDisabled) {
                node.setAttribute("aria-disabled", dragDisabled);
                node.setAttribute("role", "list");
                node.setAttribute("aria-describedby", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);
            }
            if (config.type && newType !== config.type) {
                unregisterDropZone(node, config.type);
            }
            config.type = newType;
            registerDropZone(node, newType);
            dzToConfig.set(node, config);

            node.tabIndex =
                isDragging &&
                (node === focusedDz ||
                    focusedItem.contains(node) ||
                    config.dropFromOthersDisabled ||
                    (focusedDz && config.type !== dzToConfig.get(focusedDz).type))
                    ? -1
                    : 0;
            node.addEventListener("focus", handleZoneFocus);

            for (let i = 0; i < node.children.length; i++) {
                const draggableEl = node.children[i];
                allDragTargets.add(draggableEl);
                draggableEl.tabIndex = isDragging ? -1 : 0;
                if (!autoAriaDisabled) {
                    draggableEl.setAttribute("role", "listitem");
                }
                draggableEl.removeEventListener("keydown", elToKeyDownListeners.get(draggableEl));
                draggableEl.removeEventListener("click", elToFocusListeners.get(draggableEl));
                if (!dragDisabled) {
                    draggableEl.addEventListener("keydown", handleKeyDown);
                    elToKeyDownListeners.set(draggableEl, handleKeyDown);
                    draggableEl.addEventListener("click", handleClick);
                    elToFocusListeners.set(draggableEl, handleClick);
                }
                if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {
                    // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer
                    focusedItem = draggableEl;
                    focusedItem.tabIndex = 0;
                    // without this the element loses focus if it moves backwards in the list
                    draggableEl.focus();
                }
            }
        }
        configure(options);

        const handles = {
            update: newOptions => {
                configure(newOptions);
            },
            destroy: () => {
                unregisterDropZone(node, config.type);
                dzToConfig.delete(node);
                dzToHandles.delete(node);
            }
        };
        dzToHandles.set(node, handles);
        return handles;
    }

    /**
     * A custom action to turn any container to a dnd zone and all of its direct children to draggables
     * Supports mouse, touch and keyboard interactions.
     * Dispatches two events that the container is expected to react to by modifying its list of items,
     * which will then feed back in to this action via the update function
     *
     * @typedef {object} Options
     * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block
     * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type
     * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero
     * @property {boolean} [dragDisabled]
     * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions
     * @property {boolean} [dropFromOthersDisabled]
     * @property {object} [dropTargetStyle]
     * @property {string[]} [dropTargetClasses]
     * @property {function} [transformDraggedElement]
     * @param {HTMLElement} node - the element to enhance
     * @param {Options} options
     * @return {{update: function, destroy: function}}
     */
    function dndzone(node, options) {
        validateOptions(options);
        const pointerZone = dndzone$2(node, options);
        const keyboardZone = dndzone$1(node, options);
        return {
            update: newOptions => {
                validateOptions(newOptions);
                pointerZone.update(newOptions);
                keyboardZone.update(newOptions);
            },
            destroy: () => {
                pointerZone.destroy();
                keyboardZone.destroy();
            }
        };
    }

    function validateOptions(options) {
        /*eslint-disable*/
        const {
            items,
            flipDurationMs,
            type,
            dragDisabled,
            morphDisabled,
            dropFromOthersDisabled,
            dropTargetStyle,
            dropTargetClasses,
            transformDraggedElement,
            autoAriaDisabled,
            centreDraggedOnCursor,
            ...rest
        } = options;
        /*eslint-enable*/
        if (Object.keys(rest).length > 0) {
            console.warn(`dndzone will ignore unknown options`, rest);
        }
        if (!items) {
            throw new Error("no 'items' key provided to dndzone");
        }
        const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));
        if (itemWithMissingId) {
            throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);
        }
        if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {
            throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);
        }
    }

    /* public\images\dark_mode.svg generated by Svelte v3.38.3 */

    function create_fragment$1N(ctx) {
    	let svg;
    	let rect;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			rect = claim_element(svg_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M11.01,3.05C6.51,3.54,3,7.36,3,12c0,4.97,4.03,9,9,9c4.63,0,8.45-3.5,8.95-8c0.09-0.79-0.78-1.42-1.54-0.95 c-0.84,0.54-1.84,0.85-2.91,0.85c-2.98,0-5.4-2.42-5.4-5.4c0-1.06,0.31-2.06,0.84-2.89C12.39,3.94,11.9,2.98,11.01,3.05z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, rect);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Dark_mode extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {});
    	}
    }

    /* public\images\light_mode.svg generated by Svelte v3.38.3 */

    function create_fragment$1M(ctx) {
    	let svg;
    	let rect;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			rect = claim_element(svg_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0 c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2 c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1 C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06 c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41 l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41 c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36 c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, rect);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Light_mode extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {});
    	}
    }

    /* src\components\themeHandler.svelte generated by Svelte v3.38.3 */
    const file$Z = "src\\components\\themeHandler.svelte";

    // (37:4) {:else}
    function create_else_block_1$c(ctx) {
    	let svglightmode;
    	let current;
    	svglightmode = new Light_mode({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svglightmode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svglightmode, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svglightmode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svglightmode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svglightmode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$c.name,
    		type: "else",
    		source: "(37:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:4) {#if $ThemeIsLight}
    function create_if_block_2$s(ctx) {
    	let svgdarkmode;
    	let current;
    	svgdarkmode = new Dark_mode({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgdarkmode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgdarkmode, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgdarkmode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgdarkmode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgdarkmode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$s.name,
    		type: "if",
    		source: "(35:4) {#if $ThemeIsLight}",
    		ctx
    	});

    	return block;
    }

    // (121:0) {:else}
    function create_else_block$t(ctx) {
    	let html_tag;

    	let raw_value = `<style>
:root {
    --color-tint-900:  rgba(255, 255, 255, 0.9);
    --color-tint-800:  rgba(255, 255, 255, 0.8);
    --color-tint-700:  rgba(255, 255, 255, 0.7);
    --color-tint-600:  rgba(255, 255, 255, 0.6);
    --color-tint-500:  rgba(255, 255, 255, 0.5);
    --color-tint-400:  rgba(255, 255, 255, 0.4);
    --color-tint-300:  rgba(255, 255, 255, 0.3);
    --color-tint-200:  rgba(255, 255, 255, 0.2);
    --color-tint-100:  rgba(255, 255, 255, 0.1);
    --color-tint-50:   rgba(255, 255, 255, 0.05);

    --color-shade-900:  rgba(0, 0, 0, 0.9);
    --color-shade-800:  rgba(0, 0, 0, 0.8);
    --color-shade-700:  rgba(0, 0, 0, 0.7);
    --color-shade-600:  rgba(0, 0, 0, 0.6);
    --color-shade-500:  rgba(0, 0, 0, 0.5);
    --color-shade-400:  rgba(0, 0, 0, 0.4);
    --color-shade-300:  rgba(0, 0, 0, 0.3);
    --color-shade-200:  rgba(0, 0, 0, 0.2);
    --color-shade-100:  rgba(0, 0, 0, 0.1);
    --color-shade-50:   rgba(0, 0, 0, 0.05);

    --color-background: rgb(${K([3, 3, 243])});
    --color-interface: rgba(${K([12, 3, 243])}, 0.7);
    --color-interface-hover: rgba(${K([20, 3, 243])}, 0.7);
    --color-highlight: rgb(${K([73, 84, 68])});
    --color-highlight-rgb: ${K([73, 84, 68])};

    --color-text-body:       var(--color-tint-700);
    --color-text-heading:    var(--color-tint-900);
    --color-text-subheading: var(--color-tint-800);

    --color-link-primary:    var(--color-tint-900);
    --color-link-hover:      var(--color-tint-800);
    --color-link-active:     var(--color-tint-900);
    --color-link-secondary:  var(--color-text-body);

    --color-button-bg-primary: var(--color-tint-50);
    --color-button-text-primary: var(--color-link-secondary);
    --color-button-bg-hover:   var(--color-tint-100);
    --color-button-text-hover:   var(--color-link-hover);

    --color-card-background: var(--color-tint-50);

    --color-lines:           var(--color-tint-200);
    --color-border:          var(--color-tint-200);

    --color-waveform-progress: var(--color-text-subheading);
    --color-waveform-wave:     var(--color-lines);
}
</style>` + "";

    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$t.name,
    		type: "else",
    		source: "(121:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:0) {#if $ThemeIsLight}
    function create_if_block_1$x(ctx) {
    	let html_tag;

    	let raw_value = `<style>
:root {
    /* tints and shades inverted for light theme */
    --color-tint-900:  rgba(255, 255, 255, 0.9);
    --color-tint-800:  rgba(255, 255, 255, 0.85);
    --color-tint-700:  rgba(255, 255, 255, 0.8);
    --color-tint-600:  rgba(255, 255, 255, 0.75);
    --color-tint-500:  rgba(255, 255, 255, 0.7);
    --color-tint-400:  rgba(255, 255, 255, 0.6);
    --color-tint-300:  rgba(255, 255, 255, 0.5);
    --color-tint-200:  rgba(255, 255, 255, 0.4);
    --color-tint-100:  rgba(255, 255, 255, 0.3);
    --color-tint-50:   rgba(255, 255, 255, 0.2);

    --color-shade-900:  rgba(0, 0, 0, 0.9);
    --color-shade-800:  rgba(0, 0, 0, 0.8);
    --color-shade-700:  rgba(0, 0, 0, 0.7);
    --color-shade-600:  rgba(0, 0, 0, 0.6);
    --color-shade-500:  rgba(0, 0, 0, 0.5);
    --color-shade-400:  rgba(0, 0, 0, 0.4);
    --color-shade-300:  rgba(0, 0, 0, 0.3);
    --color-shade-200:  rgba(0, 0, 0, 0.2);
    --color-shade-100:  rgba(0, 0, 0, 0.1);
    --color-shade-50:   rgba(0, 0, 0, 0.05);

    --color-background: rgb(${K([90, 3, 243])});
    --color-interface: rgba(${K([95, 3, 243])}, 0.8);
    --color-interface-hover: rgba(${K([95, 3, 243])}, 0.8);
    --color-highlight: rgb(${K([57, 49, 257])});
    --color-highlight-rgb: ${K([57, 49, 257])};

    --color-text-body:       var(--color-shade-700);
    --color-text-heading:    var(--color-shade-800);
    --color-text-subheading: var(--color-shade-700);

    --color-link-primary:    var(--color-shade-800);
    --color-link-hover:      var(--color-shade-900);
    --color-link-active:     var(--color-shade-800);
    --color-link-secondary:  var(--color-text-body);

    --color-button-bg-primary: var(--color-tint-200);
    --color-button-text-primary: var(--color-link-secondary);
    --color-button-bg-hover:   var(--color-tint-400);
    --color-button-text-hover:   var(--color-link-hover);

    --color-card-background: var(--color-tint-500);

    --color-lines:           var(--color-shade-100);
    --color-border:          var(--color-shade-200);

    --color-waveform-progress: var(--color-text-subheading);
    --color-waveform-wave:     var(--color-border);
}
</style>` + "";

    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$x.name,
    		type: "if",
    		source: "(66:0) {#if $ThemeIsLight}",
    		ctx
    	});

    	return block;
    }

    // (177:0) {#if $customColors}
    function create_if_block$H(ctx) {
    	let html_tag;

    	let raw_value = `<style>
:root body.useCustomColors {
    background-color: rgb(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].background});
}

:root body.useCustomColors {
    --color-tint-900:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 1 : 0.9});
    --color-tint-800:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.95 : 0.8});
    --color-tint-700:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.9 : 0.7});
    --color-tint-600:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.85 : 0.6});
    --color-tint-500:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.8 : 0.5});
    --color-tint-400:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.7 : 0.4});
    --color-tint-300:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.6 : 0.3});
    --color-tint-200:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.5 : 0.2});
    --color-tint-100:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.4 : 0.1});
    --color-tint-50:   rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.3 : 0.05});

    --color-highlight: rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight}, 1);
    --color-highlight-rgb: ${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight};

    --color-text-heading:    rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight}, 1);

    --color-link-primary:    rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.8);
    --color-link-hover:      rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.9);
    --color-link-secondary:  var(--color-text-body);

    --color-button-bg-primary: var(--color-tint-50);
    --color-button-text-primary: var(--color-link-secondary);
    --color-button-bg-hover:   var(--color-tint-100);
    --color-button-text-hover:   var(--color-link-hover);

    --color-lines:           rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.2);
    --color-border:          rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.2);

    --color-waveform-progress: var(--color-text-subheading);
    --color-waveform-wave:     var(--color-lines);
}
</style>` + "";

    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$customColors, theme, $ThemeIsLight*/ 7 && raw_value !== (raw_value = `<style>
:root body.useCustomColors {
    background-color: rgb(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].background});
}

:root body.useCustomColors {
    --color-tint-900:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 1 : 0.9});
    --color-tint-800:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.95 : 0.8});
    --color-tint-700:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.9 : 0.7});
    --color-tint-600:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.85 : 0.6});
    --color-tint-500:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.8 : 0.5});
    --color-tint-400:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.7 : 0.4});
    --color-tint-300:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.6 : 0.3});
    --color-tint-200:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.5 : 0.2});
    --color-tint-100:  rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.4 : 0.1});
    --color-tint-50:   rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].nearWhite}, ${/*$ThemeIsLight*/ ctx[0] ? 0.3 : 0.05});

    --color-highlight: rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight}, 1);
    --color-highlight-rgb: ${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight};

    --color-text-heading:    rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].highlight}, 1);

    --color-link-primary:    rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.8);
    --color-link-hover:      rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.9);
    --color-link-secondary:  var(--color-text-body);

    --color-button-bg-primary: var(--color-tint-50);
    --color-button-text-primary: var(--color-link-secondary);
    --color-button-bg-hover:   var(--color-tint-100);
    --color-button-text-hover:   var(--color-link-hover);

    --color-lines:           rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.2);
    --color-border:          rgba(${/*$customColors*/ ctx[2][/*theme*/ ctx[1]].foreground}, 0.2);

    --color-waveform-progress: var(--color-text-subheading);
    --color-waveform-wave:     var(--color-lines);
}
</style>` + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(177:0) {#if $customColors}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1L(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let html_tag;

    	let raw_value = `<style>
:root {
    --color-danger-foreground:       rgb(${K([100, 40, 35])});
    --color-danger-foreground-hover: rgb(${K([100, 0, 35])});
    --color-danger-background:       rgb(${K([40, 40, 35])});
    --color-danger-background-hover: rgb(${K([45, 40, 35])});

    --color-warning-foreground:       rgb(${K([100, 40, 60])});
    --color-warning-foreground-hover: rgb(${K([100, 0, 60])});
    --color-warning-background:       rgb(${K([50, 40, 60])});
    --color-warning-background-hover: rgb(${K([55, 40, 60])});

    --color-primary-foreground:       rgb(${K([100, 40, 130])});
    --color-primary-foreground-hover: rgb(${K([100, 0, 130])});
    --color-primary-background:       rgb(${K([50, 40, 130])});
    --color-primary-background-hover: rgb(${K([55, 40, 130])});

    --color-secondary-foreground:       rgb(${K([95, 20, 240])});
    --color-secondary-foreground-hover: rgb(${K([100, 0, 240])});
    --color-secondary-background:       rgb(${K([40, 40, 240])});
    --color-secondary-background-hover: rgb(${K([45, 40, 240])});
}
</style>` + "";

    	let t1;
    	let t2;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_2$s, create_else_block_1$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$ThemeIsLight*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*$ThemeIsLight*/ ctx[0]) return create_if_block_1$x;
    		return create_else_block$t;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = /*$customColors*/ ctx[2] && create_if_block$H(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block0.c();
    			t0 = space();
    			html_tag = new HtmlTag();
    			t1 = space();
    			if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(button, "class", "icon theme-toggle svelte-c6fyot");
    			add_location(button, file$Z, 30, 0, 893);
    			html_tag.a = t1;
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			insert_dev(target, t0, anchor);
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, t1, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleTheme*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(button, null);
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(t2.parentNode, t2);
    				}
    			}

    			if (/*$customColors*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$H(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t0);
    			if (detaching) html_tag.d();
    			if (detaching) detach_dev(t1);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let $ThemeIsLight;
    	let $MediaPlayer;
    	let $customColors;
    	validate_store(ThemeIsLight, "ThemeIsLight");
    	component_subscribe($$self, ThemeIsLight, $$value => $$invalidate(0, $ThemeIsLight = $$value));
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(4, $MediaPlayer = $$value));
    	validate_store(customColors, "customColors");
    	component_subscribe($$self, customColors, $$value => $$invalidate(2, $customColors = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ThemeHandler", slots, []);
    	let theme;

    	function toggleTheme() {
    		let inverted = !$ThemeIsLight;
    		localStorage.setItem("AmpleThemeIsLight", JSON.stringify(inverted));
    		ThemeIsLight.set(inverted);

    		// update waveform colors when theme is toggled
    		$MediaPlayer.setWaveColors();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ThemeHandler> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		lchToRgb: K,
    		ThemeIsLight,
    		customColors,
    		MediaPlayer,
    		SVGDarkMode: Dark_mode,
    		SVGLightMode: Light_mode,
    		theme,
    		toggleTheme,
    		$ThemeIsLight,
    		$MediaPlayer,
    		$customColors
    	});

    	$$self.$inject_state = $$props => {
    		if ("theme" in $$props) $$invalidate(1, theme = $$props.theme);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ThemeIsLight*/ 1) {
    			{
    				if ($ThemeIsLight) {
    					document.body.classList.add("theme-is-light");
    				} else {
    					document.body.classList.remove("theme-is-light");
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$ThemeIsLight*/ 1) {
    			$$invalidate(1, theme = $ThemeIsLight ? "light" : "dark");
    		}
    	};

    	return [$ThemeIsLight, theme, $customColors, toggleTheme];
    }

    class ThemeHandler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ThemeHandler",
    			options,
    			id: create_fragment$1L.name
    		});
    	}
    }

    /* src\components\siteLoading.svelte generated by Svelte v3.38.3 */

    const file$Y = "src\\components\\siteLoading.svelte";

    function create_fragment$1K(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "Loading";
    			add_location(p, file$Y, 1, 4, 32);
    			attr_dev(div, "class", "site-loading");
    			add_location(div, file$Y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SiteLoading", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SiteLoading> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class SiteLoading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SiteLoading",
    			options,
    			id: create_fragment$1K.name
    		});
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    /* public\images\add.svg generated by Svelte v3.38.3 */

    function create_fragment$1J(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M18 13h-5v5c0 .55-.45 1-1 1s-1-.45-1-1v-5H6c-.55 0-1-.45-1-1s.45-1 1-1h5V6c0-.55.45-1 1-1s1 .45 1 1v5h5c.55 0 1 .45 1 1s-.45 1-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Add extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {});
    	}
    }

    /* public\images\refresh.svg generated by Svelte v3.38.3 */

    function create_fragment$1I(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M17.65 6.35c-1.63-1.63-3.94-2.57-6.48-2.31-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20c3.19 0 5.93-1.87 7.21-4.56.32-.67-.16-1.44-.9-1.44-.37 0-.72.2-.88.53-1.13 2.43-3.84 3.97-6.8 3.31-2.22-.49-4.01-2.3-4.48-4.52C5.31 9.44 8.26 6 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71l-.64.65z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Refresh extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, {});
    	}
    }

    /* src\components\cardList.svelte generated by Svelte v3.38.3 */
    const file$X = "src\\components\\cardList.svelte";

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (90:0) {#if heading}
    function create_if_block_4$f(ctx) {
    	let h2;
    	let t0;
    	let t1;
    	let current;
    	let if_block = /*refresh*/ ctx[1] && create_if_block_5$a(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(/*heading*/ ctx[2]);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(h2, "class", "svelte-qu087g");
    			add_location(h2, file$X, 90, 4, 3067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			append_dev(h2, t1);
    			if (if_block) if_block.m(h2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*heading*/ 4) set_data_dev(t0, /*heading*/ ctx[2]);

    			if (/*refresh*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*refresh*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(h2, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$f.name,
    		type: "if",
    		source: "(90:0) {#if heading}",
    		ctx
    	});

    	return block;
    }

    // (94:8) {#if refresh}
    function create_if_block_5$a(ctx) {
    	let button;
    	let svgrefresh;
    	let current;
    	let mounted;
    	let dispose;
    	svgrefresh = new Refresh({ $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(svgrefresh.$$.fragment);
    			attr_dev(button, "class", "with-icon refresh-button svelte-qu087g");
    			add_location(button, file$X, 94, 12, 3129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(svgrefresh, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*refreshItems*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgrefresh.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgrefresh.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(svgrefresh);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$a.name,
    		type: "if",
    		source: "(94:8) {#if refresh}",
    		ctx
    	});

    	return block;
    }

    // (125:8) {:else}
    function create_else_block$s(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*emptyMessage*/ ctx[9]);
    			add_location(p, file$X, 125, 12, 4210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*emptyMessage*/ 512) set_data_dev(t, /*emptyMessage*/ ctx[9]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$s.name,
    		type: "else",
    		source: "(125:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:8) {#if data.length > 0}
    function create_if_block_1$w(ctx) {
    	let ul;
    	let t;
    	let ul_class_value;
    	let current;
    	let each_value_1 = /*data*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = !/*refresh*/ ctx[1] && create_if_block_2$r(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(/*containerClass*/ ctx[8]) + " svelte-qu087g"));
    			add_location(ul, file$X, 110, 12, 3602);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t);
    			if (if_block) if_block.m(ul, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card, data*/ 136) {
    				each_value_1 = /*data*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!/*refresh*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*refresh*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*containerClass*/ 256 && ul_class_value !== (ul_class_value = "" + (null_to_empty(/*containerClass*/ ctx[8]) + " svelte-qu087g"))) {
    				attr_dev(ul, "class", ul_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$w.name,
    		type: "if",
    		source: "(110:8) {#if data.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (101:4) {#if loading && (loadCount < 1 || refresh)}
    function create_if_block$G(ctx) {
    	let ul;
    	let ul_class_value;
    	let current;
    	let each_value = Array(parseInt(/*limit*/ ctx[0]));
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(/*containerClass*/ ctx[8]) + " svelte-qu087g"));
    			add_location(ul, file$X, 101, 8, 3321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card, limit*/ 129) {
    				each_value = Array(parseInt(/*limit*/ ctx[0]));
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*containerClass*/ 256 && ul_class_value !== (ul_class_value = "" + (null_to_empty(/*containerClass*/ ctx[8]) + " svelte-qu087g"))) {
    				attr_dev(ul, "class", ul_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(101:4) {#if loading && (loadCount < 1 || refresh)}",
    		ctx
    	});

    	return block;
    }

    // (113:20) {#if dataSingle.name}
    function create_if_block_3$j(ctx) {
    	let li;
    	let switch_instance;
    	let current;
    	var switch_value = /*card*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: { data: /*dataSingle*/ ctx[20] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			add_location(li, file$X, 113, 24, 3744);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*data*/ 8) switch_instance_changes.data = /*dataSingle*/ ctx[20];

    			if (switch_value !== (switch_value = /*card*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, li, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$j.name,
    		type: "if",
    		source: "(113:20) {#if dataSingle.name}",
    		ctx
    	});

    	return block;
    }

    // (112:16) {#each data as dataSingle}
    function create_each_block_1$8(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*dataSingle*/ ctx[20].name && create_if_block_3$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*dataSingle*/ ctx[20].name) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(112:16) {#each data as dataSingle}",
    		ctx
    	});

    	return block;
    }

    // (119:16) {#if !refresh}
    function create_if_block_2$r(ctx) {
    	let li;
    	let button;
    	let svgadd;
    	let button_hidden_value;
    	let current;
    	let mounted;
    	let dispose;
    	svgadd = new Add({ $$inline: true });

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(svgadd.$$.fragment);
    			button.hidden = button_hidden_value = /*newBatch*/ ctx[4].length < /*limit*/ ctx[0];
    			attr_dev(button, "class", "load-more-button just-icon svelte-qu087g");
    			add_location(button, file$X, 120, 24, 3995);
    			add_location(li, file$X, 119, 20, 3965);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(svgadd, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*loadMore*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*newBatch, limit*/ 17 && button_hidden_value !== (button_hidden_value = /*newBatch*/ ctx[4].length < /*limit*/ ctx[0])) {
    				prop_dev(button, "hidden", button_hidden_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgadd.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgadd.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(svgadd);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$r.name,
    		type: "if",
    		source: "(119:16) {#if !refresh}",
    		ctx
    	});

    	return block;
    }

    // (103:12) {#each Array(parseInt(limit)) as placeholder}
    function create_each_block$h(ctx) {
    	let li;
    	let switch_instance;
    	let t;
    	let current;
    	var switch_value = /*card*/ ctx[7];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			add_location(li, file$X, 103, 16, 3427);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, li, null);
    			}

    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*card*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, li, t);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(103:12) {#each Array(parseInt(limit)) as placeholder}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1H(ctx) {
    	let t;
    	let section;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let if_block0 = /*heading*/ ctx[2] && create_if_block_4$f(ctx);
    	const if_block_creators = [create_if_block$G, create_if_block_1$w, create_else_block$s];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[6] && (/*loadCount*/ ctx[5] < 1 || /*refresh*/ ctx[1])) return 0;
    		if (/*data*/ ctx[3].length > 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			section = element("section");
    			if_block1.c();
    			add_location(section, file$X, 99, 0, 3253);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, section, anchor);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*heading*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*heading*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$f(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(section, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(section);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardList", slots, []);
    	let { type } = $$props;
    	let { dataProvider } = $$props;
    	let { refresh = false } = $$props;
    	let { limit } = $$props;
    	let { heading = null } = $$props;
    	let { containerType = "grid" } = $$props;
    	let { arg = null } = $$props;
    	let data = [];
    	let newBatch = [];
    	let loadCount = 0;
    	let loading = true;
    	let card;
    	let logic;
    	let containerClass;
    	let emptyMessage;

    	// Load initial data
    	onMount(async () => {
    		switch (type) {
    			case "artist":
    				logic = await Promise.resolve().then(function () { return artist; });
    				$$invalidate(7, card = (await Promise.resolve().then(function () { return artistCard; })).default);
    				$$invalidate(8, containerClass = containerType === "grid"
    				? "artist-grid"
    				: "artist-scroll");
    				$$invalidate(9, emptyMessage = "No artists found");
    				break;
    			case "album":
    				logic = await Promise.resolve().then(function () { return album; });
    				$$invalidate(7, card = (await Promise.resolve().then(function () { return albumCard; })).default);
    				$$invalidate(8, containerClass = containerType === "grid" ? "album-grid" : "album-scroll");
    				$$invalidate(9, emptyMessage = "No albums found");
    				break;
    			case "song":
    				logic = await Promise.resolve().then(function () { return song; });
    				$$invalidate(7, card = (await Promise.resolve().then(function () { return songCard; })).default);
    				$$invalidate(8, containerClass = containerType === "grid" ? "song-grid" : "song-scroll");
    				$$invalidate(9, emptyMessage = "No songs found");
    				break;
    			case "playlist":
    				logic = await Promise.resolve().then(function () { return playlist; });
    				$$invalidate(7, card = (await Promise.resolve().then(function () { return playlistCard; })).default);
    				$$invalidate(8, containerClass = containerType === "grid"
    				? "playlist-grid"
    				: "playlist-scroll");
    				$$invalidate(9, emptyMessage = "No playlists found");
    				break;
    			case "smartlist":
    				logic = await Promise.resolve().then(function () { return playlist; });
    				$$invalidate(7, card = (await Promise.resolve().then(function () { return smartlistCard; })).default);
    				$$invalidate(8, containerClass = containerType === "grid"
    				? "playlist-grid"
    				: "playlist-scroll");
    				$$invalidate(9, emptyMessage = "No smartlists found");
    				break;
    		}

    		await loadMore();
    	});

    	// Append extra data to existing
    	async function loadMore() {
    		$$invalidate(6, loading = true);
    		$$invalidate(4, newBatch = await logic[dataProvider]({ query: arg, limit, page: loadCount }));
    		$$invalidate(6, loading = false);
    		$$invalidate(5, loadCount++, loadCount);
    	}

    	// Replace existing data with new
    	async function refreshItems() {
    		$$invalidate(6, loading = true);
    		$$invalidate(3, data = []);
    		$$invalidate(4, newBatch = []);
    		$$invalidate(4, newBatch = await logic[dataProvider]({ query: arg, limit }));
    		$$invalidate(6, loading = false);
    	}

    	const writable_props = ["type", "dataProvider", "refresh", "limit", "heading", "containerType", "arg"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("type" in $$props) $$invalidate(12, type = $$props.type);
    		if ("dataProvider" in $$props) $$invalidate(13, dataProvider = $$props.dataProvider);
    		if ("refresh" in $$props) $$invalidate(1, refresh = $$props.refresh);
    		if ("limit" in $$props) $$invalidate(0, limit = $$props.limit);
    		if ("heading" in $$props) $$invalidate(2, heading = $$props.heading);
    		if ("containerType" in $$props) $$invalidate(14, containerType = $$props.containerType);
    		if ("arg" in $$props) $$invalidate(15, arg = $$props.arg);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		SVGAdd: Add,
    		SVGRefresh: Refresh,
    		type,
    		dataProvider,
    		refresh,
    		limit,
    		heading,
    		containerType,
    		arg,
    		data,
    		newBatch,
    		loadCount,
    		loading,
    		card,
    		logic,
    		containerClass,
    		emptyMessage,
    		loadMore,
    		refreshItems
    	});

    	$$self.$inject_state = $$props => {
    		if ("type" in $$props) $$invalidate(12, type = $$props.type);
    		if ("dataProvider" in $$props) $$invalidate(13, dataProvider = $$props.dataProvider);
    		if ("refresh" in $$props) $$invalidate(1, refresh = $$props.refresh);
    		if ("limit" in $$props) $$invalidate(0, limit = $$props.limit);
    		if ("heading" in $$props) $$invalidate(2, heading = $$props.heading);
    		if ("containerType" in $$props) $$invalidate(14, containerType = $$props.containerType);
    		if ("arg" in $$props) $$invalidate(15, arg = $$props.arg);
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("newBatch" in $$props) $$invalidate(4, newBatch = $$props.newBatch);
    		if ("loadCount" in $$props) $$invalidate(5, loadCount = $$props.loadCount);
    		if ("loading" in $$props) $$invalidate(6, loading = $$props.loading);
    		if ("card" in $$props) $$invalidate(7, card = $$props.card);
    		if ("logic" in $$props) logic = $$props.logic;
    		if ("containerClass" in $$props) $$invalidate(8, containerClass = $$props.containerClass);
    		if ("emptyMessage" in $$props) $$invalidate(9, emptyMessage = $$props.emptyMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, newBatch*/ 24) {
    			$$invalidate(3, data = [...data, ...newBatch]);
    		}

    		if ($$self.$$.dirty & /*limit*/ 1) {
    			$$invalidate(0, limit);
    		}
    	};

    	return [
    		limit,
    		refresh,
    		heading,
    		data,
    		newBatch,
    		loadCount,
    		loading,
    		card,
    		containerClass,
    		emptyMessage,
    		loadMore,
    		refreshItems,
    		type,
    		dataProvider,
    		containerType,
    		arg
    	];
    }

    class CardList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {
    			type: 12,
    			dataProvider: 13,
    			refresh: 1,
    			limit: 0,
    			heading: 2,
    			containerType: 14,
    			arg: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardList",
    			options,
    			id: create_fragment$1H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*type*/ ctx[12] === undefined && !("type" in props)) {
    			console.warn("<CardList> was created without expected prop 'type'");
    		}

    		if (/*dataProvider*/ ctx[13] === undefined && !("dataProvider" in props)) {
    			console.warn("<CardList> was created without expected prop 'dataProvider'");
    		}

    		if (/*limit*/ ctx[0] === undefined && !("limit" in props)) {
    			console.warn("<CardList> was created without expected prop 'limit'");
    		}
    	}

    	get type() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataProvider() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataProvider(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get refresh() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set refresh(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get limit() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limit(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get heading() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set heading(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerType() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerType(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get arg() {
    		throw new Error("<CardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set arg(value) {
    		throw new Error("<CardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\close.svg generated by Svelte v3.38.3 */

    function create_fragment$1G(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M18.3 5.71c-.39-.39-1.02-.39-1.41 0L12 10.59 7.11 5.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89 4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Close extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, {});
    	}
    }

    /* src\components\search.svelte generated by Svelte v3.38.3 */
    const file$W = "src\\components\\search.svelte";

    // (22:0) {#if $SearchQuery}
    function create_if_block$F(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0;
    	let b1;
    	let t1;
    	let b0;
    	let t2;
    	let button;
    	let svgclose;
    	let t3;
    	let div2;
    	let previous_key = /*$SearchQuery*/ ctx[0];
    	let div3_transition;
    	let t4;
    	let div4;
    	let div4_transition;
    	let current;
    	let mounted;
    	let dispose;
    	svgclose = new Close({ $$inline: true });
    	let key_block = create_key_block$8(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Results for ");
    			b1 = element("b");
    			t1 = text(/*$SearchQuery*/ ctx[0]);
    			b0 = element("b");
    			t2 = space();
    			button = element("button");
    			create_component(svgclose.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			key_block.c();
    			t4 = space();
    			div4 = element("div");
    			add_location(b0, file$W, 24, 66, 725);
    			add_location(b1, file$W, 24, 49, 708);
    			attr_dev(div0, "class", "header-text svelte-1pgnbzp");
    			add_location(div0, file$W, 24, 12, 671);
    			attr_dev(button, "class", "icon close svelte-1pgnbzp");
    			add_location(button, file$W, 25, 12, 748);
    			attr_dev(div1, "class", "header svelte-1pgnbzp");
    			add_location(div1, file$W, 23, 8, 637);
    			attr_dev(div2, "class", "results svelte-1pgnbzp");
    			add_location(div2, file$W, 28, 8, 847);
    			attr_dev(div3, "class", "container svelte-1pgnbzp");
    			add_location(div3, file$W, 22, 4, 538);
    			attr_dev(div4, "class", "backdrop svelte-1pgnbzp");
    			add_location(div4, file$W, 42, 4, 1624);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, b1);
    			append_dev(b1, t1);
    			append_dev(b1, b0);
    			append_dev(div1, t2);
    			append_dev(div1, button);
    			mount_component(svgclose, button, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			key_block.m(div2, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div4, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*handleClose*/ ctx[2], false, false, false),
    					listen_dev(div3, "click", /*handleClick*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*$SearchQuery*/ 1) set_data_dev(t1, /*$SearchQuery*/ ctx[0]);

    			if (dirty & /*$SearchQuery*/ 1 && safe_not_equal(previous_key, previous_key = /*$SearchQuery*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$8(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div2, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclose.$$.fragment, local);
    			transition_in(key_block);

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fly, { x: -50, duration: 300 }, true);
    				div3_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div4_transition) div4_transition = create_bidirectional_transition(div4, fade, {}, true);
    				div4_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclose.$$.fragment, local);
    			transition_out(key_block);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fly, { x: -50, duration: 300 }, false);
    			div3_transition.run(0);
    			if (!div4_transition) div4_transition = create_bidirectional_transition(div4, fade, {}, false);
    			div4_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(svgclose);
    			key_block.d(detaching);
    			if (detaching && div3_transition) div3_transition.end();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div4);
    			if (detaching && div4_transition) div4_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(22:0) {#if $SearchQuery}",
    		ctx
    	});

    	return block;
    }

    // (30:12) {#key $SearchQuery}
    function create_key_block$8(ctx) {
    	let cardlist0;
    	let t0;
    	let cardlist1;
    	let t1;
    	let cardlist2;
    	let t2;
    	let cardlist3;
    	let t3;
    	let cardlist4;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "searchArtists",
    				limit: "6",
    				arg: encodeURI(/*$SearchQuery*/ ctx[0]),
    				heading: "Artists"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "searchAlbums",
    				limit: "6",
    				arg: encodeURI(/*$SearchQuery*/ ctx[0]),
    				heading: "Albums"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "searchSongs",
    				limit: "9",
    				arg: encodeURI(/*$SearchQuery*/ ctx[0]),
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	cardlist3 = new CardList({
    			props: {
    				type: "playlist",
    				dataProvider: "searchPlaylists",
    				limit: "6",
    				arg: encodeURI(/*$SearchQuery*/ ctx[0]),
    				heading: "Playlists"
    			},
    			$$inline: true
    		});

    	cardlist4 = new CardList({
    			props: {
    				type: "smartlist",
    				dataProvider: "searchSmartlists",
    				limit: "6",
    				arg: encodeURI(/*$SearchQuery*/ ctx[0]),
    				heading: "Smartlists"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardlist0.$$.fragment);
    			t0 = space();
    			create_component(cardlist1.$$.fragment);
    			t1 = space();
    			create_component(cardlist2.$$.fragment);
    			t2 = space();
    			create_component(cardlist3.$$.fragment);
    			t3 = space();
    			create_component(cardlist4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cardlist1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cardlist3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardlist0_changes = {};
    			if (dirty & /*$SearchQuery*/ 1) cardlist0_changes.arg = encodeURI(/*$SearchQuery*/ ctx[0]);
    			cardlist0.$set(cardlist0_changes);
    			const cardlist1_changes = {};
    			if (dirty & /*$SearchQuery*/ 1) cardlist1_changes.arg = encodeURI(/*$SearchQuery*/ ctx[0]);
    			cardlist1.$set(cardlist1_changes);
    			const cardlist2_changes = {};
    			if (dirty & /*$SearchQuery*/ 1) cardlist2_changes.arg = encodeURI(/*$SearchQuery*/ ctx[0]);
    			cardlist2.$set(cardlist2_changes);
    			const cardlist3_changes = {};
    			if (dirty & /*$SearchQuery*/ 1) cardlist3_changes.arg = encodeURI(/*$SearchQuery*/ ctx[0]);
    			cardlist3.$set(cardlist3_changes);
    			const cardlist4_changes = {};
    			if (dirty & /*$SearchQuery*/ 1) cardlist4_changes.arg = encodeURI(/*$SearchQuery*/ ctx[0]);
    			cardlist4.$set(cardlist4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			transition_in(cardlist3.$$.fragment, local);
    			transition_in(cardlist4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			transition_out(cardlist3.$$.fragment, local);
    			transition_out(cardlist4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cardlist1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cardlist3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$8.name,
    		type: "key",
    		source: "(30:12) {#key $SearchQuery}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1F(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$SearchQuery*/ ctx[0] && create_if_block$F(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$SearchQuery*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$SearchQuery*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let $SearchQuery;
    	validate_store(SearchQuery, "SearchQuery");
    	component_subscribe($$self, SearchQuery, $$value => $$invalidate(0, $SearchQuery = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Search", slots, []);

    	function handleClick(event) {
    		// Close search if we are following a link
    		if (event.target.href !== undefined) {
    			ShowSearch.set(false);
    		}
    	}

    	function handleClose() {
    		ShowSearch.set(false);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		fly,
    		SearchQuery,
    		ShowSearch,
    		CardList,
    		SVGClose: Close,
    		handleClick,
    		handleClose,
    		$SearchQuery
    	});

    	return [$SearchQuery, handleClick, handleClose];
    }

    class Search$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$1F.name
    		});
    	}
    }

    let serverURL_value$5 = get_store_value(serverURL);

    /**
     * Make API request for album data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchAlbumData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.album) ? data.album : data;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Sort albums from earliest to most recent date
     * @param {array} albums
     * @returns {*}
     */
    const sortAlbumsByDate = async (albums) => {
        return albums.sort(function(obj1, obj2) { return obj1.year - obj2.year; })
    };

    /**
     * Get all albums
     * @returns {Promise<*>}
     */
    const getAlbums = async ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=albums";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get top rated albums
     * @returns {Promise<*>}
     */
    const getTopRatedAlbums = () => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=highest&limit=6";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getTopRatedAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get recently added albums
     * @returns {Promise<*>}
     */
    const getAlbumsRecentlyAdded = () => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=recent&limit=6";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbumsRecentlyAdded");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get albums starting with specified character
     * @param {string} filterChar
     * @returns {Promise<*>}
     */
    const getAlbumsStartingWith = async (filterChar) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=advanced_search&type=album";
        // ignore punctuation and leading "The "
        queryURL += "&operator=and&rule_1=title&rule_1_operator=8&rule_1_input=" + encodeURI('^(?!the\\s)[[:punct:]]*') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbumsStartingWith");

        let albums = await fetchAlbumData(queryURL);

        albums.sort(function(obj1, obj2) {
            return obj1.name.toLowerCase().replace(/([^a-z0-9\s]|the\s)/g, "").localeCompare(obj2.name.toLowerCase().replace(/([^a-z0-9\s]|the\s)/g, "")) ;
        });

        return albums;
    };

    /**
     * Test existence of artists starting with specified character
     * @param {string} filterChar
     * @returns {Promise<*>}
     */
    const testAlbumsStartingWith = (filterChar) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=advanced_search&type=album";
        queryURL += "&limit=1";
        queryURL += "&operator=and&rule_1=title&rule_1_operator=8&rule_1_input=" + encodeURI('^[[:punct:]]*') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "testAlbumsStartingWith");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get album by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getAlbum = async (id) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=album&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbum");

        let album = await fetchAlbumData(queryURL);
        album.useBackground = await placeholderArtCheck(album.art + "&thumb=10");
        album.averageColor = await getAverageColor(album.art + "&thumb=10");
        album.legibleColors = await getLegibleColors(album.averageColor.value);

        customColors.set(album.legibleColors);
        let mp = get_store_value(MediaPlayer);
        await mp.setWaveColors();

        return album;
    };

    /**
     * Get albums by artist ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getAlbumsByArtist = (id) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=artist_albums&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbumsByArtist");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get albums by year range
     * @param {number} from
     * @param {number} to
     * @returns {Promise<*>}
     */
    const getAlbumsByYear = (from, to) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=advanced_search";
        queryURL += "&type=album&operator=and";
        queryURL += "&rule_1=year&rule_1_operator=0&rule_1_input=" + from;
        queryURL += "&rule_2=year&rule_2_operator=1&rule_2_input=" + to;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbumsByYear");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get albums that have no rating
     * @returns {Promise<*>}
     */
    const unratedAlbums = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=advanced_search";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&type=album&operator=and&random=1";
        queryURL += "&rule_1=myrating&rule_1_operator=2&rule_1_input=0";

        if (query) {
            queryURL += "&rule_2=title&rule_2_operator=8&rule_2_input=" + encodeURI(query);
        }

        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "unratedAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Returns albums for search
     * @param query
     * @param page
     * @param limit
     * @returns {Promise<*>}
     */
    const searchAlbums = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=albums&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "searchAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get newly added albums
     * @returns {Promise<*>}
     */
    const newestAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=newest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "newestAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get newly released albums
     * @returns {Promise<*>}
     */
    // TODO: not currently possible from API
    const newReleases = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=newest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "newReleases");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get recently played albums
     * @returns {Promise<*>}
     */
    const recentAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=recent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "recentAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get favorite albums
     * @returns {Promise<*>}
     */
    const favoriteAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=flagged";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "favoriteAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get frequent albums
     * @returns {Promise<*>}
     */
    const frequentAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=frequent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "frequentAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get top rated albums
     * @returns {Promise<*>}
     */
    const topAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=highest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "topAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get forgotten albums
     * @returns {Promise<*>}
     */
    const forgottenAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=forgotten";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "forgottenAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get random albums
     * @returns {Promise<*>}
     */
    const randomAlbums = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=stats&type=album&filter=random";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "randomAlbums");
        return fetchAlbumData(queryURL);
    };

    /**
     * Get albums by genre
     * @returns {Promise<*>}
     */
    const getAlbumsByGenre = ({query, page = 0, limit = 50}) => {
        let queryURL = serverURL_value$5 + "/server/json.server.php?action=genre_albums&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getAlbumsByGenre");
        return fetchAlbumData(queryURL);
    };

    /**
     * Group albums by release type
     * @param {array} albums
     * @returns {Map<any, any>}
     */
    const groupAlbumsByReleaseType = async (albums) => {
        let releaseTypes = new Map();
        let preferenceAlbumReleaseType = await getUserPreference('album_release_type');
        let preferenceAlbumReleaseTypeSort = await getUserPreference('album_release_type_sort');
        let preferenceReleaseTypes = preferenceAlbumReleaseTypeSort.value.split(',');

        if (preferenceAlbumReleaseType.value === '1') {
            // Create base types in specified order from server setting
            for (let i = 0; i < preferenceReleaseTypes.length; i++) {
                if (!releaseTypes.get(preferenceReleaseTypes[i])) {
                    releaseTypes.set(preferenceReleaseTypes[i].toLowerCase(), []);
                }
            }

            // Add a catchall for missing/others
            releaseTypes.set("unknown", []);

            // Assign to existing types or create new ones as needed
            for (let i = 0; i < albums.length; i++) {
                let type = albums[i].type;

                if (type) {
                    type = type.toLowerCase();
                }

                if (!releaseTypes.get(type)) {
                    releaseTypes.set(type, []);
                }

                switch (type) {
                    case null:
                        releaseTypes.get("unknown").push(albums[i]);
                        break;
                    default:
                        releaseTypes.get(type).push(albums[i]);
                        break;
                }
            }
        } else {
            // just return the albums
            releaseTypes.set('ungrouped', albums);
        }

        return releaseTypes;
    };

    var album = /*#__PURE__*/Object.freeze({
        __proto__: null,
        sortAlbumsByDate: sortAlbumsByDate,
        getAlbums: getAlbums,
        getTopRatedAlbums: getTopRatedAlbums,
        getAlbumsRecentlyAdded: getAlbumsRecentlyAdded,
        getAlbumsStartingWith: getAlbumsStartingWith,
        testAlbumsStartingWith: testAlbumsStartingWith,
        getAlbum: getAlbum,
        getAlbumsByArtist: getAlbumsByArtist,
        getAlbumsByYear: getAlbumsByYear,
        unratedAlbums: unratedAlbums,
        searchAlbums: searchAlbums,
        newestAlbums: newestAlbums,
        newReleases: newReleases,
        recentAlbums: recentAlbums,
        favoriteAlbums: favoriteAlbums,
        frequentAlbums: frequentAlbums,
        topAlbums: topAlbums,
        forgottenAlbums: forgottenAlbums,
        randomAlbums: randomAlbums,
        getAlbumsByGenre: getAlbumsByGenre,
        groupAlbumsByReleaseType: groupAlbumsByReleaseType
    });

    let serverURL_value$4 = get_store_value(serverURL);

    /**
     * Make API request for artist data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchArtistData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.artist) ? data.artist : data;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Get all artists
     * @returns {Promise<*>}
     */
    const getArtists = async ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=artists";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getArtists");

        return fetchArtistData(queryURL);
    };

    /**
     * Get artists starting with specified character
     * @param {string} filterChar
     * @param albumArtistsOnly
     * @returns {Promise<*>}
     */
    const getArtistsStartingWith = async (filterChar, albumArtistsOnly = false) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=advanced_search&type=artist";
        // ignore punctuation and leading "The "
        queryURL += "&operator=and&rule_1=title&rule_1_operator=8&rule_1_input=" + encodeURI('^(?!the\\s)[[:punct:]]*') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getArtistsStartingWith");

        let artists = await fetchArtistData(queryURL);

        artists.sort(function(obj1, obj2) {
            return obj1.name.toLowerCase().replace(/([^a-z0-9\s]|the\s)/g, "").localeCompare(obj2.name.toLowerCase().replace(/([^a-z0-9\s]|the\s)/g, "")) ;
        });

        if (albumArtistsOnly) {
            artists = artists.filter(a => a.albumcount > 0);
        }

        return artists;
    };

    /**
     * Test existence of artists starting with specified character
     * @param {string} filterChar
     * @param albumArtistsOnly
     * @returns {Promise<*>}
     */
    const testArtistsStartingWith = async (filterChar, albumArtistsOnly = false) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=advanced_search&type=artist";

        // need to check more artists if albumArtistsOnly in case some get filtered out
        // 20 seems like a reasonable balance between speed and accuracy
        queryURL += `&limit=${albumArtistsOnly ? 20 : 1}`;

        queryURL += "&operator=and&rule_1=title&rule_1_operator=8&rule_1_input=" + encodeURI('^[[:punct:]]*') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "testArtistsStartingWith");

        let artists = await fetchArtistData(queryURL);

        if (albumArtistsOnly) {
            artists = artists.filter(a => a.albumcount > 0);
        }

        return artists;
    };

    /**
     * Get artist by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getArtist = async (id) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=artist&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getArtist");

        let artist = await fetchArtistData(queryURL);
        artist.useBackground = await placeholderArtCheck(artist.art + "&thumb=10");
        artist.averageColor = await getAverageColor(artist.art + "&thumb=10");
        artist.legibleColors = await getLegibleColors(artist.averageColor.value);

        customColors.set(artist.legibleColors);
        let mp = get_store_value(MediaPlayer);
        await mp.setWaveColors();

        let appearances = await getAlbumsByArtist(artist.id);
        artist.appearanceCount = appearances.length - artist.albumcount;

        return artist;
    };

    /**
     * Get artists that have no rating
     * @returns {Promise<*>}
     */
    const unratedArtists = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=advanced_search";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&type=artist&operator=and&random=1";
        queryURL += "&rule_1=myrating&rule_1_operator=2&rule_1_input=0";

        if (query) {
            queryURL += "&rule_2=title&rule_2_operator=8&rule_2_input=" + encodeURI(query);
        }

        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "unratedArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Returns artists for search
     * @param query
     * @param page
     * @param limit
     * @returns {Promise<*>}
     */
    const searchArtists = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=artists&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "searchArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get newest artists
     * @returns {Promise<*>}
     */
    const newestArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=newest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "newestArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get recently played artists
     * @returns {Promise<*>}
     */
    const recentArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=recent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "recentArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get favorite artists
     * @returns {Promise<*>}
     */
    const favoriteArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=flagged";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "favoriteArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get frequent artists
     * @returns {Promise<*>}
     */
    const frequentArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=frequent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "frequentArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get top rated artists
     * @returns {Promise<*>}
     */
    const topArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=highest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "topArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get forgotten artists
     * @returns {Promise<*>}
     */
    const forgottenArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=forgotten";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "forgottenArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get random artists
     * @returns {Promise<*>}
     */
    const randomArtists = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=stats&type=artist&filter=random";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "randomArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get similar artists
     * @returns {Promise<*>}
     */
    const similarArtists = (id) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=get_similar&type=artist&filter=" + id;
        queryURL += "&limit=15";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "similarArtists");
        return fetchArtistData(queryURL);
    };

    /**
     * Get artists by genre
     * @returns {Promise<*>}
     */
    const getArtistsByGenre = ({query, page = 0, limit = 50}) => {
        let queryURL = serverURL_value$4 + "/server/json.server.php?action=genre_artists&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getArtistsByGenre");
        return fetchArtistData(queryURL);
    };

    var artist = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getArtists: getArtists,
        getArtistsStartingWith: getArtistsStartingWith,
        testArtistsStartingWith: testArtistsStartingWith,
        getArtist: getArtist,
        unratedArtists: unratedArtists,
        searchArtists: searchArtists,
        newestArtists: newestArtists,
        recentArtists: recentArtists,
        favoriteArtists: favoriteArtists,
        frequentArtists: frequentArtists,
        topArtists: topArtists,
        forgottenArtists: forgottenArtists,
        randomArtists: randomArtists,
        similarArtists: similarArtists,
        getArtistsByGenre: getArtistsByGenre
    });

    function clickOutsideDetector(node, options) {
        function handleEvent(e) {
            // ignore clicks without our object
            if (node.contains(e.target)) {
                return;
            }

            // ignore clicks on the toggle
            if (options.toggle && options.toggle.contains && options.toggle.contains(e.target)) {
                return;
            }

            // ignore clicks on specified items
            if (options.ignore && e.target.closest(options.ignore)) {
                return;
            }

            node.dispatchEvent(new CustomEvent('clickedOutside'));
        }

        window.addEventListener('mousedown', handleEvent);

        return {
            destroy() {
                window.removeEventListener('mousedown', handleEvent);
            }
        };
    }

    /* public\images\artist.svg generated by Svelte v3.38.3 */

    function create_fragment$1E(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v1c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-1c0-2.66-5.33-4-8-4z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Artist$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, {});
    	}
    }

    /* src\components\sidebarDrawer.svelte generated by Svelte v3.38.3 */
    const file$V = "src\\components\\sidebarDrawer.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i][0];
    	child_ctx[17] = list[i][1];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i][0];
    	child_ctx[17] = list[i][1];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i][0];
    	child_ctx[17] = list[i][1];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i][0];
    	child_ctx[17] = list[i][1];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (144:12) {#if $albumIndex}
    function create_if_block_9$5(ctx) {
    	let each_1_anchor;
    	let each_value_5 = [.../*$albumIndex*/ ctx[9]];
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*handleAlphaScroll, $albumIndex*/ 512) {
    				each_value_5 = [.../*$albumIndex*/ ctx[9]];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$5.name,
    		type: "if",
    		source: "(144:12) {#if $albumIndex}",
    		ctx
    	});

    	return block;
    }

    // (127:8) {#if type === 'artist'}
    function create_if_block_6$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*$artistIndex*/ ctx[8] && create_if_block_7$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$artistIndex*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_7$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$9.name,
    		type: "if",
    		source: "(127:8) {#if type === 'artist'}",
    		ctx
    	});

    	return block;
    }

    // (146:20) {#if value.albumCount > 0}
    function create_if_block_10$3(ctx) {
    	let button;
    	let t0_value = /*key*/ ctx[16] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(button, file$V, 146, 24, 4416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", handleAlphaScroll, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$albumIndex*/ 512 && t0_value !== (t0_value = /*key*/ ctx[16] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$3.name,
    		type: "if",
    		source: "(146:20) {#if value.albumCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (145:16) {#each [...$albumIndex] as [key, value], i}
    function create_each_block_5(ctx) {
    	let if_block_anchor;
    	let if_block = /*value*/ ctx[17].albumCount > 0 && create_if_block_10$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*value*/ ctx[17].albumCount > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_10$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(145:16) {#each [...$albumIndex] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (128:12) {#if $artistIndex}
    function create_if_block_7$8(ctx) {
    	let each_1_anchor;
    	let each_value_4 = [.../*$artistIndex*/ ctx[8]];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$ShowAlbumArtistsOnly, parseInt, $artistIndex, handleAlphaScroll*/ 288) {
    				each_value_4 = [.../*$artistIndex*/ ctx[8]];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$8.name,
    		type: "if",
    		source: "(128:12) {#if $artistIndex}",
    		ctx
    	});

    	return block;
    }

    // (130:20) {#if value.artistCount > 0 || value.albumArtistCount > 0}
    function create_if_block_8$5(ctx) {
    	let button;
    	let t0_value = /*key*/ ctx[16] + "";
    	let t0;
    	let t1;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			button.disabled = button_disabled_value = /*$ShowAlbumArtistsOnly*/ ctx[5] && parseInt(/*value*/ ctx[17].albumArtistCount) === 0 || !/*$ShowAlbumArtistsOnly*/ ctx[5] && parseInt(/*value*/ ctx[17].artistCount) === 0;
    			add_location(button, file$V, 130, 24, 3732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", handleAlphaScroll, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$artistIndex*/ 256 && t0_value !== (t0_value = /*key*/ ctx[16] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$ShowAlbumArtistsOnly, $artistIndex*/ 288 && button_disabled_value !== (button_disabled_value = /*$ShowAlbumArtistsOnly*/ ctx[5] && parseInt(/*value*/ ctx[17].albumArtistCount) === 0 || !/*$ShowAlbumArtistsOnly*/ ctx[5] && parseInt(/*value*/ ctx[17].artistCount) === 0)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$5.name,
    		type: "if",
    		source: "(130:20) {#if value.artistCount > 0 || value.albumArtistCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (129:16) {#each [...$artistIndex] as [key, value], i}
    function create_each_block_4(ctx) {
    	let if_block_anchor;
    	let if_block = (/*value*/ ctx[17].artistCount > 0 || /*value*/ ctx[17].albumArtistCount > 0) && create_if_block_8$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*value*/ ctx[17].artistCount > 0 || /*value*/ ctx[17].albumArtistCount > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_8$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(129:16) {#each [...$artistIndex] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (159:8) {#if type === 'artist'}
    function create_if_block_5$9(ctx) {
    	let div;
    	let label;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			input = element("input");
    			t = text("\r\n                    Show album artists only");
    			attr_dev(input, "type", "checkbox");
    			input.disabled = /*loading*/ ctx[7];
    			add_location(input, file$V, 161, 20, 4816);
    			add_location(label, file$V, 160, 16, 4787);
    			attr_dev(div, "class", "header svelte-1nax0yy");
    			add_location(div, file$V, 159, 12, 4749);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, input);
    			input.checked = /*$ShowAlbumArtistsOnly*/ ctx[5];
    			append_dev(label, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*handleToggleAlbumArtists*/ ctx[10], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[13])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*loading*/ 128) {
    				prop_dev(input, "disabled", /*loading*/ ctx[7]);
    			}

    			if (dirty & /*$ShowAlbumArtistsOnly*/ 32) {
    				input.checked = /*$ShowAlbumArtistsOnly*/ ctx[5];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$9.name,
    		type: "if",
    		source: "(159:8) {#if type === 'artist'}",
    		ctx
    	});

    	return block;
    }

    // (232:8) {:else}
    function create_else_block$r(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading";
    			set_style(p, "padding-left", "var(--spacing-lg)");
    			add_location(p, file$V, 232, 11, 8035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$r.name,
    		type: "else",
    		source: "(232:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (168:8) {#if !loading}
    function create_if_block$E(ctx) {
    	let ul;
    	let t;
    	let current;
    	let if_block0 = /*type*/ ctx[1] === "artist" && /*$allArtists*/ ctx[4] && create_if_block_3$i(ctx);
    	let if_block1 = /*type*/ ctx[1] === "album" && /*$allAlbums*/ ctx[6] && create_if_block_1$v(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(ul, "class", "svelte-1nax0yy");
    			add_location(ul, file$V, 168, 12, 5078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			if (if_block0) if_block0.m(ul, null);
    			append_dev(ul, t);
    			if (if_block1) if_block1.m(ul, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*type*/ ctx[1] === "artist" && /*$allArtists*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*type, $allArtists*/ 18) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$i(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(ul, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "album" && /*$allAlbums*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type, $allAlbums*/ 66) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$v(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(ul, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(168:8) {#if !loading}",
    		ctx
    	});

    	return block;
    }

    // (170:16) {#if type === 'artist' && $allArtists}
    function create_if_block_3$i(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = [.../*dataDisplay*/ ctx[3]];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataDisplay, type, handleClick*/ 2058) {
    				each_value_2 = [.../*dataDisplay*/ ctx[3]];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$i.name,
    		type: "if",
    		source: "(170:16) {#if type === 'artist' && $allArtists}",
    		ctx
    	});

    	return block;
    }

    // (187:36) {#if type === 'album'}
    function create_if_block_4$e(ctx) {
    	let div;
    	let svgartist;
    	let t0;
    	let t1_value = /*single*/ ctx[20].artist.name + "";
    	let t1;
    	let div_title_value;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(div, "class", "artist-name svelte-1nax0yy");
    			attr_dev(div, "title", div_title_value = /*single*/ ctx[20].artist.name);
    			add_location(div, file$V, 187, 40, 6002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(svgartist, div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t1_value !== (t1_value = /*single*/ ctx[20].artist.name + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*dataDisplay*/ 8 && div_title_value !== (div_title_value = /*single*/ ctx[20].artist.name)) {
    				attr_dev(div, "title", div_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgartist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$e.name,
    		type: "if",
    		source: "(187:36) {#if type === 'album'}",
    		ctx
    	});

    	return block;
    }

    // (176:32) <Link                                      to="{type === 'artist' ? 'artists' : 'albums'}/{single.id}"                                      on:click={handleClick}                                  >
    function create_default_slot_1$f(ctx) {
    	let div;
    	let t0_value = /*single*/ ctx[20].name + "";
    	let t0;
    	let div_title_value;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let if_block = /*type*/ ctx[1] === "album" && create_if_block_4$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "class", "item-name svelte-1nax0yy");
    			attr_dev(div, "title", div_title_value = /*single*/ ctx[20].name);
    			add_location(div, file$V, 179, 36, 5634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t0_value !== (t0_value = /*single*/ ctx[20].name + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*dataDisplay*/ 8 && div_title_value !== (div_title_value = /*single*/ ctx[20].name)) {
    				attr_dev(div, "title", div_title_value);
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(176:32) <Link                                      to=\\\"{type === 'artist' ? 'artists' : 'albums'}/{single.id}\\\"                                      on:click={handleClick}                                  >",
    		ctx
    	});

    	return block;
    }

    // (174:24) {#each value as single}
    function create_each_block_3$2(ctx) {
    	let li;
    	let link;
    	let t;
    	let current;

    	link = new Link({
    			props: {
    				to: "" + ((/*type*/ ctx[1] === "artist" ? "artists" : "albums") + "/" + /*single*/ ctx[20].id),
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link.$on("click", /*handleClick*/ ctx[11]);

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "item svelte-1nax0yy");
    			add_location(li, file$V, 174, 28, 5348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*type, dataDisplay*/ 10) link_changes.to = "" + ((/*type*/ ctx[1] === "artist" ? "artists" : "albums") + "/" + /*single*/ ctx[20].id);

    			if (dirty & /*$$scope, dataDisplay, type*/ 268435466) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(174:24) {#each value as single}",
    		ctx
    	});

    	return block;
    }

    // (171:20) {#each [...dataDisplay] as [key, value], i}
    function create_each_block_2$4(ctx) {
    	let li;
    	let t0_value = /*key*/ ctx[16] + "";
    	let t0;
    	let t1;
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*value*/ ctx[17];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(li, "class", "item subheading svelte-1nax0yy");
    			add_location(li, file$V, 171, 24, 5229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			insert_dev(target, t1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t0_value !== (t0_value = /*key*/ ctx[16] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*type, dataDisplay, handleClick*/ 2058) {
    				each_value_3 = /*value*/ ctx[17];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (detaching) detach_dev(t1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(171:20) {#each [...dataDisplay] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (201:16) {#if type === 'album' && $allAlbums}
    function create_if_block_1$v(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = [.../*dataDisplay*/ ctx[3]];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataDisplay, type, handleClick*/ 2058) {
    				each_value = [.../*dataDisplay*/ ctx[3]];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$v.name,
    		type: "if",
    		source: "(201:16) {#if type === 'album' && $allAlbums}",
    		ctx
    	});

    	return block;
    }

    // (218:36) {#if type === 'album'}
    function create_if_block_2$q(ctx) {
    	let div;
    	let svgartist;
    	let t0;
    	let t1_value = /*single*/ ctx[20].artist.name + "";
    	let t1;
    	let div_title_value;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(div, "class", "artist-name svelte-1nax0yy");
    			attr_dev(div, "title", div_title_value = /*single*/ ctx[20].artist.name);
    			add_location(div, file$V, 218, 40, 7454);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(svgartist, div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t1_value !== (t1_value = /*single*/ ctx[20].artist.name + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*dataDisplay*/ 8 && div_title_value !== (div_title_value = /*single*/ ctx[20].artist.name)) {
    				attr_dev(div, "title", div_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgartist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$q.name,
    		type: "if",
    		source: "(218:36) {#if type === 'album'}",
    		ctx
    	});

    	return block;
    }

    // (207:32) <Link                                      to="{type === 'artist' ? 'artists' : 'albums'}/{single.id}"                                      on:click={handleClick}                                  >
    function create_default_slot$t(ctx) {
    	let div;
    	let t0_value = /*single*/ ctx[20].name + "";
    	let t0;
    	let div_title_value;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let if_block = /*type*/ ctx[1] === "album" && create_if_block_2$q(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "class", "item-name svelte-1nax0yy");
    			attr_dev(div, "title", div_title_value = /*single*/ ctx[20].name);
    			add_location(div, file$V, 210, 36, 7086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t0_value !== (t0_value = /*single*/ ctx[20].name + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*dataDisplay*/ 8 && div_title_value !== (div_title_value = /*single*/ ctx[20].name)) {
    				attr_dev(div, "title", div_title_value);
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(207:32) <Link                                      to=\\\"{type === 'artist' ? 'artists' : 'albums'}/{single.id}\\\"                                      on:click={handleClick}                                  >",
    		ctx
    	});

    	return block;
    }

    // (205:24) {#each value as single}
    function create_each_block_1$7(ctx) {
    	let li;
    	let link;
    	let t;
    	let current;

    	link = new Link({
    			props: {
    				to: "" + ((/*type*/ ctx[1] === "artist" ? "artists" : "albums") + "/" + /*single*/ ctx[20].id),
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link.$on("click", /*handleClick*/ ctx[11]);

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "item svelte-1nax0yy");
    			add_location(li, file$V, 205, 28, 6800);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*type, dataDisplay*/ 10) link_changes.to = "" + ((/*type*/ ctx[1] === "artist" ? "artists" : "albums") + "/" + /*single*/ ctx[20].id);

    			if (dirty & /*$$scope, dataDisplay, type*/ 268435466) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(205:24) {#each value as single}",
    		ctx
    	});

    	return block;
    }

    // (202:20) {#each [...dataDisplay] as [key, value], i}
    function create_each_block$g(ctx) {
    	let li;
    	let t0_value = /*key*/ ctx[16] + "";
    	let t0;
    	let t1;
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*value*/ ctx[17];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(li, "class", "item subheading svelte-1nax0yy");
    			add_location(li, file$V, 202, 24, 6681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			insert_dev(target, t1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*dataDisplay*/ 8) && t0_value !== (t0_value = /*key*/ ctx[16] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*type, dataDisplay, handleClick*/ 2058) {
    				each_value_1 = /*value*/ ctx[17];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (detaching) detach_dev(t1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(202:20) {#each [...dataDisplay] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1D(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let current_block_type_index;
    	let if_block2;
    	let clickOutsideDetector_action;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[1] === "artist") return create_if_block_6$9;
    		if (/*$albumIndex*/ ctx[9]) return create_if_block_9$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type && current_block_type(ctx);
    	let if_block1 = /*type*/ ctx[1] === "artist" && create_if_block_5$9(ctx);
    	const if_block_creators = [create_if_block$E, create_else_block$r];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (!/*loading*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			attr_dev(div0, "class", "alpha svelte-1nax0yy");
    			toggle_class(div0, "loaded", !/*loading*/ ctx[7]);
    			add_location(div0, file$V, 125, 4, 3457);
    			attr_dev(div1, "class", "list svelte-1nax0yy");
    			add_location(div1, file$V, 157, 4, 4684);
    			attr_dev(div2, "class", "container c-sidebar-drawer svelte-1nax0yy");
    			toggle_class(div2, "visible", /*visible*/ ctx[0]);
    			add_location(div2, file$V, 117, 0, 3259);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t1);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(clickOutsideDetector_action = clickOutsideDetector.call(null, div2, { toggle: /*toggleElement*/ ctx[2] })),
    					listen_dev(div2, "clickedOutside", /*handleClickOutside*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if (if_block0) if_block0.d(1);
    				if_block0 = current_block_type && current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			}

    			if (dirty & /*loading*/ 128) {
    				toggle_class(div0, "loaded", !/*loading*/ ctx[7]);
    			}

    			if (/*type*/ ctx[1] === "artist") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_5$9(ctx);
    					if_block1.c();
    					if_block1.m(div1, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div1, null);
    			}

    			if (clickOutsideDetector_action && is_function(clickOutsideDetector_action.update) && dirty & /*toggleElement*/ 4) clickOutsideDetector_action.update.call(null, { toggle: /*toggleElement*/ ctx[2] });

    			if (dirty & /*visible*/ 1) {
    				toggle_class(div2, "visible", /*visible*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);

    			if (if_block0) {
    				if_block0.d();
    			}

    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function groupByFirstChar(items) {
    	let grouped = new Map();

    	// Add a catchall for numbers and non-word chars
    	grouped.set("#", []);

    	for (let i = 0; i < items.length; i++) {
    		let char = items[i].name.charAt(0).toLowerCase();

    		// if digit or non-word char
    		if ((/^(\d|\W)/i).test(char)) {
    			grouped.get("#").push(items[i]);
    			continue;
    		}

    		if (!grouped.get(char)) {
    			grouped.set(char, []);
    		}

    		grouped.get(char).push(items[i]);
    	}

    	return grouped;
    }

    function handleAlphaScroll(e) {
    	let thisLetter = e.target.textContent.charAt(0).toLowerCase();
    	let items = e.target.closest(".container").querySelectorAll(".item");
    	let foundElement = Array.from(items).find(element => element.textContent.charAt(0).toLowerCase() === thisLetter);

    	if (thisLetter === "#") {
    		Array.from(items)[0].scrollIntoView();
    	}

    	if (foundElement) {
    		foundElement.scrollIntoView();
    	}
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let $allArtists;
    	let $ShowAlbumArtistsOnly;
    	let $allAlbums;
    	let $artistIndex;
    	let $albumIndex;
    	validate_store(allArtists, "allArtists");
    	component_subscribe($$self, allArtists, $$value => $$invalidate(4, $allArtists = $$value));
    	validate_store(ShowAlbumArtistsOnly, "ShowAlbumArtistsOnly");
    	component_subscribe($$self, ShowAlbumArtistsOnly, $$value => $$invalidate(5, $ShowAlbumArtistsOnly = $$value));
    	validate_store(allAlbums, "allAlbums");
    	component_subscribe($$self, allAlbums, $$value => $$invalidate(6, $allAlbums = $$value));
    	validate_store(artistIndex, "artistIndex");
    	component_subscribe($$self, artistIndex, $$value => $$invalidate(8, $artistIndex = $$value));
    	validate_store(albumIndex, "albumIndex");
    	component_subscribe($$self, albumIndex, $$value => $$invalidate(9, $albumIndex = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SidebarDrawer", slots, []);
    	let { visible = false } = $$props;
    	let { type } = $$props;
    	let { toggleElement } = $$props;
    	let data = [];
    	let dataDisplay;
    	let loading = true;

    	async function loadAll() {
    		$$invalidate(7, loading = true);

    		if (type === "artist") {
    			data = await getArtists({ limit: null, page: null });

    			data = data.sort(function (obj1, obj2) {
    				return obj1.name.localeCompare(obj2.name);
    			});

    			allArtists.set({ loaded: true, data });
    			data = null; // flush
    		} else {
    			data = await getAlbums({ limit: null, page: null });

    			data = data.sort(function (obj1, obj2) {
    				return obj1.name.localeCompare(obj2.name);
    			});

    			allAlbums.set({ loaded: true, data });
    			data = null; // flush
    		}

    		$$invalidate(7, loading = false);
    	}

    	function handleToggleAlbumArtists() {
    		ShowAlbumArtistsOnly.set(!$ShowAlbumArtistsOnly);
    	}

    	function handleClick() {
    		$$invalidate(0, visible = false);
    	}

    	function handleClickOutside() {
    		$$invalidate(0, visible = false);
    	}

    	onMount(() => {
    		loadAll();
    	});

    	const writable_props = ["visible", "type", "toggleElement"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SidebarDrawer> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		$ShowAlbumArtistsOnly = this.checked;
    		ShowAlbumArtistsOnly.set($ShowAlbumArtistsOnly);
    	}

    	$$self.$$set = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("toggleElement" in $$props) $$invalidate(2, toggleElement = $$props.toggleElement);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Link,
    		allArtists,
    		allAlbums,
    		artistIndex,
    		albumIndex,
    		ShowAlbumArtistsOnly,
    		getArtists,
    		getAlbums,
    		clickOutsideDetector,
    		SVGArtist: Artist$1,
    		visible,
    		type,
    		toggleElement,
    		data,
    		dataDisplay,
    		loading,
    		groupByFirstChar,
    		loadAll,
    		handleToggleAlbumArtists,
    		handleClick,
    		handleClickOutside,
    		handleAlphaScroll,
    		$allArtists,
    		$ShowAlbumArtistsOnly,
    		$allAlbums,
    		$artistIndex,
    		$albumIndex
    	});

    	$$self.$inject_state = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("toggleElement" in $$props) $$invalidate(2, toggleElement = $$props.toggleElement);
    		if ("data" in $$props) data = $$props.data;
    		if ("dataDisplay" in $$props) $$invalidate(3, dataDisplay = $$props.dataDisplay);
    		if ("loading" in $$props) $$invalidate(7, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type, $allArtists, $ShowAlbumArtistsOnly, dataDisplay, $allAlbums*/ 122) {
    			{
    				if (type === "artist" && $allArtists.loaded) {
    					$$invalidate(3, dataDisplay = $ShowAlbumArtistsOnly
    					? $allArtists.data.filter(a => a.albumcount > 0)
    					: $allArtists.data);

    					$$invalidate(3, dataDisplay = groupByFirstChar(dataDisplay));
    				}

    				if (type !== "artist" && $allAlbums.loaded) {
    					$$invalidate(3, dataDisplay = groupByFirstChar($allAlbums.data));
    				}
    			}
    		}
    	};

    	return [
    		visible,
    		type,
    		toggleElement,
    		dataDisplay,
    		$allArtists,
    		$ShowAlbumArtistsOnly,
    		$allAlbums,
    		loading,
    		$artistIndex,
    		$albumIndex,
    		handleToggleAlbumArtists,
    		handleClick,
    		handleClickOutside,
    		input_change_handler
    	];
    }

    class SidebarDrawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, { visible: 0, type: 1, toggleElement: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SidebarDrawer",
    			options,
    			id: create_fragment$1D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<SidebarDrawer> was created without expected prop 'type'");
    		}

    		if (/*toggleElement*/ ctx[2] === undefined && !("toggleElement" in props)) {
    			console.warn("<SidebarDrawer> was created without expected prop 'toggleElement'");
    		}
    	}

    	get visible() {
    		throw new Error("<SidebarDrawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<SidebarDrawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<SidebarDrawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<SidebarDrawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleElement() {
    		throw new Error("<SidebarDrawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleElement(value) {
    		throw new Error("<SidebarDrawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\ample_logo.svg generated by Svelte v3.38.3 */

    function create_fragment$1C(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 332.201 44.087" },
    		{ class: "ample-logo" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(nodes, "svg", { xmlns: true, viewBox: true, class: true }, 1);
    			var svg_nodes = children(svg);
    			g = claim_element(svg_nodes, "g", { class: true }, 1);
    			var g_nodes = children(g);
    			path0 = claim_element(g_nodes, "path", { d: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(g_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			path2 = claim_element(g_nodes, "path", { d: true }, 1);
    			children(path2).forEach(detach);
    			g_nodes.forEach(detach);
    			path3 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path3).forEach(detach);
    			path4 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path4).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M8.727,44.087C2.475,44.087,0,41.612,0,37.055a15.964,15.964,0,0,1,.26-2.931L1.3,28.132c1.108-6.448,4.493-9.964,11.983-9.964h37.38l.52-2.8a12.851,12.851,0,0,0,.261-2.54c0-3.06-1.693-3.451-4.689-3.451H5.731L7.359,0H50.6c7.684,0,11.332,3.321,11.332,10.028a26.225,26.225,0,0,1-.392,4.3L56.266,44.087ZM49.363,25.528H15.7c-2.736,0-3.972,1.367-4.428,3.841l-.391,2.215a10.382,10.382,0,0,0-.2,1.759c0,1.953,1.043,2.213,3.256,2.213h33.67Z");
    			attr(path1, "d", "M128.062,44.087l5.079-28.719a12.851,12.851,0,0,0,.261-2.54c0-3.06-1.693-3.451-4.624-3.451H113.539l-6.121,34.71H97.259l6.12-34.71H82.8l-6.12,34.71H66.456L74.2,0h58.35c7.751,0,11.4,3.45,11.4,10.157a24.265,24.265,0,0,1-.391,4.168l-5.275,29.762Z");
    			attr(path2, "d", "M160.678,33.147l-1.953,10.94H148.5L156.249,0h46.174c6.252,0,8.791,2.409,8.791,6.968a17.517,17.517,0,0,1-.326,3l-2.149,12.372c-1.3,7.62-4.624,10.811-12.112,10.811Zm39.6-20.775a9.069,9.069,0,0,0,.194-1.692c0-1.955-1.106-2.151-3.256-2.151H164.977l-2.865,16.282h32.235c2.736,0,3.908-1.3,4.428-4.167Z");
    			attr(g, "class", "amp");
    			attr(path3, "d", "M226.712,44.087c-7.684,0-11.4-3.32-11.4-10.028a26.816,26.816,0,0,1,.456-4.3L220.98,0H231.2l-5.013,28.719a16.183,16.183,0,0,0-.327,2.669c0,3.06,1.759,3.256,4.691,3.256h32.951l-1.692,9.443Z");
    			attr(path4, "d", "M281.6,44.087c-7.748,0-11.4-3.32-11.4-10.028a26.048,26.048,0,0,1,.392-4.3l3.451-19.8C275.152,3.516,278.6,0,286.158,0h37.251c6.252,0,8.792,2.409,8.792,6.968a17.525,17.525,0,0,1-.327,3l-1.041,6.185c-1.108,6.447-4.5,9.964-11.983,9.964H281.535l-.456,2.606a15.082,15.082,0,0,0-.261,2.669c0,3.06,1.628,3.256,4.689,3.256h40.962l-1.692,9.443Zm39.726-31.715a6.951,6.951,0,0,0,.129-1.563c0-1.953-1.041-2.28-3.256-2.28H288.371c-2.733,0-3.972,1.3-4.428,3.843l-1.107,6.317h33.6c2.8,0,3.972-1.433,4.428-3.908Z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g);
    			append(g, path0);
    			append(g, path1);
    			append(g, path2);
    			append(svg, path3);
    			append(svg, path4);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 332.201 44.087" },
    				{ class: "ample-logo" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ample_logo extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {});
    	}
    }

    /* public\images\album.svg generated by Svelte v3.38.3 */

    function create_fragment$1B(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Album$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, {});
    	}
    }

    /* public\images\queue_music.svg generated by Svelte v3.38.3 */

    function create_fragment$1A(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M14 6H4c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1zm0 4H4c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1zM4 16h6c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1zM19 6c-1.1 0-2 .9-2 2v6.18c-.31-.11-.65-.18-1-.18-1.84 0-3.28 1.64-2.95 3.54.21 1.21 1.2 2.2 2.41 2.41 1.9.33 3.54-1.11 3.54-2.95V8h2c.55 0 1-.45 1-1s-.45-1-1-1h-2z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Queue_music extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {});
    	}
    }

    /* public\images\smartlist.svg generated by Svelte v3.38.3 */

    function create_fragment$1z(ctx) {
    	let svg;
    	let g0;
    	let rect;
    	let g1;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect = svg_element("rect");
    			g1 = svg_element("g");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			rect = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			g0_nodes.forEach(detach);
    			g1 = claim_element(svg_nodes, "g", {}, 1);
    			var g1_nodes = children(g1);
    			path = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			g1_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M10.67,21L10.67,21c-0.35,0-0.62-0.31-0.57-0.66L11,14H7.5c-0.88,0-0.33-0.75-0.31-0.78c1.26-2.23,3.15-5.53,5.65-9.93 c0.1-0.18,0.3-0.29,0.5-0.29h0c0.35,0,0.62,0.31,0.57,0.66L13.01,10h3.51c0.4,0,0.62,0.19,0.4,0.66c-3.29,5.74-5.2,9.09-5.75,10.05 C11.07,20.89,10.88,21,10.67,21z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, rect);
    			append(svg, g1);
    			append(g1, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Smartlist extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {});
    	}
    }

    /* public\images\star_full.svg generated by Svelte v3.38.3 */

    function create_fragment$1y(ctx) {
    	let svg;
    	let g0;
    	let path0;
    	let path1;
    	let g1;
    	let path2;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			g1 = svg_element("g");
    			path2 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			path0 = claim_element(g0_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(g0_nodes, "path", { d: true, fill: true }, 1);
    			children(path1).forEach(detach);
    			g0_nodes.forEach(detach);
    			g1 = claim_element(svg_nodes, "g", {}, 1);
    			var g1_nodes = children(g1);
    			path2 = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path2).forEach(detach);
    			g1_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0,0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M0,0h24v24H0V0z");
    			attr(path1, "fill", "none");
    			attr(path2, "d", "M12,17.27l4.15,2.51c0.76,0.46,1.69-0.22,1.49-1.08l-1.1-4.72l3.67-3.18c0.67-0.58,0.31-1.68-0.57-1.75l-4.83-0.41 l-1.89-4.46c-0.34-0.81-1.5-0.81-1.84,0L9.19,8.63L4.36,9.04c-0.88,0.07-1.24,1.17-0.57,1.75l3.67,3.18l-1.1,4.72 c-0.2,0.86,0.73,1.54,1.49,1.08L12,17.27z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, path0);
    			append(g0, path1);
    			append(svg, g1);
    			append(g1, path2);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_full extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {});
    	}
    }

    /* public\images\star_outline.svg generated by Svelte v3.38.3 */

    function create_fragment$1x(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M19.65 9.04l-4.84-.42-1.89-4.45c-.34-.81-1.5-.81-1.84 0L9.19 8.63l-4.83.41c-.88.07-1.24 1.17-.57 1.75l3.67 3.18-1.1 4.72c-.2.86.73 1.54 1.49 1.08l4.15-2.5 4.15 2.51c.76.46 1.69-.22 1.49-1.08l-1.1-4.73 3.67-3.18c.67-.58.32-1.68-.56-1.75zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_outline extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {});
    	}
    }

    /* public\images\favorite_full.svg generated by Svelte v3.38.3 */

    function create_fragment$1w(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M13.35 20.13c-.76.69-1.93.69-2.69-.01l-.11-.1C5.3 15.27 1.87 12.16 2 8.28c.06-1.7.93-3.33 2.34-4.29 2.64-1.8 5.9-.96 7.66 1.1 1.76-2.06 5.02-2.91 7.66-1.1 1.41.96 2.28 2.59 2.34 4.29.14 3.88-3.3 6.99-8.55 11.76l-.1.09z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Favorite_full extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {});
    	}
    }

    /* public\images\recent.svg generated by Svelte v3.38.3 */

    function create_fragment$1v(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M13.26 3C8.17 2.86 4 6.95 4 12H2.21c-.45 0-.67.54-.35.85l2.79 2.8c.2.2.51.2.71 0l2.79-2.8c.31-.31.09-.85-.36-.85H6c0-3.9 3.18-7.05 7.1-7 3.72.05 6.85 3.18 6.9 6.9.05 3.91-3.1 7.1-7 7.1-1.61 0-3.1-.55-4.28-1.48-.4-.31-.96-.28-1.32.08-.42.42-.39 1.13.08 1.49C9 20.29 10.91 21 13 21c5.05 0 9.14-4.17 9-9.26-.13-4.69-4.05-8.61-8.74-8.74zm-.51 5c-.41 0-.75.34-.75.75v3.68c0 .35.19.68.49.86l3.12 1.85c.36.21.82.09 1.03-.26.21-.36.09-.82-.26-1.03l-2.88-1.71v-3.4c0-.4-.34-.74-.75-.74z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Recent$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {});
    	}
    }

    /* public\images\new.svg generated by Svelte v3.38.3 */

    function create_fragment$1u(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M22.42 11.34l-1.86-2.12.26-2.81c.05-.5-.29-.96-.77-1.07l-2.76-.63-1.44-2.43c-.26-.43-.79-.61-1.25-.41L12 3 9.41 1.89c-.46-.2-1-.02-1.25.41L6.71 4.72l-2.75.62c-.49.11-.83.56-.78 1.07l.26 2.8-1.86 2.13c-.33.38-.33.94 0 1.32l1.86 2.12-.26 2.82c-.05.5.29.96.77 1.07l2.76.63 1.44 2.42c.26.43.79.61 1.26.41L12 21l2.59 1.11c.46.2 1 .02 1.25-.41l1.44-2.43 2.76-.63c.49-.11.82-.57.77-1.07l-.26-2.81 1.86-2.12c.34-.36.34-.92.01-1.3zM13 17h-2v-2h2v2zm-1-4c-.55 0-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class New extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});
    	}
    }

    /* public\images\trending_up.svg generated by Svelte v3.38.3 */

    function create_fragment$1t(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M16.85 6.85l1.44 1.44-4.88 4.88-3.29-3.29c-.39-.39-1.02-.39-1.41 0l-6 6.01c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L9.41 12l3.29 3.29c.39.39 1.02.39 1.41 0l5.59-5.58 1.44 1.44c.31.31.85.09.85-.35V6.5c.01-.28-.21-.5-.49-.5h-4.29c-.45 0-.67.54-.36.85z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Trending_up extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});
    	}
    }

    /* public\images\trending_down.svg generated by Svelte v3.38.3 */

    function create_fragment$1s(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M16.85 17.15l1.44-1.44-4.88-4.88-3.29 3.29c-.39.39-1.02.39-1.41 0l-6-6.01c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L9.41 12l3.29-3.29c.39-.39 1.02-.39 1.41 0l5.59 5.58 1.44-1.44c.31-.31.85-.09.85.35v4.29c0 .28-.22.5-.5.5H17.2c-.44.01-.66-.53-.35-.84z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Trending_down extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {});
    	}
    }

    /* public\images\random.svg generated by Svelte v3.38.3 */

    function create_fragment$1r(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M17.65 4.35l-2.79 2.79c-.32.32-.1.86.35.86H17v6.88c0 1-.67 1.93-1.66 2.09-1.25.21-2.34-.76-2.34-1.97V8.17c0-2.09-1.53-3.95-3.61-4.15C7.01 3.79 5 5.66 5 8v7H3.21c-.45 0-.67.54-.35.85l2.79 2.79c.2.2.51.2.71 0l2.79-2.79c.31-.31.09-.85-.36-.85H7V8.12c0-1 .67-1.93 1.66-2.09C9.91 5.82 11 6.79 11 8v6.83c0 2.09 1.53 3.95 3.61 4.15C16.99 19.21 19 17.34 19 15V8h1.79c.45 0 .67-.54.35-.85l-2.79-2.79c-.19-.2-.51-.2-.7-.01z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Random$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {});
    	}
    }

    /* public\images\logout.svg generated by Svelte v3.38.3 */

    function create_fragment$1q(ctx) {
    	let svg;
    	let g0;
    	let path0;
    	let g2;
    	let g1;
    	let path1;
    	let path2;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			path0 = claim_element(g0_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			g0_nodes.forEach(detach);
    			g2 = claim_element(svg_nodes, "g", {}, 1);
    			var g2_nodes = children(g2);
    			g1 = claim_element(g2_nodes, "g", {}, 1);
    			var g1_nodes = children(g1);
    			path1 = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			path2 = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path2).forEach(detach);
    			g1_nodes.forEach(detach);
    			g2_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0,0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M5,5h6c0.55,0,1-0.45,1-1v0c0-0.55-0.45-1-1-1H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h6c0.55,0,1-0.45,1-1v0 c0-0.55-0.45-1-1-1H5V5z");
    			attr(path2, "d", "M20.65,11.65l-2.79-2.79C17.54,8.54,17,8.76,17,9.21V11h-7c-0.55,0-1,0.45-1,1v0c0,0.55,0.45,1,1,1h7v1.79 c0,0.45,0.54,0.67,0.85,0.35l2.79-2.79C20.84,12.16,20.84,11.84,20.65,11.65z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, path0);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, path1);
    			append(g1, path2);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Logout extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {});
    	}
    }

    /* public\images\arrow_left.svg generated by Svelte v3.38.3 */

    function create_fragment$1p(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true, opacity: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M24 0v24H0V0h24z");
    			attr(path0, "fill", "none");
    			attr(path0, "opacity", ".87");
    			attr(path1, "d", "M12.29 8.71L9.7 11.3c-.39.39-.39 1.02 0 1.41l2.59 2.59c.63.63 1.71.18 1.71-.71V9.41c0-.89-1.08-1.33-1.71-.7z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_left extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {});
    	}
    }

    /* public\images\arrow_right.svg generated by Svelte v3.38.3 */

    function create_fragment$1o(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M11.71 15.29l2.59-2.59c.39-.39.39-1.02 0-1.41L11.71 8.7c-.63-.62-1.71-.18-1.71.71v5.17c0 .9 1.08 1.34 1.71.71z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_right extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {});
    	}
    }

    /* public\images\label.svg generated by Svelte v3.38.3 */

    function create_fragment$1n(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84l3.96-5.58c.25-.35.25-.81 0-1.16l-3.96-5.58z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Label extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});
    	}
    }

    /* src\components\sidebar.svelte generated by Svelte v3.38.3 */
    const file$U = "src\\components\\sidebar.svelte";

    // (103:12) <Link to="/" class="site-logo">
    function create_default_slot_13(ctx) {
    	let svgamplelogo;
    	let current;
    	svgamplelogo = new Ample_logo({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgamplelogo.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgamplelogo, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgamplelogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgamplelogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgamplelogo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(103:12) <Link to=\\\"/\\\" class=\\\"site-logo\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:12) {#if $SearchQuery}
    function create_if_block_4$d(ctx) {
    	let button;
    	let svgclose;
    	let current;
    	let mounted;
    	let dispose;
    	svgclose = new Close({ $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(svgclose.$$.fragment);
    			attr_dev(button, "class", "icon close svelte-ljsu9h");
    			add_location(button, file$U, 116, 16, 3976);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(svgclose, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClear*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclose.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclose.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(svgclose);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$d.name,
    		type: "if",
    		source: "(116:12) {#if $SearchQuery}",
    		ctx
    	});

    	return block;
    }

    // (124:16) <Link to="artists" class="site-sidebar__link ">
    function create_default_slot_12$1(ctx) {
    	let svgartist;
    	let t;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t = text(" Artists");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(124:16) <Link to=\\\"artists\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (128:20) {:else}
    function create_else_block_1$b(ctx) {
    	let svgarrowright;
    	let current;
    	svgarrowright = new Arrow_right({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgarrowright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgarrowright, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgarrowright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgarrowright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgarrowright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$b.name,
    		type: "else",
    		source: "(128:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (126:20) {#if artistsDrawerIsVisible}
    function create_if_block_3$h(ctx) {
    	let svgarrowleft;
    	let current;
    	svgarrowleft = new Arrow_left({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgarrowleft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgarrowleft, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgarrowleft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgarrowleft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgarrowleft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$h.name,
    		type: "if",
    		source: "(126:20) {#if artistsDrawerIsVisible}",
    		ctx
    	});

    	return block;
    }

    // (134:16) <Link to="albums" class="site-sidebar__link ">
    function create_default_slot_11$1(ctx) {
    	let svgalbum;
    	let t;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t = text(" Albums");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(134:16) <Link to=\\\"albums\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (138:20) {:else}
    function create_else_block$q(ctx) {
    	let svgarrowright;
    	let current;
    	svgarrowright = new Arrow_right({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgarrowright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgarrowright, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgarrowright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgarrowright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgarrowright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$q.name,
    		type: "else",
    		source: "(138:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (136:20) {#if albumsDrawerIsVisible}
    function create_if_block_2$p(ctx) {
    	let svgarrowleft;
    	let current;
    	svgarrowleft = new Arrow_left({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgarrowleft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgarrowleft, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgarrowleft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgarrowleft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgarrowleft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$p.name,
    		type: "if",
    		source: "(136:20) {#if albumsDrawerIsVisible}",
    		ctx
    	});

    	return block;
    }

    // (143:68) <Link to="playlists" class="site-sidebar__link ">
    function create_default_slot_10$1(ctx) {
    	let svgplaylist;
    	let t;
    	let current;

    	svgplaylist = new Queue_music({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgplaylist.$$.fragment);
    			t = text(" Playlists");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgplaylist, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgplaylist, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(143:68) <Link to=\\\"playlists\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (144:69) <Link to="smartlists" class="site-sidebar__link ">
    function create_default_slot_9$1(ctx) {
    	let svgsmartlist;
    	let t;
    	let current;

    	svgsmartlist = new Smartlist({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgsmartlist.$$.fragment);
    			t = text(" Smartlists");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgsmartlist, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgsmartlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgsmartlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgsmartlist, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(144:69) <Link to=\\\"smartlists\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (145:65) <Link to="genres" class="site-sidebar__link ">
    function create_default_slot_8$1(ctx) {
    	let svggenre;
    	let t;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t = text(" Genres");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(145:65) <Link to=\\\"genres\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (150:68) <Link to="favorites" class="site-sidebar__link ">
    function create_default_slot_7$1(ctx) {
    	let svgfavoritefull;
    	let t;
    	let current;

    	svgfavoritefull = new Favorite_full({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgfavoritefull.$$.fragment);
    			t = text(" Favorites");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgfavoritefull, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgfavoritefull.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgfavoritefull.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgfavoritefull, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(150:68) <Link to=\\\"favorites\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (151:65) <Link to="recent" class="site-sidebar__link ">
    function create_default_slot_6$1(ctx) {
    	let svgrecent;
    	let t;
    	let current;

    	svgrecent = new Recent$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgrecent.$$.fragment);
    			t = text(" Recent");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgrecent, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgrecent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgrecent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgrecent, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(151:65) <Link to=\\\"recent\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (152:65) <Link to="newest" class="site-sidebar__link ">
    function create_default_slot_5$2(ctx) {
    	let svgnew;
    	let t;
    	let current;

    	svgnew = new New({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgnew.$$.fragment);
    			t = text(" Newest");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgnew, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgnew.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgnew.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgnew, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(152:65) <Link to=\\\"newest\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (153:67) <Link to="trending" class="site-sidebar__link ">
    function create_default_slot_4$2(ctx) {
    	let svgtrending;
    	let t;
    	let current;

    	svgtrending = new Trending_up({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgtrending.$$.fragment);
    			t = text(" Trending");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgtrending, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgtrending.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgtrending.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgtrending, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(153:67) <Link to=\\\"trending\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (154:62) <Link to="top" class="site-sidebar__link ">
    function create_default_slot_3$8(ctx) {
    	let svgstarfull;
    	let t;
    	let current;

    	svgstarfull = new Star_full({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgstarfull.$$.fragment);
    			t = text(" Top Rated");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgstarfull, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgstarfull.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgstarfull.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgstarfull, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(154:62) <Link to=\\\"top\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (155:68) <Link to="forgotten" class="site-sidebar__link ">
    function create_default_slot_2$b(ctx) {
    	let svgforgotten;
    	let t;
    	let current;

    	svgforgotten = new Trending_down({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgforgotten.$$.fragment);
    			t = text(" Forgotten");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgforgotten, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgforgotten.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgforgotten.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgforgotten, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(155:68) <Link to=\\\"forgotten\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (156:65) <Link to="random" class="site-sidebar__link ">
    function create_default_slot_1$e(ctx) {
    	let svgrandom;
    	let t;
    	let current;

    	svgrandom = new Random$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgrandom.$$.fragment);
    			t = text(" Random");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgrandom, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgrandom.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgrandom.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgrandom, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(156:65) <Link to=\\\"random\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (157:66) <Link to="unrated" class="site-sidebar__link ">
    function create_default_slot$s(ctx) {
    	let svgstaroutline;
    	let t;
    	let current;

    	svgstaroutline = new Star_outline({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgstaroutline.$$.fragment);
    			t = text(" Unrated");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgstaroutline, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgstaroutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgstaroutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgstaroutline, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(157:66) <Link to=\\\"unrated\\\" class=\\\"site-sidebar__link \\\">",
    		ctx
    	});

    	return block;
    }

    // (163:4) {#if $ShowSearch && $SearchQuery.length >= minimumLength}
    function create_if_block_1$u(ctx) {
    	/*$SearchQuery*/ ctx[5];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$7(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$u.name,
    		type: "if",
    		source: "(163:4) {#if $ShowSearch && $SearchQuery.length >= minimumLength}",
    		ctx
    	});

    	return block;
    }

    // (164:8) {#key $SearchQuery}
    function create_key_block$7(ctx) {
    	let search;
    	let current;
    	search = new Search$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(search.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(search, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(search.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(search.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(search, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$7.name,
    		type: "key",
    		source: "(164:8) {#key $SearchQuery}",
    		ctx
    	});

    	return block;
    }

    // (169:4) {#if initialized}
    function create_if_block$D(ctx) {
    	let sidebardrawer0;
    	let updating_visible;
    	let t;
    	let sidebardrawer1;
    	let updating_visible_1;
    	let current;

    	function sidebardrawer0_visible_binding(value) {
    		/*sidebardrawer0_visible_binding*/ ctx[15](value);
    	}

    	let sidebardrawer0_props = {
    		type: "artist",
    		toggleElement: document.querySelector("#js-drawer-artists")
    	};

    	if (/*artistsDrawerIsVisible*/ ctx[1] !== void 0) {
    		sidebardrawer0_props.visible = /*artistsDrawerIsVisible*/ ctx[1];
    	}

    	sidebardrawer0 = new SidebarDrawer({
    			props: sidebardrawer0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(sidebardrawer0, "visible", sidebardrawer0_visible_binding));

    	function sidebardrawer1_visible_binding(value) {
    		/*sidebardrawer1_visible_binding*/ ctx[16](value);
    	}

    	let sidebardrawer1_props = {
    		type: "album",
    		toggleElement: document.querySelector("#js-drawer-albums")
    	};

    	if (/*albumsDrawerIsVisible*/ ctx[2] !== void 0) {
    		sidebardrawer1_props.visible = /*albumsDrawerIsVisible*/ ctx[2];
    	}

    	sidebardrawer1 = new SidebarDrawer({
    			props: sidebardrawer1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(sidebardrawer1, "visible", sidebardrawer1_visible_binding));

    	const block = {
    		c: function create() {
    			create_component(sidebardrawer0.$$.fragment);
    			t = space();
    			create_component(sidebardrawer1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(sidebardrawer0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(sidebardrawer1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const sidebardrawer0_changes = {};

    			if (!updating_visible && dirty & /*artistsDrawerIsVisible*/ 2) {
    				updating_visible = true;
    				sidebardrawer0_changes.visible = /*artistsDrawerIsVisible*/ ctx[1];
    				add_flush_callback(() => updating_visible = false);
    			}

    			sidebardrawer0.$set(sidebardrawer0_changes);
    			const sidebardrawer1_changes = {};

    			if (!updating_visible_1 && dirty & /*albumsDrawerIsVisible*/ 4) {
    				updating_visible_1 = true;
    				sidebardrawer1_changes.visible = /*albumsDrawerIsVisible*/ ctx[2];
    				add_flush_callback(() => updating_visible_1 = false);
    			}

    			sidebardrawer1.$set(sidebardrawer1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sidebardrawer0.$$.fragment, local);
    			transition_in(sidebardrawer1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sidebardrawer0.$$.fragment, local);
    			transition_out(sidebardrawer1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sidebardrawer0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(sidebardrawer1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(169:4) {#if initialized}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let link0;
    	let t0;
    	let div1;
    	let input;
    	let input_class_value;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let ul0;
    	let li0;
    	let link1;
    	let t5;
    	let button0;
    	let current_block_type_index;
    	let if_block1;
    	let li0_class_value;
    	let t6;
    	let li1;
    	let link2;
    	let t7;
    	let button1;
    	let current_block_type_index_1;
    	let if_block2;
    	let li1_class_value;
    	let t8;
    	let li2;
    	let link3;
    	let li2_class_value;
    	let t9;
    	let li3;
    	let link4;
    	let li3_class_value;
    	let t10;
    	let li4;
    	let link5;
    	let li4_class_value;
    	let t11;
    	let h31;
    	let t13;
    	let ul1;
    	let li5;
    	let link6;
    	let li5_class_value;
    	let t14;
    	let li6;
    	let link7;
    	let li6_class_value;
    	let t15;
    	let li7;
    	let link8;
    	let li7_class_value;
    	let t16;
    	let li8;
    	let link9;
    	let li8_class_value;
    	let t17;
    	let li9;
    	let link10;
    	let li9_class_value;
    	let t18;
    	let li10;
    	let link11;
    	let li10_class_value;
    	let t19;
    	let li11;
    	let link12;
    	let li11_class_value;
    	let t20;
    	let li12;
    	let link13;
    	let li12_class_value;
    	let t21;
    	let button2;
    	let svglogout;
    	let t22;
    	let t23;
    	let t24;
    	let current;
    	let mounted;
    	let dispose;

    	link0 = new Link({
    			props: {
    				to: "/",
    				class: "site-logo",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = /*$SearchQuery*/ ctx[5] && create_if_block_4$d(ctx);

    	link1 = new Link({
    			props: {
    				to: "artists",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_3$h, create_else_block_1$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*artistsDrawerIsVisible*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	link2 = new Link({
    			props: {
    				to: "albums",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2$p, create_else_block$q];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*albumsDrawerIsVisible*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	link3 = new Link({
    			props: {
    				to: "playlists",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link4 = new Link({
    			props: {
    				to: "smartlists",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link5 = new Link({
    			props: {
    				to: "genres",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link6 = new Link({
    			props: {
    				to: "favorites",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link7 = new Link({
    			props: {
    				to: "recent",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link8 = new Link({
    			props: {
    				to: "newest",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link9 = new Link({
    			props: {
    				to: "trending",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link10 = new Link({
    			props: {
    				to: "top",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link11 = new Link({
    			props: {
    				to: "forgotten",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link12 = new Link({
    			props: {
    				to: "random",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link13 = new Link({
    			props: {
    				to: "unrated",
    				class: "site-sidebar__link ",
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	svglogout = new Logout({ $$inline: true });
    	let if_block3 = /*$ShowSearch*/ ctx[4] && /*$SearchQuery*/ ctx[5].length >= /*minimumLength*/ ctx[7] && create_if_block_1$u(ctx);
    	let if_block4 = /*initialized*/ ctx[3] && create_if_block$D(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(link0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			input = element("input");
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Library";
    			t4 = space();
    			ul0 = element("ul");
    			li0 = element("li");
    			create_component(link1.$$.fragment);
    			t5 = space();
    			button0 = element("button");
    			if_block1.c();
    			t6 = space();
    			li1 = element("li");
    			create_component(link2.$$.fragment);
    			t7 = space();
    			button1 = element("button");
    			if_block2.c();
    			t8 = space();
    			li2 = element("li");
    			create_component(link3.$$.fragment);
    			t9 = space();
    			li3 = element("li");
    			create_component(link4.$$.fragment);
    			t10 = space();
    			li4 = element("li");
    			create_component(link5.$$.fragment);
    			t11 = space();
    			h31 = element("h3");
    			h31.textContent = "Insights";
    			t13 = space();
    			ul1 = element("ul");
    			li5 = element("li");
    			create_component(link6.$$.fragment);
    			t14 = space();
    			li6 = element("li");
    			create_component(link7.$$.fragment);
    			t15 = space();
    			li7 = element("li");
    			create_component(link8.$$.fragment);
    			t16 = space();
    			li8 = element("li");
    			create_component(link9.$$.fragment);
    			t17 = space();
    			li9 = element("li");
    			create_component(link10.$$.fragment);
    			t18 = space();
    			li10 = element("li");
    			create_component(link11.$$.fragment);
    			t19 = space();
    			li11 = element("li");
    			create_component(link12.$$.fragment);
    			t20 = space();
    			li12 = element("li");
    			create_component(link13.$$.fragment);
    			t21 = space();
    			button2 = element("button");
    			create_component(svglogout.$$.fragment);
    			t22 = text(" Log out");
    			t23 = space();
    			if (if_block3) if_block3.c();
    			t24 = space();
    			if (if_block4) if_block4.c();
    			attr_dev(div0, "class", "site-logo-container");
    			add_location(div0, file$U, 101, 8, 3409);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Search");

    			attr_dev(input, "class", input_class_value = "site-search " + (/*$ShowSearch*/ ctx[4] && /*$SearchQuery*/ ctx[5]
    			? "active"
    			: "") + " svelte-ljsu9h");

    			input.value = /*$SearchQuery*/ ctx[5];
    			add_location(input, file$U, 106, 12, 3582);
    			attr_dev(div1, "class", "search-container svelte-ljsu9h");
    			add_location(div1, file$U, 105, 8, 3538);
    			attr_dev(h30, "class", "svelte-ljsu9h");
    			add_location(h30, file$U, 120, 8, 4094);
    			attr_dev(button0, "id", "js-drawer-artists");
    			attr_dev(button0, "class", "drawer-toggle icon svelte-ljsu9h");
    			toggle_class(button0, "open", /*artistsDrawerIsVisible*/ ctx[1]);
    			add_location(button0, file$U, 124, 16, 4317);
    			attr_dev(li0, "class", li0_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "artists" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li0, file$U, 122, 12, 4138);
    			attr_dev(button1, "id", "js-drawer-albums");
    			attr_dev(button1, "class", "drawer-toggle icon svelte-ljsu9h");
    			toggle_class(button1, "open", /*albumsDrawerIsVisible*/ ctx[2]);
    			add_location(button1, file$U, 134, 16, 4868);
    			attr_dev(li1, "class", li1_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "albums" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li1, file$U, 132, 12, 4693);
    			attr_dev(li2, "class", li2_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "playlists" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li2, file$U, 142, 12, 5240);
    			attr_dev(li3, "class", li3_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "smartlists" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li3, file$U, 143, 12, 5410);
    			attr_dev(li4, "class", li4_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "genres" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li4, file$U, 144, 12, 5584);
    			attr_dev(ul0, "class", "svelte-ljsu9h");
    			add_location(ul0, file$U, 121, 8, 4120);
    			attr_dev(h31, "class", "svelte-ljsu9h");
    			add_location(h31, file$U, 147, 8, 5755);
    			attr_dev(li5, "class", li5_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "favorites" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li5, file$U, 149, 12, 5800);
    			attr_dev(li6, "class", li6_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "recent" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li6, file$U, 150, 12, 5974);
    			attr_dev(li7, "class", li7_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "newest" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li7, file$U, 151, 12, 6133);
    			attr_dev(li8, "class", li8_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "trending" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li8, file$U, 152, 12, 6289);
    			attr_dev(li9, "class", li9_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "top" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li9, file$U, 153, 12, 6456);
    			attr_dev(li10, "class", li10_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "forgotten" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li10, file$U, 154, 12, 6614);
    			attr_dev(li11, "class", li11_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "random" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li11, file$U, 155, 12, 6785);
    			attr_dev(li12, "class", li12_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "unrated" ? "current" : "") + " svelte-ljsu9h"));
    			add_location(li12, file$U, 156, 12, 6944);
    			attr_dev(ul1, "class", "svelte-ljsu9h");
    			add_location(ul1, file$U, 148, 8, 5782);
    			attr_dev(button2, "class", "logout with-icon svelte-ljsu9h");
    			add_location(button2, file$U, 159, 8, 7124);
    			attr_dev(div2, "class", "site-sidebar-inner svelte-ljsu9h");
    			add_location(div2, file$U, 100, 4, 3367);
    			attr_dev(div3, "class", "site-sidebar svelte-ljsu9h");
    			add_location(div3, file$U, 99, 0, 3335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(link0, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div2, t2);
    			append_dev(div2, h30);
    			append_dev(div2, t4);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			mount_component(link1, li0, null);
    			append_dev(li0, t5);
    			append_dev(li0, button0);
    			if_blocks[current_block_type_index].m(button0, null);
    			append_dev(ul0, t6);
    			append_dev(ul0, li1);
    			mount_component(link2, li1, null);
    			append_dev(li1, t7);
    			append_dev(li1, button1);
    			if_blocks_1[current_block_type_index_1].m(button1, null);
    			append_dev(ul0, t8);
    			append_dev(ul0, li2);
    			mount_component(link3, li2, null);
    			append_dev(ul0, t9);
    			append_dev(ul0, li3);
    			mount_component(link4, li3, null);
    			append_dev(ul0, t10);
    			append_dev(ul0, li4);
    			mount_component(link5, li4, null);
    			append_dev(div2, t11);
    			append_dev(div2, h31);
    			append_dev(div2, t13);
    			append_dev(div2, ul1);
    			append_dev(ul1, li5);
    			mount_component(link6, li5, null);
    			append_dev(ul1, t14);
    			append_dev(ul1, li6);
    			mount_component(link7, li6, null);
    			append_dev(ul1, t15);
    			append_dev(ul1, li7);
    			mount_component(link8, li7, null);
    			append_dev(ul1, t16);
    			append_dev(ul1, li8);
    			mount_component(link9, li8, null);
    			append_dev(ul1, t17);
    			append_dev(ul1, li9);
    			mount_component(link10, li9, null);
    			append_dev(ul1, t18);
    			append_dev(ul1, li10);
    			mount_component(link11, li10, null);
    			append_dev(ul1, t19);
    			append_dev(ul1, li11);
    			mount_component(link12, li11, null);
    			append_dev(ul1, t20);
    			append_dev(ul1, li12);
    			mount_component(link13, li12, null);
    			append_dev(div2, t21);
    			append_dev(div2, button2);
    			mount_component(svglogout, button2, null);
    			append_dev(button2, t22);
    			append_dev(div3, t23);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div3, t24);
    			if (if_block4) if_block4.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "focus", /*handleFocus*/ ctx[8], false, false, false),
    					listen_dev(input, "paste", /*handleInputChange*/ ctx[9], false, false, false),
    					listen_dev(input, "keyup", /*handleInputChange*/ ctx[9], false, false, false),
    					listen_dev(button0, "click", /*toggleArtistsDrawer*/ ctx[11], false, false, false),
    					listen_dev(button1, "click", /*toggleAlbumsDrawer*/ ctx[12], false, false, false),
    					listen_dev(button2, "click", /*handleLogOut*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);

    			if (!current || dirty & /*$ShowSearch, $SearchQuery*/ 48 && input_class_value !== (input_class_value = "site-search " + (/*$ShowSearch*/ ctx[4] && /*$SearchQuery*/ ctx[5]
    			? "active"
    			: "") + " svelte-ljsu9h")) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (!current || dirty & /*$SearchQuery*/ 32 && input.value !== /*$SearchQuery*/ ctx[5]) {
    				prop_dev(input, "value", /*$SearchQuery*/ ctx[5]);
    			}

    			if (/*$SearchQuery*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$SearchQuery*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$d(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(button0, null);
    			}

    			if (dirty & /*artistsDrawerIsVisible*/ 2) {
    				toggle_class(button0, "open", /*artistsDrawerIsVisible*/ ctx[1]);
    			}

    			if (!current || dirty & /*basePath*/ 1 && li0_class_value !== (li0_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "artists" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li0, "class", li0_class_value);
    			}

    			const link2_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(button1, null);
    			}

    			if (dirty & /*albumsDrawerIsVisible*/ 4) {
    				toggle_class(button1, "open", /*albumsDrawerIsVisible*/ ctx[2]);
    			}

    			if (!current || dirty & /*basePath*/ 1 && li1_class_value !== (li1_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "albums" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li1, "class", li1_class_value);
    			}

    			const link3_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);

    			if (!current || dirty & /*basePath*/ 1 && li2_class_value !== (li2_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "playlists" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li2, "class", li2_class_value);
    			}

    			const link4_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link4_changes.$$scope = { dirty, ctx };
    			}

    			link4.$set(link4_changes);

    			if (!current || dirty & /*basePath*/ 1 && li3_class_value !== (li3_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "smartlists" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li3, "class", li3_class_value);
    			}

    			const link5_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link5_changes.$$scope = { dirty, ctx };
    			}

    			link5.$set(link5_changes);

    			if (!current || dirty & /*basePath*/ 1 && li4_class_value !== (li4_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "genres" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li4, "class", li4_class_value);
    			}

    			const link6_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link6_changes.$$scope = { dirty, ctx };
    			}

    			link6.$set(link6_changes);

    			if (!current || dirty & /*basePath*/ 1 && li5_class_value !== (li5_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "favorites" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li5, "class", li5_class_value);
    			}

    			const link7_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link7_changes.$$scope = { dirty, ctx };
    			}

    			link7.$set(link7_changes);

    			if (!current || dirty & /*basePath*/ 1 && li6_class_value !== (li6_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "recent" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li6, "class", li6_class_value);
    			}

    			const link8_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link8_changes.$$scope = { dirty, ctx };
    			}

    			link8.$set(link8_changes);

    			if (!current || dirty & /*basePath*/ 1 && li7_class_value !== (li7_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "newest" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li7, "class", li7_class_value);
    			}

    			const link9_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link9_changes.$$scope = { dirty, ctx };
    			}

    			link9.$set(link9_changes);

    			if (!current || dirty & /*basePath*/ 1 && li8_class_value !== (li8_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "trending" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li8, "class", li8_class_value);
    			}

    			const link10_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link10_changes.$$scope = { dirty, ctx };
    			}

    			link10.$set(link10_changes);

    			if (!current || dirty & /*basePath*/ 1 && li9_class_value !== (li9_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "top" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li9, "class", li9_class_value);
    			}

    			const link11_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link11_changes.$$scope = { dirty, ctx };
    			}

    			link11.$set(link11_changes);

    			if (!current || dirty & /*basePath*/ 1 && li10_class_value !== (li10_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "forgotten" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li10, "class", li10_class_value);
    			}

    			const link12_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link12_changes.$$scope = { dirty, ctx };
    			}

    			link12.$set(link12_changes);

    			if (!current || dirty & /*basePath*/ 1 && li11_class_value !== (li11_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "random" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li11, "class", li11_class_value);
    			}

    			const link13_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				link13_changes.$$scope = { dirty, ctx };
    			}

    			link13.$set(link13_changes);

    			if (!current || dirty & /*basePath*/ 1 && li12_class_value !== (li12_class_value = "" + (null_to_empty(/*basePath*/ ctx[0] === "unrated" ? "current" : "") + " svelte-ljsu9h"))) {
    				attr_dev(li12, "class", li12_class_value);
    			}

    			if (/*$ShowSearch*/ ctx[4] && /*$SearchQuery*/ ctx[5].length >= /*minimumLength*/ ctx[7]) {
    				if (if_block3) {
    					if (dirty & /*$ShowSearch, $SearchQuery*/ 48) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$u(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div3, t24);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*initialized*/ ctx[3]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*initialized*/ 8) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block$D(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div3, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(link1.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(link2.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(link3.$$.fragment, local);
    			transition_in(link4.$$.fragment, local);
    			transition_in(link5.$$.fragment, local);
    			transition_in(link6.$$.fragment, local);
    			transition_in(link7.$$.fragment, local);
    			transition_in(link8.$$.fragment, local);
    			transition_in(link9.$$.fragment, local);
    			transition_in(link10.$$.fragment, local);
    			transition_in(link11.$$.fragment, local);
    			transition_in(link12.$$.fragment, local);
    			transition_in(link13.$$.fragment, local);
    			transition_in(svglogout.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(link1.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(link2.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(link3.$$.fragment, local);
    			transition_out(link4.$$.fragment, local);
    			transition_out(link5.$$.fragment, local);
    			transition_out(link6.$$.fragment, local);
    			transition_out(link7.$$.fragment, local);
    			transition_out(link8.$$.fragment, local);
    			transition_out(link9.$$.fragment, local);
    			transition_out(link10.$$.fragment, local);
    			transition_out(link11.$$.fragment, local);
    			transition_out(link12.$$.fragment, local);
    			transition_out(link13.$$.fragment, local);
    			transition_out(svglogout.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(link0);
    			if (if_block0) if_block0.d();
    			destroy_component(link1);
    			if_blocks[current_block_type_index].d();
    			destroy_component(link2);
    			if_blocks_1[current_block_type_index_1].d();
    			destroy_component(link3);
    			destroy_component(link4);
    			destroy_component(link5);
    			destroy_component(link6);
    			destroy_component(link7);
    			destroy_component(link8);
    			destroy_component(link9);
    			destroy_component(link10);
    			destroy_component(link11);
    			destroy_component(link12);
    			destroy_component(link13);
    			destroy_component(svglogout);
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $ShowSearch;
    	let $SearchQuery;
    	validate_store(ShowSearch, "ShowSearch");
    	component_subscribe($$self, ShowSearch, $$value => $$invalidate(4, $ShowSearch = $$value));
    	validate_store(SearchQuery, "SearchQuery");
    	component_subscribe($$self, SearchQuery, $$value => $$invalidate(5, $SearchQuery = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Sidebar", slots, []);
    	const { activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(14, $activeRoute = value));
    	let basePath = "";
    	let timeout;
    	let minimumLength = 3;
    	let artistsDrawerIsVisible = false;
    	let albumsDrawerIsVisible = false;
    	let initialized = false;

    	function handleFocus() {
    		ShowSearch.set(true);
    	}

    	function handleInputChange(event) {
    		clearTimeout(timeout);

    		timeout = setTimeout(
    			function () {
    				let chars = event.target.value;

    				if (chars.length >= 3) {
    					ShowSearch.set(true);
    					SearchQuery.set(chars);
    				} else {
    					ShowSearch.set(false);
    				}
    			},
    			600
    		);
    	}

    	function handleClear() {
    		SearchQuery.set("");
    		ShowSearch.set(false);
    	}

    	function toggleArtistsDrawer() {
    		$$invalidate(1, artistsDrawerIsVisible = !artistsDrawerIsVisible);
    	}

    	function toggleAlbumsDrawer() {
    		$$invalidate(2, albumsDrawerIsVisible = !albumsDrawerIsVisible);
    	}

    	function handleLogOut() {
    		logout();
    	}

    	onMount(() => {
    		// wait for sidebar to be ready before loading the sidebardrawer components
    		$$invalidate(3, initialized = true);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sidebar> was created with unknown prop '${key}'`);
    	});

    	function sidebardrawer0_visible_binding(value) {
    		artistsDrawerIsVisible = value;
    		$$invalidate(1, artistsDrawerIsVisible);
    	}

    	function sidebardrawer1_visible_binding(value) {
    		albumsDrawerIsVisible = value;
    		$$invalidate(2, albumsDrawerIsVisible);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		getContext,
    		ROUTER,
    		Link,
    		SearchQuery,
    		ShowSearch,
    		logout,
    		Search: Search$1,
    		SidebarDrawer,
    		SVGAmpleLogo: Ample_logo,
    		SVGClose: Close,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGPlaylist: Queue_music,
    		SVGSmartlist: Smartlist,
    		SVGStarFull: Star_full,
    		SVGStarOutline: Star_outline,
    		SVGFavoriteFull: Favorite_full,
    		SVGRecent: Recent$1,
    		SVGNew: New,
    		SVGTrending: Trending_up,
    		SVGForgotten: Trending_down,
    		SVGRandom: Random$1,
    		SVGLogout: Logout,
    		SVGArrowLeft: Arrow_left,
    		SVGArrowRight: Arrow_right,
    		SVGGenre: Label,
    		activeRoute,
    		basePath,
    		timeout,
    		minimumLength,
    		artistsDrawerIsVisible,
    		albumsDrawerIsVisible,
    		initialized,
    		handleFocus,
    		handleInputChange,
    		handleClear,
    		toggleArtistsDrawer,
    		toggleAlbumsDrawer,
    		handleLogOut,
    		$activeRoute,
    		$ShowSearch,
    		$SearchQuery
    	});

    	$$self.$inject_state = $$props => {
    		if ("basePath" in $$props) $$invalidate(0, basePath = $$props.basePath);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("minimumLength" in $$props) $$invalidate(7, minimumLength = $$props.minimumLength);
    		if ("artistsDrawerIsVisible" in $$props) $$invalidate(1, artistsDrawerIsVisible = $$props.artistsDrawerIsVisible);
    		if ("albumsDrawerIsVisible" in $$props) $$invalidate(2, albumsDrawerIsVisible = $$props.albumsDrawerIsVisible);
    		if ("initialized" in $$props) $$invalidate(3, initialized = $$props.initialized);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeRoute*/ 16384) {
    			{
    				if ($activeRoute !== null) {
    					$$invalidate(0, basePath = $activeRoute.route._path.split(/\//)[0]);

    					// remove customColors class if not on our special pages
    					// their onMount events will add it back in
    					switch ($activeRoute.route._path) {
    						case "albums/:id":
    						case "artists/:id":
    							break;
    						default:
    							document.body.classList.remove("useCustomColors");
    							break;
    					}
    				}
    			}
    		}
    	};

    	return [
    		basePath,
    		artistsDrawerIsVisible,
    		albumsDrawerIsVisible,
    		initialized,
    		$ShowSearch,
    		$SearchQuery,
    		activeRoute,
    		minimumLength,
    		handleFocus,
    		handleInputChange,
    		handleClear,
    		toggleArtistsDrawer,
    		toggleAlbumsDrawer,
    		handleLogOut,
    		$activeRoute,
    		sidebardrawer0_visible_binding,
    		sidebardrawer1_visible_binding
    	];
    }

    class Sidebar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sidebar",
    			options,
    			id: create_fragment$1m.name
    		});
    	}
    }

    /* public\images\favorite_outline.svg generated by Svelte v3.38.3 */

    function create_fragment$1l(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M19.66 3.99c-2.64-1.8-5.9-.96-7.66 1.1-1.76-2.06-5.02-2.91-7.66-1.1-1.4.96-2.28 2.58-2.34 4.29-.14 3.88 3.3 6.99 8.55 11.76l.1.09c.76.69 1.93.69 2.69-.01l.11-.1c5.25-4.76 8.68-7.87 8.55-11.75-.06-1.7-.94-3.32-2.34-4.28zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Favorite_outline extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});
    	}
    }

    /* public\images\remove_circle_outline.svg generated by Svelte v3.38.3 */

    function create_fragment$1k(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M7 12c0 .55.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1zm5-10C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Remove_circle_outline extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {});
    	}
    }

    let serverURL_value$3 = get_store_value(serverURL);

    /**
     * Make API request for library data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchLibraryData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.success) ? data.success : data;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Rate an object
     * @param {string} type
     * @param {number} id
     * @param {number} rating
     * @returns {Promise<*>}
     */
    const setRating = (type, id, rating) => {
        let queryURL = serverURL_value$3 + "/server/json.server.php?action=rate";
        queryURL += "&type=" + type + "&id=" + id + "&rating=" + rating;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "setRating");
        return fetchLibraryData(queryURL);
    };

    /**
     * Flag/favourite an object
     * @param {string} type
     * @param {number} id
     * @param {boolean} flag
     * @returns {Promise<*>}
     */
    const setFlag = (type, id, flag) => {
        let queryURL = serverURL_value$3 + "/server/json.server.php?action=flag";
        queryURL += "&type=" + type + "&id=" + id + "&flag=" + flag;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "setFlag");
        return fetchLibraryData(queryURL);
    };

    /* src\components\rating.svelte generated by Svelte v3.38.3 */
    const file$T = "src\\components\\rating.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (93:16) {:else}
    function create_else_block_1$a(ctx) {
    	let svgstaroutline;
    	let current;
    	svgstaroutline = new Star_outline({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgstaroutline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgstaroutline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgstaroutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgstaroutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgstaroutline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$a.name,
    		type: "else",
    		source: "(93:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:16) {#if rating > i}
    function create_if_block_2$o(ctx) {
    	let svgstarfull;
    	let current;
    	svgstarfull = new Star_full({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgstarfull.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgstarfull, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgstarfull.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgstarfull.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgstarfull, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$o.name,
    		type: "if",
    		source: "(91:16) {#if rating > i}",
    		ctx
    	});

    	return block;
    }

    // (89:8) {#each values as ratingValue, i}
    function create_each_block$f(ctx) {
    	let li;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let li_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_2$o, create_else_block_1$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*rating*/ ctx[0] > /*i*/ ctx[14]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			if_block.c();
    			t = space();
    			attr_dev(li, "data-rating", /*ratingValue*/ ctx[12]);

    			attr_dev(li, "class", li_class_value = "c-rating__star " + (/*rating*/ ctx[0] === /*ratingValue*/ ctx[12]
    			? "current"
    			: "") + " svelte-1c2f638");

    			add_location(li, file$T, 89, 12, 2573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			if_blocks[current_block_type_index].m(li, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*handleRating*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(li, t);
    			}

    			if (!current || dirty & /*rating*/ 1 && li_class_value !== (li_class_value = "c-rating__star " + (/*rating*/ ctx[0] === /*ratingValue*/ ctx[12]
    			? "current"
    			: "") + " svelte-1c2f638")) {
    				attr_dev(li, "class", li_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(89:8) {#each values as ratingValue, i}",
    		ctx
    	});

    	return block;
    }

    // (100:4) {#if averageRating && showAverageRatings}
    function create_if_block_1$t(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("(");
    			t1 = text(/*averageRating*/ ctx[2]);
    			t2 = text(")");
    			attr_dev(span, "class", "c-rating__average svelte-1c2f638");
    			attr_dev(span, "title", "Average from all users");
    			add_location(span, file$T, 100, 8, 2959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*averageRating*/ 4) set_data_dev(t1, /*averageRating*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$t.name,
    		type: "if",
    		source: "(100:4) {#if averageRating && showAverageRatings}",
    		ctx
    	});

    	return block;
    }

    // (109:8) {:else}
    function create_else_block$p(ctx) {
    	let svgfavoriteoutline;
    	let current;
    	svgfavoriteoutline = new Favorite_outline({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgfavoriteoutline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgfavoriteoutline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgfavoriteoutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgfavoriteoutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgfavoriteoutline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$p.name,
    		type: "else",
    		source: "(109:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (107:8) {#if flag}
    function create_if_block$C(ctx) {
    	let svgfavoritefull;
    	let current;
    	svgfavoritefull = new Favorite_full({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgfavoritefull.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgfavoritefull, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgfavoritefull.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgfavoritefull.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgfavoritefull, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(107:8) {#if flag}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let div;
    	let span0;
    	let svgclear;
    	let t0;
    	let ul;
    	let t1;
    	let t2;
    	let span1;
    	let current_block_type_index;
    	let if_block1;
    	let span1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	svgclear = new Remove_circle_outline({ $$inline: true });
    	let each_value = /*values*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block0 = /*averageRating*/ ctx[2] && /*showAverageRatings*/ ctx[3] && create_if_block_1$t(ctx);
    	const if_block_creators = [create_if_block$C, create_else_block$p];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*flag*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			create_component(svgclear.$$.fragment);
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			span1 = element("span");
    			if_block1.c();
    			attr_dev(span0, "class", "c-rating__clear svelte-1c2f638");
    			attr_dev(span0, "data-rating", "0");
    			add_location(span0, file$T, 83, 4, 2376);
    			attr_dev(ul, "class", "c-rating__stars svelte-1c2f638");
    			add_location(ul, file$T, 87, 4, 2489);
    			attr_dev(span1, "class", span1_class_value = "c-rating__flag " + (/*flag*/ ctx[1] ? "flagged" : "") + " svelte-1c2f638");
    			add_location(span1, file$T, 105, 4, 3089);
    			attr_dev(div, "class", "c-rating svelte-1c2f638");
    			add_location(div, file$T, 82, 0, 2348);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			mount_component(svgclear, span0, null);
    			append_dev(div, t0);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div, t1);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t2);
    			append_dev(div, span1);
    			if_blocks[current_block_type_index].m(span1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span0, "click", /*handleRating*/ ctx[5], false, false, false),
    					listen_dev(span1, "click", /*handleFlag*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*values, rating, handleRating*/ 49) {
    				each_value = /*values*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*averageRating*/ ctx[2] && /*showAverageRatings*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$t(ctx);
    					if_block0.c();
    					if_block0.m(div, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(span1, null);
    			}

    			if (!current || dirty & /*flag*/ 2 && span1_class_value !== (span1_class_value = "c-rating__flag " + (/*flag*/ ctx[1] ? "flagged" : "") + " svelte-1c2f638")) {
    				attr_dev(span1, "class", span1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclear.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclear.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgclear);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let recentRating = writable({ type: null, id: null, rating: null });

    // shared across component instances
    let recentFlag = writable({ type: null, id: null, flag: null });

    function instance$1j($$self, $$props, $$invalidate) {
    	let $recentRating;
    	let $recentFlag;
    	validate_store(recentRating, "recentRating");
    	component_subscribe($$self, recentRating, $$value => $$invalidate(9, $recentRating = $$value));
    	validate_store(recentFlag, "recentFlag");
    	component_subscribe($$self, recentFlag, $$value => $$invalidate(10, $recentFlag = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Rating", slots, []);
    	let { id = null } = $$props;
    	let { type = null } = $$props;
    	let { rating = null } = $$props;
    	let { flag = null } = $$props;
    	let { averageRating = null } = $$props;
    	let showAverageRatings = true;
    	const values = [1, 2, 3, 4, 5];
    	let update = Promise.resolve([]);

    	function handleRating() {
    		let newRating = parseInt(this.dataset.rating);

    		update = setRating(type, id, newRating).then(result => {
    			if (!result.error) {
    				$$invalidate(0, rating = newRating);
    				recentRating.set({ type, id, rating: newRating });
    			}
    		});
    	}

    	function handleFlag() {
    		let newFlag = flag ? 0 : 1;

    		update = setFlag(type, id, newFlag).then(result => {
    			if (!result.error) {
    				$$invalidate(1, flag = newFlag);
    				recentFlag.set({ type, id, flag: newFlag });
    			}
    		});
    	}

    	const writable_props = ["id", "type", "rating", "flag", "averageRating"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Rating> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("type" in $$props) $$invalidate(8, type = $$props.type);
    		if ("rating" in $$props) $$invalidate(0, rating = $$props.rating);
    		if ("flag" in $$props) $$invalidate(1, flag = $$props.flag);
    		if ("averageRating" in $$props) $$invalidate(2, averageRating = $$props.averageRating);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		SVGClear: Remove_circle_outline,
    		SVGStarFull: Star_full,
    		SVGStarOutline: Star_outline,
    		SVGFavoriteFull: Favorite_full,
    		SVGFavoriteOutline: Favorite_outline,
    		recentRating,
    		recentFlag,
    		setRating,
    		setFlag,
    		id,
    		type,
    		rating,
    		flag,
    		averageRating,
    		showAverageRatings,
    		values,
    		update,
    		handleRating,
    		handleFlag,
    		$recentRating,
    		$recentFlag
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("type" in $$props) $$invalidate(8, type = $$props.type);
    		if ("rating" in $$props) $$invalidate(0, rating = $$props.rating);
    		if ("flag" in $$props) $$invalidate(1, flag = $$props.flag);
    		if ("averageRating" in $$props) $$invalidate(2, averageRating = $$props.averageRating);
    		if ("showAverageRatings" in $$props) $$invalidate(3, showAverageRatings = $$props.showAverageRatings);
    		if ("update" in $$props) update = $$props.update;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$recentRating, type, id, rating, $recentFlag, flag*/ 1923) {
    			{
    				if ($recentRating.type === type && $recentRating.id === id && $recentRating.rating !== rating) {
    					$$invalidate(0, rating = $recentRating.rating);
    				}

    				if ($recentFlag.type === type && $recentFlag.id === id && $recentFlag.flag !== flag) {
    					$$invalidate(1, flag = $recentFlag.flag);
    				}
    			}
    		}
    	};

    	return [
    		rating,
    		flag,
    		averageRating,
    		showAverageRatings,
    		values,
    		handleRating,
    		handleFlag,
    		id,
    		type,
    		$recentRating,
    		$recentFlag
    	];
    }

    class Rating extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
    			id: 7,
    			type: 8,
    			rating: 0,
    			flag: 1,
    			averageRating: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rating",
    			options,
    			id: create_fragment$1j.name
    		});
    	}

    	get id() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rating() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rating(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flag() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flag(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get averageRating() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set averageRating(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\player\player_seekBar.svelte generated by Svelte v3.38.3 */
    const file$S = "src\\components\\player\\player_seekBar.svelte";

    function create_fragment$1i(ctx) {
    	let div;
    	let span;
    	let span_data_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "site-player__progress svelte-1maobjf");
    			attr_dev(span, "data-value", span_data_value_value = formatSongLength(/*currentTime*/ ctx[1]));
    			set_style(span, "width", /*seekWidth*/ ctx[0] + "%");
    			add_location(span, file$S, 58, 4, 1960);
    			attr_dev(div, "class", "site-player__seekBar svelte-1maobjf");
    			add_location(div, file$S, 57, 0, 1833);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*handleSeek*/ ctx[4], false, false, false),
    					listen_dev(div, "mousedown", /*handleSeekMouseDown*/ ctx[2], false, false, false),
    					listen_dev(div, "mousemove", /*handleSeekDrag*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*currentTime*/ 2 && span_data_value_value !== (span_data_value_value = formatSongLength(/*currentTime*/ ctx[1]))) {
    				attr_dev(span, "data-value", span_data_value_value);
    			}

    			if (dirty & /*seekWidth*/ 1) {
    				set_style(span, "width", /*seekWidth*/ ctx[0] + "%");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let $MediaPlayer;
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(8, $MediaPlayer = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player_seekBar", slots, []);
    	let seekWidth;
    	let duration;
    	let currentTime;
    	let mouseDown = false;
    	let progressSlider;

    	function updateProgress() {
    		$$invalidate(0, seekWidth = $MediaPlayer.wavesurfer
    		? $MediaPlayer.wavesurfer.getCurrentTime() / $MediaPlayer.wavesurfer.getDuration() * 100
    		: 0);

    		duration = $MediaPlayer.wavesurfer
    		? $MediaPlayer.wavesurfer.getDuration()
    		: 0;

    		$$invalidate(1, currentTime = $MediaPlayer.wavesurfer
    		? $MediaPlayer.wavesurfer.getCurrentTime()
    		: 0);

    		requestAnimationFrame(updateProgress);
    	}

    	function handleSeekMouseDown(event) {
    		mouseDown = true;
    		document.addEventListener("mouseup", handleSeekMouseUp);
    	}

    	function handleSeekMouseUp(event) {
    		mouseDown = false;
    		document.removeEventListener("mouseup", handleSeekMouseUp);
    		progressSlider.classList.remove("dragging");
    	}

    	function handleSeekDrag(event) {
    		if (mouseDown) {
    			progressSlider.classList.add("dragging");

    			requestAnimationFrame(function () {
    				handleSeek(event);
    			});
    		}
    	}

    	function handleSeek(event) {
    		let seekElementWidth = event.target.offsetWidth;
    		let seekClickLocation = event.clientX - event.target.getBoundingClientRect().left;

    		if ($MediaPlayer.wavesurfer) {
    			let seekFraction = seekClickLocation / seekElementWidth;
    			$MediaPlayer.wavesurfer.seekTo(seekFraction);
    		}
    	}

    	onMount(() => {
    		progressSlider = document.querySelector(".site-player__seekBar");
    		requestAnimationFrame(updateProgress);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player_seekBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		MediaPlayer,
    		formatSongLength,
    		seekWidth,
    		duration,
    		currentTime,
    		mouseDown,
    		progressSlider,
    		updateProgress,
    		handleSeekMouseDown,
    		handleSeekMouseUp,
    		handleSeekDrag,
    		handleSeek,
    		$MediaPlayer
    	});

    	$$self.$inject_state = $$props => {
    		if ("seekWidth" in $$props) $$invalidate(0, seekWidth = $$props.seekWidth);
    		if ("duration" in $$props) duration = $$props.duration;
    		if ("currentTime" in $$props) $$invalidate(1, currentTime = $$props.currentTime);
    		if ("mouseDown" in $$props) mouseDown = $$props.mouseDown;
    		if ("progressSlider" in $$props) progressSlider = $$props.progressSlider;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [seekWidth, currentTime, handleSeekMouseDown, handleSeekDrag, handleSeek];
    }

    class Player_seekBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player_seekBar",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* public\images\year.svg generated by Svelte v3.38.3 */

    function create_fragment$1h(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M20 3h-1V2c0-.55-.45-1-1-1s-1 .45-1 1v1H7V2c0-.55-.45-1-1-1s-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 18H5c-.55 0-1-.45-1-1V8h16v12c0 .55-.45 1-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Year extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});
    	}
    }

    /* src\components\player\player_nowPlaying.svelte generated by Svelte v3.38.3 */
    const file$R = "src\\components\\player\\player_nowPlaying.svelte";

    // (12:4) {#if $CurrentSong}
    function create_if_block$B(ctx) {
    	let img;
    	let img_src_value;
    	let t0;
    	let div3;
    	let div0;
    	let t1_value = /*$CurrentSong*/ ctx[0].title + "";
    	let t1;
    	let div0_title_value;
    	let t2;
    	let div1;
    	let link0;
    	let div1_title_value;
    	let t3;
    	let div2;
    	let t4;
    	let link1;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "artists/" + /*$CurrentSong*/ ctx[0].artist.id,
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$CurrentSong*/ ctx[0].year > 0 && create_if_block_1$s(ctx);

    	link1 = new Link({
    			props: {
    				to: "albums/" + /*$CurrentSong*/ ctx[0].album.id,
    				title: /*$CurrentSong*/ ctx[0].album.name,
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			img = element("img");
    			t0 = space();
    			div3 = element("div");
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			create_component(link1.$$.fragment);
    			attr_dev(img, "class", "nowPlayingArtwork svelte-1mv8eze");
    			if (img.src !== (img_src_value = "" + (/*$CurrentSong*/ ctx[0].art + "&thumb=22"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$R, 12, 8, 370);
    			attr_dev(div0, "class", "title svelte-1mv8eze");
    			attr_dev(div0, "title", div0_title_value = /*$CurrentSong*/ ctx[0].title);
    			add_location(div0, file$R, 14, 12, 489);
    			attr_dev(div1, "class", "artist svelte-1mv8eze");
    			attr_dev(div1, "title", div1_title_value = /*$CurrentSong*/ ctx[0].artist.name);
    			add_location(div1, file$R, 15, 12, 577);
    			attr_dev(div2, "class", "album svelte-1mv8eze");
    			add_location(div2, file$R, 16, 12, 757);
    			attr_dev(div3, "class", "details svelte-1mv8eze");
    			add_location(div3, file$R, 13, 8, 454);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			mount_component(link0, div1, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t4);
    			mount_component(link1, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*$CurrentSong*/ 1 && img.src !== (img_src_value = "" + (/*$CurrentSong*/ ctx[0].art + "&thumb=22"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*$CurrentSong*/ 1) && t1_value !== (t1_value = /*$CurrentSong*/ ctx[0].title + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*$CurrentSong*/ 1 && div0_title_value !== (div0_title_value = /*$CurrentSong*/ ctx[0].title)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			const link0_changes = {};
    			if (dirty & /*$CurrentSong*/ 1) link0_changes.to = "artists/" + /*$CurrentSong*/ ctx[0].artist.id;

    			if (dirty & /*$$scope, $CurrentSong*/ 3) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);

    			if (!current || dirty & /*$CurrentSong*/ 1 && div1_title_value !== (div1_title_value = /*$CurrentSong*/ ctx[0].artist.name)) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			if (/*$CurrentSong*/ ctx[0].year > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$CurrentSong*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, t4);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const link1_changes = {};
    			if (dirty & /*$CurrentSong*/ 1) link1_changes.to = "albums/" + /*$CurrentSong*/ ctx[0].album.id;
    			if (dirty & /*$CurrentSong*/ 1) link1_changes.title = /*$CurrentSong*/ ctx[0].album.name;

    			if (dirty & /*$$scope, $CurrentSong*/ 3) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div3);
    			destroy_component(link0);
    			if (if_block) if_block.d();
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(12:4) {#if $CurrentSong}",
    		ctx
    	});

    	return block;
    }

    // (16:67) <Link to="artists/{$CurrentSong.artist.id}">
    function create_default_slot_2$a(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*$CurrentSong*/ ctx[0].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$CurrentSong*/ 1) && t1_value !== (t1_value = /*$CurrentSong*/ ctx[0].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(16:67) <Link to=\\\"artists/{$CurrentSong.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:16) {#if $CurrentSong.year > 0}
    function create_if_block_1$s(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/year/" + /*$CurrentSong*/ ctx[0].year,
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "class", "date svelte-1mv8eze");
    			add_location(span, file$R, 18, 20, 843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*$CurrentSong*/ 1) link_changes.to = "albums/year/" + /*$CurrentSong*/ ctx[0].year;

    			if (dirty & /*$$scope, $CurrentSong*/ 3) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$s.name,
    		type: "if",
    		source: "(18:16) {#if $CurrentSong.year > 0}",
    		ctx
    	});

    	return block;
    }

    // (19:39) <Link to="albums/year/{$CurrentSong.year}">
    function create_default_slot_1$d(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = /*$CurrentSong*/ ctx[0].year + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$CurrentSong*/ 1) && t1_value !== (t1_value = /*$CurrentSong*/ ctx[0].year + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(19:39) <Link to=\\\"albums/year/{$CurrentSong.year}\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:16) <Link to="albums/{$CurrentSong.album.id}" title="{$CurrentSong.album.name}">
    function create_default_slot$r(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*$CurrentSong*/ ctx[0].album.name + "";
    	let t1;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$CurrentSong*/ 1) && t1_value !== (t1_value = /*$CurrentSong*/ ctx[0].album.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(21:16) <Link to=\\\"albums/{$CurrentSong.album.id}\\\" title=\\\"{$CurrentSong.album.name}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1g(ctx) {
    	let div;
    	let current;
    	let if_block = /*$CurrentSong*/ ctx[0] && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "container svelte-1mv8eze");
    			add_location(div, file$R, 10, 0, 313);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$CurrentSong*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$CurrentSong*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$B(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let $CurrentSong;
    	validate_store(CurrentSong, "CurrentSong");
    	component_subscribe($$self, CurrentSong, $$value => $$invalidate(0, $CurrentSong = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player_nowPlaying", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player_nowPlaying> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Link,
    		CurrentSong,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGYear: Year,
    		$CurrentSong
    	});

    	return [$CurrentSong];
    }

    class Player_nowPlaying extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player_nowPlaying",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    /* src\components\menu.svelte generated by Svelte v3.38.3 */

    const { console: console_1$1 } = globals;
    const file$Q = "src\\components\\menu.svelte";

    function create_fragment$1f(ctx) {
    	let div;
    	let clickOutsideDetector_action;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "c-menu svelte-18vl47n");
    			toggle_class(div, "is-open", /*isVisible*/ ctx[0]);
    			add_location(div, file$Q, 126, 0, 4600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[10](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(clickOutsideDetector_action = clickOutsideDetector.call(null, div, {
    						toggle: /*toggleElement*/ ctx[1],
    						ignore: ".c-menu"
    					})),
    					listen_dev(div, "clickedOutside", /*handleClickOutside*/ ctx[3], false, false, false),
    					listen_dev(div, "click", /*handleClickInside*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
    				}
    			}

    			if (clickOutsideDetector_action && is_function(clickOutsideDetector_action.update) && dirty & /*toggleElement*/ 2) clickOutsideDetector_action.update.call(null, {
    				toggle: /*toggleElement*/ ctx[1],
    				ignore: ".c-menu"
    			});

    			if (dirty & /*isVisible*/ 1) {
    				toggle_class(div, "is-open", /*isVisible*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: 0, y: 0, duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: 0, y: 0, duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[10](null);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Menu", slots, ['default']);
    	let { isVisible } = $$props;
    	let { toggleElement } = $$props;
    	let { anchor } = $$props;
    	let spacing = 10;
    	let menu;
    	let menuBounds;
    	let coords = [];
    	let toggleBounds;

    	function handleClickOutside() {
    		$$invalidate(0, isVisible = false);
    	}

    	function handleClickInside(event) {
    		event.stopPropagation();

    		// Close menu if we are following a link
    		if (event.target.href !== undefined) {
    			$$invalidate(0, isVisible = false);
    		}
    	}

    	onMount(() => {
    		let menuContainer = document.querySelector("#menu-container");

    		if (menu) {
    			// move menu to be a direct child of body
    			menuContainer.append(menu);
    		}
    	});

    	// in reference to clicked item
    	function getAnchorCoordinates() {
    		if (toggleBounds && menuBounds) {
    			let posLeft = toggleBounds.left - menuBounds.width - spacing;
    			let posRight = toggleBounds.right + spacing;
    			let posTop = toggleBounds.top - menuBounds.height - spacing;
    			let posBottom = toggleBounds.top + toggleBounds.height + spacing;
    			let alignTop = toggleBounds.top;
    			let alignMiddleHeight = toggleBounds.top + toggleBounds.height / 2 - menuBounds.height / 2;
    			let alignMiddleWidth = toggleBounds.left + toggleBounds.width / 2 - menuBounds.width / 2;
    			let alignBottom = toggleBounds.bottom - menuBounds.height;
    			let alignLeft = toggleBounds.left;
    			let alignRight = toggleBounds.right - menuBounds.width;

    			// [relative to toggle]-[alignment with toggle]
    			switch (anchor) {
    				case "top-left":
    					$$invalidate(7, coords.top = posTop, coords);
    					$$invalidate(7, coords.left = alignLeft, coords);
    					break;
    				case "bottom-left":
    					$$invalidate(7, coords.top = posBottom, coords);
    					$$invalidate(7, coords.left = alignLeft, coords);
    					break;
    				case "top-center":
    					$$invalidate(7, coords.top = posTop, coords);
    					$$invalidate(7, coords.left = alignMiddleWidth, coords);
    					break;
    				case "bottom-center":
    					$$invalidate(7, coords.top = posBottom, coords);
    					$$invalidate(7, coords.left = alignMiddleWidth, coords);
    					break;
    				case "top-right":
    					$$invalidate(7, coords.top = posTop, coords);
    					$$invalidate(7, coords.left = alignRight, coords);
    					break;
    				case "bottom-right":
    					$$invalidate(7, coords.top = posBottom, coords);
    					$$invalidate(7, coords.left = alignRight, coords);
    					break;
    				case "left-center":
    					$$invalidate(7, coords.top = alignMiddleHeight, coords);
    					$$invalidate(7, coords.left = posLeft, coords);
    					break;
    				case "right-center":
    					$$invalidate(7, coords.top = alignMiddleHeight, coords);
    					$$invalidate(7, coords.left = posRight, coords);
    					break;
    				case "left-top":
    					$$invalidate(7, coords.top = alignTop, coords);
    					$$invalidate(7, coords.left = posLeft, coords);
    					break;
    				case "right-top":
    					$$invalidate(7, coords.top = alignTop, coords);
    					$$invalidate(7, coords.left = posRight, coords);
    					break;
    				case "left-bottom":
    					$$invalidate(7, coords.top = alignBottom, coords);
    					$$invalidate(7, coords.left = posLeft, coords);
    					break;
    				case "right-bottom":
    					$$invalidate(7, coords.top = alignBottom, coords);
    					$$invalidate(7, coords.left = posRight, coords);
    					break;
    				default:
    					console.warn(anchor + " as a menu anchor position was not found");
    					$$invalidate(7, coords.top = posBottom, coords);
    					$$invalidate(7, coords.left = alignLeft, coords);
    					break;
    			}
    		}
    	}

    	const writable_props = ["isVisible", "toggleElement", "anchor"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			menu = $$value;
    			$$invalidate(2, menu);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("isVisible" in $$props) $$invalidate(0, isVisible = $$props.isVisible);
    		if ("toggleElement" in $$props) $$invalidate(1, toggleElement = $$props.toggleElement);
    		if ("anchor" in $$props) $$invalidate(5, anchor = $$props.anchor);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		fly,
    		clickOutsideDetector,
    		isVisible,
    		toggleElement,
    		anchor,
    		spacing,
    		menu,
    		menuBounds,
    		coords,
    		toggleBounds,
    		handleClickOutside,
    		handleClickInside,
    		getAnchorCoordinates
    	});

    	$$self.$inject_state = $$props => {
    		if ("isVisible" in $$props) $$invalidate(0, isVisible = $$props.isVisible);
    		if ("toggleElement" in $$props) $$invalidate(1, toggleElement = $$props.toggleElement);
    		if ("anchor" in $$props) $$invalidate(5, anchor = $$props.anchor);
    		if ("spacing" in $$props) spacing = $$props.spacing;
    		if ("menu" in $$props) $$invalidate(2, menu = $$props.menu);
    		if ("menuBounds" in $$props) $$invalidate(6, menuBounds = $$props.menuBounds);
    		if ("coords" in $$props) $$invalidate(7, coords = $$props.coords);
    		if ("toggleBounds" in $$props) toggleBounds = $$props.toggleBounds;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*toggleElement, menu, coords, menuBounds*/ 198) {
    			{
    				if (toggleElement && menu) {
    					toggleBounds = toggleElement.getBoundingClientRect();
    					$$invalidate(6, menuBounds = menu.getBoundingClientRect());
    					getAnchorCoordinates();
    					menu.style.setProperty("--mouse-x", coords.left + "px");
    					menu.style.setProperty("--mouse-y", coords.top + "px");
    					menu.style.setProperty("--width", menuBounds.width + "px");
    					menu.style.setProperty("--height", menuBounds.height + "px");
    				}
    			}
    		}
    	};

    	return [
    		isVisible,
    		toggleElement,
    		menu,
    		handleClickOutside,
    		handleClickInside,
    		anchor,
    		menuBounds,
    		coords,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {
    			isVisible: 0,
    			toggleElement: 1,
    			anchor: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$1f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isVisible*/ ctx[0] === undefined && !("isVisible" in props)) {
    			console_1$1.warn("<Menu> was created without expected prop 'isVisible'");
    		}

    		if (/*toggleElement*/ ctx[1] === undefined && !("toggleElement" in props)) {
    			console_1$1.warn("<Menu> was created without expected prop 'toggleElement'");
    		}

    		if (/*anchor*/ ctx[5] === undefined && !("anchor" in props)) {
    			console_1$1.warn("<Menu> was created without expected prop 'anchor'");
    		}
    	}

    	get isVisible() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVisible(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleElement() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleElement(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchor() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchor(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\delete.svg generated by Svelte v3.38.3 */

    function create_fragment$1e(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v10zM18 4h-2.5l-.71-.71c-.18-.18-.44-.29-.7-.29H9.91c-.26 0-.52.11-.7.29L8.5 4H6c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Delete extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});
    	}
    }

    /* public\images\playlist_play.svg generated by Svelte v3.38.3 */

    function create_fragment$1d(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M5 10h10c.55 0 1 .45 1 1s-.45 1-1 1H5c-.55 0-1-.45-1-1s.45-1 1-1zm0-4h10c.55 0 1 .45 1 1s-.45 1-1 1H5c-.55 0-1-.45-1-1s.45-1 1-1zm0 8h6c.55 0 1 .45 1 1s-.45 1-1 1H5c-.55 0-1-.45-1-1s.45-1 1-1zm9 .88v4.23c0 .39.42.63.76.43l3.53-2.12c.32-.19.32-.66 0-.86l-3.53-2.12c-.34-.19-.76.05-.76.44z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Playlist_play extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});
    	}
    }

    /* public\images\play_circle.svg generated by Svelte v3.38.3 */

    function create_fragment$1c(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 13.5v-7c0-.41.47-.65.8-.4l4.67 3.5c.27.2.27.6 0 .8l-4.67 3.5c-.33.25-.8.01-.8-.4z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Play_circle extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});
    	}
    }

    /* public\images\more-hori.svg generated by Svelte v3.38.3 */

    function create_fragment$1b(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class MoreHori extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});
    	}
    }

    /* src\components\player\player_queue.svelte generated by Svelte v3.38.3 */
    const file$P = "src\\components\\player\\player_queue.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    // (153:4) {#if $NowPlayingQueue && $NowPlayingQueue.length > 0}
    function create_if_block_3$g(ctx) {
    	let div3;
    	let div0;
    	let h4;
    	let t1;
    	let button0;
    	let svgclose;
    	let t2;
    	let t3;
    	let button1;
    	let svgbin;
    	let t4;
    	let t5;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let dndzone_action;
    	let t6;
    	let div2;
    	let button2;
    	let svgcurrent;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	svgclose = new Close({ $$inline: true });
    	svgbin = new Delete({ $$inline: true });
    	let each_value = /*$NowPlayingQueue*/ ctx[2];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*song*/ ctx[22]._id;
    	validate_each_keys(ctx, each_value, get_each_context$e, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$e(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$e(key, child_ctx));
    	}

    	svgcurrent = new Play_circle({ $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Now Playing";
    			t1 = space();
    			button0 = element("button");
    			create_component(svgclose.$$.fragment);
    			t2 = text(" Remove played");
    			t3 = space();
    			button1 = element("button");
    			create_component(svgbin.$$.fragment);
    			t4 = text(" Clear all");
    			t5 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div2 = element("div");
    			button2 = element("button");
    			create_component(svgcurrent.$$.fragment);
    			t7 = text(" Go to current song");
    			attr_dev(h4, "class", "svelte-fp00v");
    			add_location(h4, file$P, 158, 16, 5081);
    			attr_dev(button0, "class", "clear-played with-icon");
    			add_location(button0, file$P, 160, 16, 5121);
    			attr_dev(button1, "class", "clear-all with-icon danger");
    			add_location(button1, file$P, 161, 16, 5242);
    			attr_dev(div0, "class", "header svelte-fp00v");
    			add_location(div0, file$P, 157, 12, 5043);
    			attr_dev(div1, "class", "queue-list svelte-fp00v");
    			add_location(div1, file$P, 164, 12, 5378);
    			attr_dev(button2, "class", "with-icon");
    			add_location(button2, file$P, 221, 16, 8441);
    			attr_dev(div2, "class", "footer svelte-fp00v");
    			add_location(div2, file$P, 220, 12, 8403);
    			attr_dev(div3, "class", "queue-slideout svelte-fp00v");
    			toggle_class(div3, "visible", /*queueVisible*/ ctx[4]);
    			add_location(div3, file$P, 153, 8, 4936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, h4);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			mount_component(svgclose, button0, null);
    			append_dev(button0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			mount_component(svgbin, button1, null);
    			append_dev(button1, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, button2);
    			mount_component(svgcurrent, button2, null);
    			append_dev(button2, t7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleClearPlayed*/ ctx[12], false, false, false),
    					listen_dev(button1, "click", /*handleClearQueue*/ ctx[13], false, false, false),
    					action_destroyer(dndzone_action = dndzone.call(null, div1, {
    						items: /*$NowPlayingQueue*/ ctx[2],
    						dropTargetStyle: {}
    					})),
    					listen_dev(div1, "consider", /*handleSort*/ ctx[14], false, false, false),
    					listen_dev(div1, "finalize", /*handleSort*/ ctx[14], false, false, false),
    					listen_dev(button2, "click", /*showCurrentSong*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$NowPlayingIndex, $NowPlayingQueue, handleAction, document, queueMoreMenuID, queueMoreMenuIsOpen, timeSince, Date, handleSongMenu, handleRemove*/ 3278) {
    				each_value = /*$NowPlayingQueue*/ ctx[2];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$e, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$e, null, get_each_context$e);
    				check_outros();
    			}

    			if (dndzone_action && is_function(dndzone_action.update) && dirty & /*$NowPlayingQueue*/ 4) dndzone_action.update.call(null, {
    				items: /*$NowPlayingQueue*/ ctx[2],
    				dropTargetStyle: {}
    			});

    			if (dirty & /*queueVisible*/ 16) {
    				toggle_class(div3, "visible", /*queueVisible*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclose.$$.fragment, local);
    			transition_in(svgbin.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(svgcurrent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclose.$$.fragment, local);
    			transition_out(svgbin.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(svgcurrent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(svgclose);
    			destroy_component(svgbin);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(svgcurrent);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$g.name,
    		type: "if",
    		source: "(153:4) {#if $NowPlayingQueue && $NowPlayingQueue.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (184:24) {#if $NowPlayingIndex === i}
    function create_if_block_7$7(ctx) {
    	let span;
    	let svgcurrent;
    	let current;
    	svgcurrent = new Play_circle({ props: { class: "icon" }, $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(svgcurrent.$$.fragment);
    			attr_dev(span, "class", "current-icon svelte-fp00v");
    			add_location(span, file$P, 184, 28, 6316);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(svgcurrent, span, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgcurrent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgcurrent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(svgcurrent);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$7.name,
    		type: "if",
    		source: "(184:24) {#if $NowPlayingIndex === i}",
    		ctx
    	});

    	return block;
    }

    // (192:24) {#if song.lastPlayed}
    function create_if_block_6$8(ctx) {
    	let previous_key = /*timeSinceTime*/ ctx[0] + "" + /*song*/ ctx[22]._id;
    	let key_block_anchor;
    	let key_block = create_key_block$6(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*timeSinceTime, $NowPlayingQueue*/ 5 && safe_not_equal(previous_key, previous_key = /*timeSinceTime*/ ctx[0] + "" + /*song*/ ctx[22]._id)) {
    				key_block.d(1);
    				key_block = create_key_block$6(ctx);
    				key_block.c();
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$8.name,
    		type: "if",
    		source: "(192:24) {#if song.lastPlayed}",
    		ctx
    	});

    	return block;
    }

    // (193:28) {#key timeSinceTime + "" + song._id}
    function create_key_block$6(ctx) {
    	let span;
    	let t0_value = timeSince(new Date(/*song*/ ctx[22].lastPlayed)) + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" ago");
    			attr_dev(span, "class", "lastPlayed svelte-fp00v");
    			add_location(span, file$P, 193, 32, 7005);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$NowPlayingQueue*/ 4 && t0_value !== (t0_value = timeSince(new Date(/*song*/ ctx[22].lastPlayed)) + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$6.name,
    		type: "key",
    		source: "(193:28) {#key timeSinceTime + \\\"\\\" + song._id}",
    		ctx
    	});

    	return block;
    }

    // (198:24) {#if song.fromAutoPlay}
    function create_if_block_5$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "From AutoPlay";
    			attr_dev(span, "class", "fromAutoPlay svelte-fp00v");
    			add_location(span, file$P, 198, 28, 7227);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$8.name,
    		type: "if",
    		source: "(198:24) {#if song.fromAutoPlay}",
    		ctx
    	});

    	return block;
    }

    // (202:24) {#if queueMoreMenuIsOpen && queueMoreMenuID === i}
    function create_if_block_4$c(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[16](value);
    	}

    	let menu_props = {
    		anchor: "left-center",
    		toggleElement: document.querySelector("#queueMoreToggle-" + /*queueMoreMenuID*/ ctx[1]),
    		$$slots: { default: [create_default_slot_1$c] },
    		$$scope: { ctx }
    	};

    	if (/*queueMoreMenuIsOpen*/ ctx[6] !== void 0) {
    		menu_props.isVisible = /*queueMoreMenuIsOpen*/ ctx[6];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*queueMoreMenuID*/ 2) menu_changes.toggleElement = document.querySelector("#queueMoreToggle-" + /*queueMoreMenuID*/ ctx[1]);

    			if (dirty & /*$$scope, $NowPlayingQueue*/ 33554436) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*queueMoreMenuIsOpen*/ 64) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*queueMoreMenuIsOpen*/ ctx[6];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$c.name,
    		type: "if",
    		source: "(202:24) {#if queueMoreMenuIsOpen && queueMoreMenuID === i}",
    		ctx
    	});

    	return block;
    }

    // (209:40) <Link to="albums/{song.album.id}">
    function create_default_slot_3$7(ctx) {
    	let svgalbum;
    	let t;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t = text(" Go to album");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(209:40) <Link to=\\\"albums/{song.album.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (212:40) <Link to="artists/{song.artist.id}">
    function create_default_slot_2$9(ctx) {
    	let svgartist;
    	let t;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t = text(" Go to artist");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(212:40) <Link to=\\\"artists/{song.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (203:28) <Menu anchor="left-center" toggleElement={document.querySelector('#queueMoreToggle-' + queueMoreMenuID)} bind:isVisible={queueMoreMenuIsOpen}>
    function create_default_slot_1$c(ctx) {
    	let ul;
    	let li0;
    	let button;
    	let t1;
    	let li1;
    	let link0;
    	let t2;
    	let li2;
    	let link1;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "albums/" + /*song*/ ctx[22].album.id,
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "artists/" + /*song*/ ctx[22].artist.id,
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			button = element("button");
    			button.textContent = "Add to playlist";
    			t1 = space();
    			li1 = element("li");
    			create_component(link0.$$.fragment);
    			t2 = space();
    			li2 = element("li");
    			create_component(link1.$$.fragment);
    			attr_dev(button, "class", "visuallyLink");
    			add_location(button, file$P, 205, 40, 7695);
    			add_location(li0, file$P, 204, 36, 7649);
    			add_location(li1, file$P, 207, 36, 7829);
    			add_location(li2, file$P, 210, 36, 8035);
    			attr_dev(ul, "class", "menu-list");
    			add_location(ul, file$P, 203, 32, 7589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, button);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			mount_component(link0, li1, null);
    			append_dev(ul, t2);
    			append_dev(ul, li2);
    			mount_component(link1, li2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};
    			if (dirty & /*$NowPlayingQueue*/ 4) link0_changes.to = "albums/" + /*song*/ ctx[22].album.id;

    			if (dirty & /*$$scope*/ 33554432) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty & /*$NowPlayingQueue*/ 4) link1_changes.to = "artists/" + /*song*/ ctx[22].artist.id;

    			if (dirty & /*$$scope*/ 33554432) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(203:28) <Menu anchor=\\\"left-center\\\" toggleElement={document.querySelector('#queueMoreToggle-' + queueMoreMenuID)} bind:isVisible={queueMoreMenuIsOpen}>",
    		ctx
    	});

    	return block;
    }

    // (174:16) {#each $NowPlayingQueue as song, i (song._id)}
    function create_each_block$e(key_1, ctx) {
    	let div2;
    	let button0;
    	let svgclose;
    	let t0;
    	let span0;
    	let img;
    	let img_src_value;
    	let t1;
    	let t2;
    	let span1;
    	let div0;
    	let t3_value = /*song*/ ctx[22].name + "";
    	let t3;
    	let div0_title_value;
    	let t4;
    	let div1;
    	let svgartist;
    	let t5;
    	let t6_value = /*song*/ ctx[22].artist.name + "";
    	let t6;
    	let div1_title_value;
    	let t7;
    	let button1;
    	let svgmore;
    	let button1_id_value;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let current;
    	let mounted;
    	let dispose;
    	svgclose = new Close({ $$inline: true });
    	let if_block0 = /*$NowPlayingIndex*/ ctx[3] === /*i*/ ctx[24] && create_if_block_7$7(ctx);

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	svgmore = new MoreHori({ $$inline: true });
    	let if_block1 = /*song*/ ctx[22].lastPlayed && create_if_block_6$8(ctx);
    	let if_block2 = /*song*/ ctx[22].fromAutoPlay && create_if_block_5$8(ctx);
    	let if_block3 = /*queueMoreMenuIsOpen*/ ctx[6] && /*queueMoreMenuID*/ ctx[1] === /*i*/ ctx[24] && create_if_block_4$c(ctx);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[17](/*i*/ ctx[24], ...args);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div2 = element("div");
    			button0 = element("button");
    			create_component(svgclose.$$.fragment);
    			t0 = space();
    			span0 = element("span");
    			img = element("img");
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			span1 = element("span");
    			div0 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div1 = element("div");
    			create_component(svgartist.$$.fragment);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			create_component(svgmore.$$.fragment);
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			if (if_block2) if_block2.c();
    			t10 = space();
    			if (if_block3) if_block3.c();
    			t11 = space();
    			attr_dev(button0, "class", "icon remove svelte-fp00v");
    			add_location(button0, file$P, 179, 24, 5978);
    			if (img.src !== (img_src_value = "" + (/*song*/ ctx[22].art + "&thumb=1"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "loading", "lazy");
    			attr_dev(img, "class", "svelte-fp00v");
    			add_location(img, file$P, 181, 28, 6146);
    			attr_dev(span0, "class", "thumb svelte-fp00v");
    			add_location(span0, file$P, 180, 24, 6096);
    			attr_dev(div0, "class", "queue-title svelte-fp00v");
    			attr_dev(div0, "title", div0_title_value = /*song*/ ctx[22].name);
    			add_location(div0, file$P, 187, 28, 6486);
    			attr_dev(div1, "class", "queue-artist svelte-fp00v");
    			attr_dev(div1, "title", div1_title_value = /*song*/ ctx[22].artist.name);
    			add_location(div1, file$P, 188, 28, 6578);
    			attr_dev(span1, "class", "details svelte-fp00v");
    			add_location(span1, file$P, 186, 24, 6434);
    			attr_dev(button1, "id", button1_id_value = "queueMoreToggle-" + /*i*/ ctx[24]);
    			attr_dev(button1, "class", "icon more svelte-fp00v");
    			add_location(button1, file$P, 190, 24, 6742);
    			attr_dev(div2, "class", "queue-item svelte-fp00v");
    			toggle_class(div2, "currentlyPlaying", /*$NowPlayingIndex*/ ctx[3] === /*i*/ ctx[24]);
    			add_location(div2, file$P, 174, 20, 5742);
    			this.first = div2;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button0);
    			mount_component(svgclose, button0, null);
    			append_dev(div2, t0);
    			append_dev(div2, span0);
    			append_dev(span0, img);
    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, span1);
    			append_dev(span1, div0);
    			append_dev(div0, t3);
    			append_dev(span1, t4);
    			append_dev(span1, div1);
    			mount_component(svgartist, div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    			append_dev(div2, t7);
    			append_dev(div2, button1);
    			mount_component(svgmore, button1, null);
    			append_dev(div2, t8);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t9);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t10);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div2, t11);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button0,
    						"click",
    						stop_propagation(function () {
    							if (is_function(/*handleRemove*/ ctx[10](/*i*/ ctx[24]))) /*handleRemove*/ ctx[10](/*i*/ ctx[24]).apply(this, arguments);
    						}),
    						false,
    						false,
    						true
    					),
    					listen_dev(
    						button1,
    						"click",
    						stop_propagation(function () {
    							if (is_function(/*handleSongMenu*/ ctx[11](/*i*/ ctx[24]))) /*handleSongMenu*/ ctx[11](/*i*/ ctx[24]).apply(this, arguments);
    						}),
    						false,
    						false,
    						true
    					),
    					listen_dev(div2, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*$NowPlayingQueue*/ 4 && img.src !== (img_src_value = "" + (/*song*/ ctx[22].art + "&thumb=1"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (/*$NowPlayingIndex*/ ctx[3] === /*i*/ ctx[24]) {
    				if (if_block0) {
    					if (dirty & /*$NowPlayingIndex, $NowPlayingQueue*/ 12) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*$NowPlayingQueue*/ 4) && t3_value !== (t3_value = /*song*/ ctx[22].name + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*$NowPlayingQueue*/ 4 && div0_title_value !== (div0_title_value = /*song*/ ctx[22].name)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			if ((!current || dirty & /*$NowPlayingQueue*/ 4) && t6_value !== (t6_value = /*song*/ ctx[22].artist.name + "")) set_data_dev(t6, t6_value);

    			if (!current || dirty & /*$NowPlayingQueue*/ 4 && div1_title_value !== (div1_title_value = /*song*/ ctx[22].artist.name)) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 4 && button1_id_value !== (button1_id_value = "queueMoreToggle-" + /*i*/ ctx[24])) {
    				attr_dev(button1, "id", button1_id_value);
    			}

    			if (/*song*/ ctx[22].lastPlayed) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$8(ctx);
    					if_block1.c();
    					if_block1.m(div2, t9);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*song*/ ctx[22].fromAutoPlay) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_5$8(ctx);
    					if_block2.c();
    					if_block2.m(div2, t10);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*queueMoreMenuIsOpen*/ ctx[6] && /*queueMoreMenuID*/ ctx[1] === /*i*/ ctx[24]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*queueMoreMenuIsOpen, queueMoreMenuID, $NowPlayingQueue*/ 70) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_4$c(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, t11);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*$NowPlayingIndex, $NowPlayingQueue*/ 12) {
    				toggle_class(div2, "currentlyPlaying", /*$NowPlayingIndex*/ ctx[3] === /*i*/ ctx[24]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclose.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(svgartist.$$.fragment, local);
    			transition_in(svgmore.$$.fragment, local);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclose.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(svgartist.$$.fragment, local);
    			transition_out(svgmore.$$.fragment, local);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(svgclose);
    			if (if_block0) if_block0.d();
    			destroy_component(svgartist);
    			destroy_component(svgmore);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(174:16) {#each $NowPlayingQueue as song, i (song._id)}",
    		ctx
    	});

    	return block;
    }

    // (229:8) {#if $NowPlayingQueue.length > 0}
    function create_if_block_2$n(ctx) {
    	let span;

    	let t0_value = (/*$NowPlayingQueue*/ ctx[2].length === 0
    	? 0
    	: /*$NowPlayingIndex*/ ctx[3] + 1) + "";

    	let t0;
    	let t1;
    	let t2_value = /*$NowPlayingQueue*/ ctx[2].length + "";
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" of ");
    			t2 = text(t2_value);
    			attr_dev(span, "class", "queue-details");
    			add_location(span, file$P, 229, 12, 8716);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$NowPlayingQueue, $NowPlayingIndex*/ 12 && t0_value !== (t0_value = (/*$NowPlayingQueue*/ ctx[2].length === 0
    			? 0
    			: /*$NowPlayingIndex*/ ctx[3] + 1) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$NowPlayingQueue*/ 4 && t2_value !== (t2_value = /*$NowPlayingQueue*/ ctx[2].length + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$n.name,
    		type: "if",
    		source: "(229:8) {#if $NowPlayingQueue.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (232:8) {#if $NowPlayingQueue.length < 2}
    function create_if_block_1$r(ctx) {
    	let span;
    	let t1;
    	let br;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "No upcoming songs";
    			t1 = space();
    			br = element("br");
    			set_style(span, "display", "block");
    			add_location(span, file$P, 232, 12, 8910);
    			add_location(br, file$P, 233, 12, 8977);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$r.name,
    		type: "if",
    		source: "(232:8) {#if $NowPlayingQueue.length < 2}",
    		ctx
    	});

    	return block;
    }

    // (237:8) {#if nextSong}
    function create_if_block$A(ctx) {
    	let div0;
    	let span;
    	let t1;
    	let t2_value = /*nextSong*/ ctx[5].title + "";
    	let t2;
    	let t3;
    	let div1;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*nextSong*/ ctx[5].artist.id,
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span = element("span");
    			span.textContent = "Next:";
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(span, "class", "svelte-fp00v");
    			add_location(span, file$P, 237, 31, 9055);
    			attr_dev(div0, "class", "title svelte-fp00v");
    			add_location(div0, file$P, 237, 12, 9036);
    			attr_dev(div1, "class", "artist svelte-fp00v");
    			add_location(div1, file$P, 238, 12, 9110);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*nextSong*/ 32) && t2_value !== (t2_value = /*nextSong*/ ctx[5].title + "")) set_data_dev(t2, t2_value);
    			const link_changes = {};
    			if (dirty & /*nextSong*/ 32) link_changes.to = "artists/" + /*nextSong*/ ctx[5].artist.id;

    			if (dirty & /*$$scope, nextSong*/ 33554464) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(237:8) {#if nextSong}",
    		ctx
    	});

    	return block;
    }

    // (239:32) <Link to="artists/{nextSong.artist.id}">
    function create_default_slot$q(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*nextSong*/ ctx[5].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*nextSong*/ 32) && t1_value !== (t1_value = /*nextSong*/ ctx[5].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(239:32) <Link to=\\\"artists/{nextSong.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let h4;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let button;
    	let svgplaylistplay;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$NowPlayingQueue*/ ctx[2] && /*$NowPlayingQueue*/ ctx[2].length > 0 && create_if_block_3$g(ctx);
    	let if_block1 = /*$NowPlayingQueue*/ ctx[2].length > 0 && create_if_block_2$n(ctx);
    	let if_block2 = /*$NowPlayingQueue*/ ctx[2].length < 2 && create_if_block_1$r(ctx);
    	let if_block3 = /*nextSong*/ ctx[5] && create_if_block$A(ctx);

    	svgplaylistplay = new Playlist_play({
    			props: { style: "transform: scale(1.3)" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Queue";
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			button = element("button");
    			create_component(svgplaylistplay.$$.fragment);
    			attr_dev(h4, "class", "queue-header svelte-fp00v");
    			add_location(h4, file$P, 227, 8, 8624);
    			attr_dev(div0, "class", "queueInfo svelte-fp00v");
    			add_location(div0, file$P, 226, 4, 8591);
    			attr_dev(button, "class", "with-icon queue-toggle svelte-fp00v");
    			button.disabled = button_disabled_value = /*$NowPlayingQueue*/ ctx[2].length === 0;
    			add_location(button, file$P, 242, 4, 9268);
    			attr_dev(div1, "class", "container well svelte-fp00v");
    			attr_dev(div1, "id", "c-queue");
    			add_location(div1, file$P, 151, 0, 4826);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, h4);
    			append_dev(div0, t2);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div0, t4);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div1, t5);
    			append_dev(div1, button);
    			mount_component(svgplaylistplay, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleQueue*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$NowPlayingQueue*/ ctx[2] && /*$NowPlayingQueue*/ ctx[2].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$NowPlayingQueue*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$NowPlayingQueue*/ ctx[2].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$n(ctx);
    					if_block1.c();
    					if_block1.m(div0, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*$NowPlayingQueue*/ ctx[2].length < 2) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_1$r(ctx);
    					if_block2.c();
    					if_block2.m(div0, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*nextSong*/ ctx[5]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*nextSong*/ 32) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$A(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 4 && button_disabled_value !== (button_disabled_value = /*$NowPlayingQueue*/ ctx[2].length === 0)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block3);
    			transition_in(svgplaylistplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block3);
    			transition_out(svgplaylistplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(svgplaylistplay);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let $NowPlayingQueue;
    	let $NowPlayingIndex;
    	let $MediaPlayer;
    	let $CurrentSong;
    	validate_store(NowPlayingQueue, "NowPlayingQueue");
    	component_subscribe($$self, NowPlayingQueue, $$value => $$invalidate(2, $NowPlayingQueue = $$value));
    	validate_store(NowPlayingIndex, "NowPlayingIndex");
    	component_subscribe($$self, NowPlayingIndex, $$value => $$invalidate(3, $NowPlayingIndex = $$value));
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(18, $MediaPlayer = $$value));
    	validate_store(CurrentSong, "CurrentSong");
    	component_subscribe($$self, CurrentSong, $$value => $$invalidate(19, $CurrentSong = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player_queue", slots, []);
    	let queueVisible = false;
    	let nextSong;
    	let staleTime = Date.now();
    	let timeSinceTime = Date.now();
    	let staleThreshold = 1000 * 60 * 60 * 3; // 3 hours
    	let queueMoreMenuID;
    	let queueMoreMenuIsOpen = false;

    	function handleAction(event, index) {
    		$MediaPlayer.playSelected(index);

    		// clickOutsideHandler doesn't respond so manually turn off menus
    		$$invalidate(6, queueMoreMenuIsOpen = false);
    	}

    	const checkElement = async selector => {
    		while (document.querySelector(selector) === null) {
    			await new Promise(resolve => requestAnimationFrame(resolve));
    		}

    		return document.querySelector(selector);
    	};

    	function toggleQueue() {
    		if ($NowPlayingQueue.length > 0) {
    			$$invalidate(4, queueVisible = !queueVisible);
    		}

    		showCurrentSong({ behavior: "auto" });
    	}

    	function showCurrentSong({ behavior = "smooth" }) {
    		if (queueVisible) {
    			checkElement("#c-queue .currentlyPlaying").then(selector => {
    				selector.scrollIntoView({ behavior });
    			});
    		}
    	}

    	function handleRemove(index) {
    		$NowPlayingQueue.splice(index, 1);

    		// If playing song is removed, load new track
    		if ($NowPlayingIndex === index) {
    			$MediaPlayer.stop();
    			$MediaPlayer.start();
    		}

    		// account for removal of previous items affected NowPlayingIndex
    		if ($NowPlayingIndex > index) {
    			NowPlayingIndex.set($NowPlayingIndex - 1);
    		}

    		NowPlayingQueue.set($NowPlayingQueue);
    	}

    	function handleSongMenu(index) {
    		$$invalidate(1, queueMoreMenuID = index);
    		$$invalidate(6, queueMoreMenuIsOpen = !queueMoreMenuIsOpen);
    	}

    	function handleClearPlayed() {
    		let foundIndex = 0;

    		// find next item to remove, that isn't the currently playing song
    		while (foundIndex !== -1) {
    			foundIndex = $NowPlayingQueue.findIndex((item, index) => index !== $NowPlayingIndex && item.lastPlayed);

    			if (foundIndex !== -1) {
    				handleRemove(foundIndex);
    			}
    		}
    	}

    	function handleClearQueue() {
    		$MediaPlayer.clearQueue();
    		$$invalidate(4, queueVisible = false);
    	}

    	function handleSort(e) {
    		NowPlayingQueue.set([...e.detail.items]);
    		let currentIndex = $NowPlayingQueue.findIndex(item => item._id === $CurrentSong._id);

    		if (currentIndex !== -1) {
    			NowPlayingIndex.set(currentIndex);
    		}
    	}

    	onMount(() => {
    		// how often to recalculate the last played times
    		const timeSinceTimer = setInterval(
    			() => {
    				$$invalidate(0, timeSinceTime = Date.now());
    			},
    			1000 * 30
    		); // 30 seconds

    		// check for stale songs and remove from queue
    		const staleTimer = setInterval(
    			() => {
    				$$invalidate(15, staleTime = Date.now());

    				// remove any stale songs
    				let indexes = $NowPlayingQueue.reduce(
    					(a, curr, index) => {
    						if (curr.lastPlayed + staleThreshold < staleTime) {
    							a.push(index);
    						}

    						return a;
    					},
    					[]
    				);

    				indexes.forEach(function (index) {
    					// don't remove an old song being replayed, and preserve the previous 10 songs before current song
    					if (index !== $NowPlayingIndex && index < $NowPlayingIndex - 10) {
    						handleRemove(index);
    					}
    				});
    			},
    			1000 * 60 * 10
    		); // 10 minutes

    		return () => {
    			clearInterval(staleTimer);
    			clearInterval(timeSinceTimer);
    		};
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player_queue> was created with unknown prop '${key}'`);
    	});

    	function menu_isVisible_binding(value) {
    		queueMoreMenuIsOpen = value;
    		$$invalidate(6, queueMoreMenuIsOpen);
    	}

    	const click_handler = (i, e) => {
    		handleAction(e, i);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Link,
    		dndzone,
    		NowPlayingQueue,
    		NowPlayingIndex,
    		CurrentSong,
    		MediaPlayer,
    		timeSince,
    		Menu,
    		SVGClose: Close,
    		SVGBin: Delete,
    		SVGPlaylistPlay: Playlist_play,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGCurrent: Play_circle,
    		SVGMore: MoreHori,
    		queueVisible,
    		nextSong,
    		staleTime,
    		timeSinceTime,
    		staleThreshold,
    		queueMoreMenuID,
    		queueMoreMenuIsOpen,
    		handleAction,
    		checkElement,
    		toggleQueue,
    		showCurrentSong,
    		handleRemove,
    		handleSongMenu,
    		handleClearPlayed,
    		handleClearQueue,
    		handleSort,
    		$NowPlayingQueue,
    		$NowPlayingIndex,
    		$MediaPlayer,
    		$CurrentSong
    	});

    	$$self.$inject_state = $$props => {
    		if ("queueVisible" in $$props) $$invalidate(4, queueVisible = $$props.queueVisible);
    		if ("nextSong" in $$props) $$invalidate(5, nextSong = $$props.nextSong);
    		if ("staleTime" in $$props) $$invalidate(15, staleTime = $$props.staleTime);
    		if ("timeSinceTime" in $$props) $$invalidate(0, timeSinceTime = $$props.timeSinceTime);
    		if ("staleThreshold" in $$props) staleThreshold = $$props.staleThreshold;
    		if ("queueMoreMenuID" in $$props) $$invalidate(1, queueMoreMenuID = $$props.queueMoreMenuID);
    		if ("queueMoreMenuIsOpen" in $$props) $$invalidate(6, queueMoreMenuIsOpen = $$props.queueMoreMenuIsOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*queueMoreMenuID*/ 2) ;

    		if ($$self.$$.dirty & /*$NowPlayingQueue, $NowPlayingIndex*/ 12) {
    			$$invalidate(5, nextSong = $NowPlayingQueue[$NowPlayingIndex + 1]);
    		}

    		if ($$self.$$.dirty & /*staleTime*/ 32768) {
    			$$invalidate(15, staleTime);
    		}

    		if ($$self.$$.dirty & /*timeSinceTime*/ 1) {
    			$$invalidate(0, timeSinceTime);
    		}
    	};

    	return [
    		timeSinceTime,
    		queueMoreMenuID,
    		$NowPlayingQueue,
    		$NowPlayingIndex,
    		queueVisible,
    		nextSong,
    		queueMoreMenuIsOpen,
    		handleAction,
    		toggleQueue,
    		showCurrentSong,
    		handleRemove,
    		handleSongMenu,
    		handleClearPlayed,
    		handleClearQueue,
    		handleSort,
    		staleTime,
    		menu_isVisible_binding,
    		click_handler
    	];
    }

    class Player_queue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player_queue",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    /* public\images\volume_up.svg generated by Svelte v3.38.3 */

    function create_fragment$19(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$19($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Volume_up extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});
    	}
    }

    /* public\images\volume_off.svg generated by Svelte v3.38.3 */

    function create_fragment$18(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M3.63 3.63c-.39.39-.39 1.02 0 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12c0-1.77-1.02-3.29-2.5-4.03v1.79l2.48 2.48c.01-.08.02-.16.02-.24z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$18($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Volume_off extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});
    	}
    }

    /* public\images\tune.svg generated by Svelte v3.38.3 */

    function create_fragment$17(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$17($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tune extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});
    	}
    }

    /* src\components\player\player_volume.svelte generated by Svelte v3.38.3 */
    const file$O = "src\\components\\player\\player_volume.svelte";

    // (98:4) {:else}
    function create_else_block$o(ctx) {
    	let svgvolumeup;
    	let current;
    	svgvolumeup = new Volume_up({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgvolumeup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgvolumeup, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgvolumeup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgvolumeup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgvolumeup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$o.name,
    		type: "else",
    		source: "(98:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (96:4) {#if $IsMuted}
    function create_if_block_4$b(ctx) {
    	let svgvolumemuted;
    	let current;
    	svgvolumemuted = new Volume_off({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(svgvolumemuted.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgvolumemuted, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgvolumemuted.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgvolumemuted.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgvolumemuted, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$b.name,
    		type: "if",
    		source: "(96:4) {#if $IsMuted}",
    		ctx
    	});

    	return block;
    }

    // (123:0) {#if menuIsVisible}
    function create_if_block$z(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[18](value);
    	}

    	let menu_props = {
    		anchor: "top-center",
    		toggleElement: document.querySelector("#volumeMenu"),
    		class: "test",
    		$$slots: { default: [create_default_slot$p] },
    		$$scope: { ctx }
    	};

    	if (/*menuIsVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*menuIsVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, $DynamicsCompressorEnabled, $MediaPlayer, $CurrentSong, $VolumeNormalizationEnabled*/ 4194513) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*menuIsVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*menuIsVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(123:0) {#if menuIsVisible}",
    		ctx
    	});

    	return block;
    }

    // (137:20) {#if $CurrentSong}
    function create_if_block_1$q(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1_value = /*$MediaPlayer*/ ctx[4].gainType + "";
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let t5;
    	let t6_value = /*$MediaPlayer*/ ctx[4].gainNeeded + "";
    	let t6;
    	let t7;
    	let if_block0 = /*$MediaPlayer*/ ctx[4].gainType === "EBU R128" && create_if_block_3$f(ctx);
    	let if_block1 = /*$MediaPlayer*/ ctx[4].gainType === "ReplayGain" && create_if_block_2$m(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text("Current type: ");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div1 = element("div");
    			t5 = text("Gain: ");
    			t6 = text(t6_value);
    			t7 = text("db");
    			add_location(div0, file$O, 138, 28, 4562);
    			add_location(div1, file$O, 149, 28, 5128);
    			attr_dev(div2, "class", "well");
    			add_location(div2, file$O, 137, 24, 4514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t3);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, t7);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MediaPlayer*/ 16 && t1_value !== (t1_value = /*$MediaPlayer*/ ctx[4].gainType + "")) set_data_dev(t1, t1_value);

    			if (/*$MediaPlayer*/ ctx[4].gainType === "EBU R128") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$f(ctx);
    					if_block0.c();
    					if_block0.m(div2, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$MediaPlayer*/ ctx[4].gainType === "ReplayGain") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$m(ctx);
    					if_block1.c();
    					if_block1.m(div2, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$MediaPlayer*/ 16 && t6_value !== (t6_value = /*$MediaPlayer*/ ctx[4].gainNeeded + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$q.name,
    		type: "if",
    		source: "(137:20) {#if $CurrentSong}",
    		ctx
    	});

    	return block;
    }

    // (141:28) {#if $MediaPlayer.gainType === 'EBU R128'}
    function create_if_block_3$f(ctx) {
    	let div0;
    	let t0;
    	let t1_value = /*$MediaPlayer*/ ctx[4].targetVolume + "";
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5_value = /*$MediaPlayer*/ ctx[4].masteredVolume + "";
    	let t5;
    	let t6;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = text("Target volume: ");
    			t1 = text(t1_value);
    			t2 = text("db");
    			t3 = space();
    			div1 = element("div");
    			t4 = text("Mastered volume: ");
    			t5 = text(t5_value);
    			t6 = text("db");
    			add_location(div0, file$O, 141, 32, 4718);
    			add_location(div1, file$O, 142, 32, 4807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MediaPlayer*/ 16 && t1_value !== (t1_value = /*$MediaPlayer*/ ctx[4].targetVolume + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$MediaPlayer*/ 16 && t5_value !== (t5_value = /*$MediaPlayer*/ ctx[4].masteredVolume + "")) set_data_dev(t5, t5_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$f.name,
    		type: "if",
    		source: "(141:28) {#if $MediaPlayer.gainType === 'EBU R128'}",
    		ctx
    	});

    	return block;
    }

    // (146:28) {#if $MediaPlayer.gainType === 'ReplayGain'}
    function create_if_block_2$m(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*$MediaPlayer*/ ctx[4].gainTagValue + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("ReplayGain: ");
    			t1 = text(t1_value);
    			add_location(div, file$O, 146, 32, 5011);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$MediaPlayer*/ 16 && t1_value !== (t1_value = /*$MediaPlayer*/ ctx[4].gainTagValue + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$m.name,
    		type: "if",
    		source: "(146:28) {#if $MediaPlayer.gainType === 'ReplayGain'}",
    		ctx
    	});

    	return block;
    }

    // (124:4) <Menu anchor="top-center" toggleElement={document.querySelector("#volumeMenu")} bind:isVisible={menuIsVisible} class="test" >
    function create_default_slot$p(ctx) {
    	let div3;
    	let div2;
    	let h4;
    	let t1;
    	let div0;
    	let label0;
    	let input0;
    	let t2;
    	let t3;
    	let p0;
    	let t5;
    	let t6;
    	let div1;
    	let label1;
    	let input1;
    	let t7;
    	let t8;
    	let p1;
    	let mounted;
    	let dispose;
    	let if_block = /*$CurrentSong*/ ctx[0] && create_if_block_1$q(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Volume settings";
    			t1 = space();
    			div0 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = text("\r\n                        Normalize volume");
    			t3 = space();
    			p0 = element("p");
    			p0.textContent = "Keeps volume consistent between different tracks";
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			div1 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t7 = text("\r\n                        Enable Night Mode");
    			t8 = space();
    			p1 = element("p");
    			p1.textContent = "Boosts quieter parts of songs";
    			add_location(h4, file$O, 126, 16, 4047);
    			attr_dev(input0, "type", "checkbox");
    			add_location(input0, file$O, 130, 24, 4180);
    			attr_dev(label0, "class", "toggle");
    			add_location(label0, file$O, 129, 20, 4132);
    			attr_dev(p0, "class", "info svelte-nlw8tt");
    			add_location(p0, file$O, 134, 20, 4378);
    			attr_dev(div0, "class", "group svelte-nlw8tt");
    			add_location(div0, file$O, 128, 16, 4091);
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$O, 156, 24, 5364);
    			attr_dev(label1, "class", "toggle");
    			add_location(label1, file$O, 155, 20, 5316);
    			attr_dev(p1, "class", "info svelte-nlw8tt");
    			add_location(p1, file$O, 160, 20, 5565);
    			attr_dev(div1, "class", "group svelte-nlw8tt");
    			add_location(div1, file$O, 154, 16, 5275);
    			attr_dev(div2, "class", "header");
    			add_location(div2, file$O, 125, 12, 4009);
    			attr_dev(div3, "class", "wrapper svelte-nlw8tt");
    			add_location(div3, file$O, 124, 8, 3974);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, h4);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input0);
    			input0.checked = /*$VolumeNormalizationEnabled*/ ctx[6];
    			append_dev(label0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p0);
    			append_dev(div0, t5);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div2, t6);
    			append_dev(div2, div1);
    			append_dev(div1, label1);
    			append_dev(label1, input1);
    			input1.checked = /*$DynamicsCompressorEnabled*/ ctx[7];
    			append_dev(label1, t7);
    			append_dev(div1, t8);
    			append_dev(div1, p1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*handleVolumeNormalize*/ ctx[11], false, false, false),
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[16]),
    					listen_dev(input1, "change", /*handleDynamicsCompressor*/ ctx[12], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[17])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$VolumeNormalizationEnabled*/ 64) {
    				input0.checked = /*$VolumeNormalizationEnabled*/ ctx[6];
    			}

    			if (/*$CurrentSong*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$q(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$DynamicsCompressorEnabled*/ 128) {
    				input1.checked = /*$DynamicsCompressorEnabled*/ ctx[7];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(124:4) <Menu anchor=\\\"top-center\\\" toggleElement={document.querySelector(\\\"#volumeMenu\\\")} bind:isVisible={menuIsVisible} class=\\\"test\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let button0;
    	let current_block_type_index;
    	let if_block0;
    	let button0_disabled_value;
    	let button0_title_value;
    	let t0;
    	let div;
    	let span;
    	let span_data_value_value;
    	let t1;
    	let button1;
    	let svgtune;
    	let t2;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_4$b, create_else_block$o];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$IsMuted*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	svgtune = new Tune({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	let if_block1 = /*menuIsVisible*/ ctx[2] && create_if_block$z(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			if_block0.c();
    			t0 = space();
    			div = element("div");
    			span = element("span");
    			t1 = space();
    			button1 = element("button");
    			create_component(svgtune.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(button0, "class", "icon");
    			button0.disabled = button0_disabled_value = /*$NowPlayingQueue*/ ctx[8].length === 0;
    			attr_dev(button0, "title", button0_title_value = /*$IsMuted*/ ctx[5] ? "Unmute" : "Mute");
    			add_location(button0, file$O, 89, 0, 3042);
    			attr_dev(span, "class", "site-player__volume-value svelte-nlw8tt");
    			attr_dev(span, "data-value", span_data_value_value = Math.floor(/*volumeWidth*/ ctx[1]));
    			set_style(span, "width", /*volumeWidth*/ ctx[1] + "%");
    			add_location(span, file$O, 108, 4, 3472);
    			attr_dev(div, "class", "site-player__volume-slider svelte-nlw8tt");
    			add_location(div, file$O, 102, 0, 3305);
    			attr_dev(button1, "id", "volumeMenu");
    			attr_dev(button1, "class", "icon");
    			attr_dev(button1, "title", "Volume settings");
    			toggle_class(button1, "notification-dot", /*missingGainTags*/ ctx[3]);
    			add_location(button1, file$O, 112, 0, 3606);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			if_blocks[current_block_type_index].m(button0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button1, anchor);
    			mount_component(svgtune, button1, null);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleMuteToggle*/ ctx[10], false, false, false),
    					listen_dev(div, "click", /*handleVolumeSlider*/ ctx[13], false, false, false),
    					listen_dev(div, "mousedown", /*handleVolumeMouseDown*/ ctx[14], false, false, false),
    					listen_dev(div, "mousemove", /*handleVolumeDrag*/ ctx[15], false, false, false),
    					listen_dev(button1, "click", /*toggleMenu*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(button0, null);
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 256 && button0_disabled_value !== (button0_disabled_value = /*$NowPlayingQueue*/ ctx[8].length === 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (!current || dirty & /*$IsMuted*/ 32 && button0_title_value !== (button0_title_value = /*$IsMuted*/ ctx[5] ? "Unmute" : "Mute")) {
    				attr_dev(button0, "title", button0_title_value);
    			}

    			if (!current || dirty & /*volumeWidth*/ 2 && span_data_value_value !== (span_data_value_value = Math.floor(/*volumeWidth*/ ctx[1]))) {
    				attr_dev(span, "data-value", span_data_value_value);
    			}

    			if (!current || dirty & /*volumeWidth*/ 2) {
    				set_style(span, "width", /*volumeWidth*/ ctx[1] + "%");
    			}

    			if (dirty & /*missingGainTags*/ 8) {
    				toggle_class(button1, "notification-dot", /*missingGainTags*/ ctx[3]);
    			}

    			if (/*menuIsVisible*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*menuIsVisible*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$z(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(svgtune.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(svgtune.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button1);
    			destroy_component(svgtune);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let $MediaPlayer;
    	let $CurrentSong;
    	let $IsMuted;
    	let $VolumeNormalizationEnabled;
    	let $DynamicsCompressorEnabled;
    	let $NowPlayingQueue;
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(4, $MediaPlayer = $$value));
    	validate_store(CurrentSong, "CurrentSong");
    	component_subscribe($$self, CurrentSong, $$value => $$invalidate(0, $CurrentSong = $$value));
    	validate_store(IsMuted, "IsMuted");
    	component_subscribe($$self, IsMuted, $$value => $$invalidate(5, $IsMuted = $$value));
    	validate_store(VolumeNormalizationEnabled, "VolumeNormalizationEnabled");
    	component_subscribe($$self, VolumeNormalizationEnabled, $$value => $$invalidate(6, $VolumeNormalizationEnabled = $$value));
    	validate_store(DynamicsCompressorEnabled, "DynamicsCompressorEnabled");
    	component_subscribe($$self, DynamicsCompressorEnabled, $$value => $$invalidate(7, $DynamicsCompressorEnabled = $$value));
    	validate_store(NowPlayingQueue, "NowPlayingQueue");
    	component_subscribe($$self, NowPlayingQueue, $$value => $$invalidate(8, $NowPlayingQueue = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player_volume", slots, []);
    	let volumeWidth = $MediaPlayer.globalVolume * 100;
    	let mouseDown = false;
    	let volumeSlider;
    	let menuIsVisible = false;
    	let missingGainTags;

    	function toggleMenu() {
    		$$invalidate(2, menuIsVisible = !menuIsVisible);
    	}

    	async function handleMuteToggle() {
    		if ($MediaPlayer.wavesurfer) {
    			IsMuted.set(!$IsMuted);
    			await tick();
    			$MediaPlayer.wavesurfer.setMute($MediaPlayer.isMuted);
    		}
    	}

    	function handleVolumeNormalize() {
    		let inverted = !$VolumeNormalizationEnabled;
    		localStorage.setItem("VolumeNormalizationEnabled", JSON.stringify(inverted));
    		VolumeNormalizationEnabled.set(inverted);
    		$MediaPlayer.updateFilters();
    	}

    	function handleDynamicsCompressor() {
    		let inverted = !$DynamicsCompressorEnabled;
    		localStorage.setItem("DynamicsCompressorEnabled", JSON.stringify(inverted));
    		DynamicsCompressorEnabled.set(inverted);
    		$MediaPlayer.updateFilters();
    	}

    	function handleVolumeSlider(event) {
    		let volumeElementWidth = event.target.offsetWidth;
    		let volumeClickLocation = event.clientX - event.target.getBoundingClientRect().left;
    		let volumeFraction = volumeClickLocation / volumeElementWidth;
    		$$invalidate(1, volumeWidth = volumeFraction * 100);
    		$$invalidate(1, volumeWidth = volumeWidth > 100 ? 100 : volumeWidth);
    		$$invalidate(1, volumeWidth = volumeWidth < 0 ? 0 : volumeWidth);

    		if ($MediaPlayer.wavesurfer) {
    			$MediaPlayer.wavesurfer.setVolume(Math.pow(volumeWidth / 100, 2)); // logarithmic volume control
    		}
    	}

    	function handleVolumeMouseDown(event) {
    		mouseDown = true;
    		document.addEventListener("mouseup", handleVolumeMouseUp);
    		volumeSlider.classList.add("dragging");
    	}

    	function handleVolumeMouseUp(event) {
    		mouseDown = false;
    		document.removeEventListener("mouseup", handleVolumeMouseUp);
    		volumeSlider.classList.remove("dragging");
    	}

    	function handleVolumeDrag(event) {
    		if (mouseDown) {
    			requestAnimationFrame(function () {
    				handleVolumeSlider(event);
    			});
    		}
    	}

    	onMount(() => {
    		volumeSlider = document.querySelector(".site-player__volume-slider");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player_volume> was created with unknown prop '${key}'`);
    	});

    	function input0_change_handler() {
    		$VolumeNormalizationEnabled = this.checked;
    		VolumeNormalizationEnabled.set($VolumeNormalizationEnabled);
    	}

    	function input1_change_handler() {
    		$DynamicsCompressorEnabled = this.checked;
    		DynamicsCompressorEnabled.set($DynamicsCompressorEnabled);
    	}

    	function menu_isVisible_binding(value) {
    		menuIsVisible = value;
    		$$invalidate(2, menuIsVisible);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		CurrentSong,
    		IsMuted,
    		NowPlayingQueue,
    		VolumeNormalizationEnabled,
    		DynamicsCompressorEnabled,
    		MediaPlayer,
    		Menu,
    		SVGVolumeUp: Volume_up,
    		SVGVolumeMuted: Volume_off,
    		SVGTune: Tune,
    		volumeWidth,
    		mouseDown,
    		volumeSlider,
    		menuIsVisible,
    		missingGainTags,
    		toggleMenu,
    		handleMuteToggle,
    		handleVolumeNormalize,
    		handleDynamicsCompressor,
    		handleVolumeSlider,
    		handleVolumeMouseDown,
    		handleVolumeMouseUp,
    		handleVolumeDrag,
    		$MediaPlayer,
    		$CurrentSong,
    		$IsMuted,
    		$VolumeNormalizationEnabled,
    		$DynamicsCompressorEnabled,
    		$NowPlayingQueue
    	});

    	$$self.$inject_state = $$props => {
    		if ("volumeWidth" in $$props) $$invalidate(1, volumeWidth = $$props.volumeWidth);
    		if ("mouseDown" in $$props) mouseDown = $$props.mouseDown;
    		if ("volumeSlider" in $$props) volumeSlider = $$props.volumeSlider;
    		if ("menuIsVisible" in $$props) $$invalidate(2, menuIsVisible = $$props.menuIsVisible);
    		if ("missingGainTags" in $$props) $$invalidate(3, missingGainTags = $$props.missingGainTags);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$CurrentSong*/ 1) {
    			$$invalidate(3, missingGainTags = $CurrentSong && !$CurrentSong.r128_track_gain && !$CurrentSong.replaygain_track_gain);
    		}
    	};

    	return [
    		$CurrentSong,
    		volumeWidth,
    		menuIsVisible,
    		missingGainTags,
    		$MediaPlayer,
    		$IsMuted,
    		$VolumeNormalizationEnabled,
    		$DynamicsCompressorEnabled,
    		$NowPlayingQueue,
    		toggleMenu,
    		handleMuteToggle,
    		handleVolumeNormalize,
    		handleDynamicsCompressor,
    		handleVolumeSlider,
    		handleVolumeMouseDown,
    		handleVolumeDrag,
    		input0_change_handler,
    		input1_change_handler,
    		menu_isVisible_binding
    	];
    }

    class Player_volume extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player_volume",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    let serverURL_value$2 = get_store_value(serverURL);

    /**
     * Make API request for playlist data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchPlaylistData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.playlist) ? data.playlist : data;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Get playlist by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getPlaylist = async (id) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getPlaylist");

        let playlist = await fetchPlaylistData(queryURL);
        playlist.useBackground = await placeholderArtCheck(playlist.art + "&thumb=10");

        let mp = get_store_value(MediaPlayer);
        await mp.setWaveColors();

        return playlist;
    };

    /**
     * Get playlist by name
     * @param {string} name
     * @returns {Promise<*>}
     */
    const getPlaylistByName = async (name) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlists&filter=" + encodeURI(name);
        queryURL += "&exact=1";
        queryURL += "&limit=1";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getPlaylistByName");

        let playlist = await fetchPlaylistData(queryURL);

        // convert into a single result
        playlist = playlist.length > 0 ? playlist[0] : [];

        return playlist;
    };

    /**
     * Get all playlists
     * @returns {Promise<*>}
     */
    const getPlaylists = () => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlists&hide_search=1";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getPlaylists");
        return fetchPlaylistData(queryURL);
    };

    /**
     * Get all smartlists (filtered from playlists)
     * @returns {Promise<*>}
     */
    const getSmartlists = () => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlists";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSmartlists");
        return fetchPlaylistData(queryURL)
            .then((result) => {
                result = result.filter(function(item) {
                    return item.id.match(/^smart_/);
                });

                return result;
            });
    };

    /**
     * Create a playlist
     * @param {string} name
     * @param {string} type
     * @returns {Promise<*>}
     */
    const createPlaylist = ({name = "Untitled", type = "public"}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist_create";
        queryURL += "&name=" + encodeURI(name);
        queryURL += "&type=" + type;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "createPlaylist");

        return fetchPlaylistData(queryURL);
    };

    /**
     * Edit an existing playlist
     * @param {number} id
     * @param {string} name
     * @param {string} type
     * @returns {Promise<*>}
     */
    const editPlaylist = ({id = '', name = "Untitled", type = "public"}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist_edit&filter=" + id;
        queryURL += "&name=" + encodeURI(name);
        queryURL += "&type=" + type;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "editPlaylist");

        return fetchPlaylistData(queryURL);
    };

    /**
     * Delete playlist by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const deletePlaylist = (id) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist_delete&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "deletePlaylist");

        return fetchPlaylistData(queryURL);
    };

    /**
     * Add song to playlist
     * @returns {Promise<*>}
     */
    const addToPlaylist = ({playlistID = '', songID = '', ignoreDuplicates = 0}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist_add_song";
        queryURL += "&filter=" + playlistID;
        queryURL += "&song=" + songID;
        queryURL += "&check=" + ignoreDuplicates;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "addToPlaylist");
        return fetchPlaylistData(queryURL);
    };

    /**
     * Remove song to playlist
     * @returns {Promise<*>}
     */
    const removeFromPlaylist = ({playlistID = '', trackNo = ''}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlist_remove_song";
        queryURL += "&filter=" + playlistID;
        queryURL += "&track=" + trackNo;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "removeFromPlaylist");
        return fetchPlaylistData(queryURL);
    };

    /**
     * Returns playlists for search
     * @param query
     * @param page
     * @param limit
     * @returns {Promise<*>}
     */
    const searchPlaylists = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlists&hide_search=1&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "searchPlaylists");
        return fetchPlaylistData(queryURL);
    };

    /**
     * Returns smartlists for search
     * @param query
     * @param page
     * @param limit
     * @returns {Promise<*>}
     */
    const searchSmartlists = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$2 + "/server/json.server.php?action=playlists&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "searchSmartlists");
        return fetchPlaylistData(queryURL)
            .then((result) => {
                result = result.filter(function(item) {
                    return item.id.match(/^smart_/);
                });

                return result;
            });
    };

    var playlist = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getPlaylist: getPlaylist,
        getPlaylistByName: getPlaylistByName,
        getPlaylists: getPlaylists,
        getSmartlists: getSmartlists,
        createPlaylist: createPlaylist,
        editPlaylist: editPlaylist,
        deletePlaylist: deletePlaylist,
        addToPlaylist: addToPlaylist,
        removeFromPlaylist: removeFromPlaylist,
        searchPlaylists: searchPlaylists,
        searchSmartlists: searchSmartlists
    });

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    let serverURL_value$1 = get_store_value(serverURL);

    /**
     * Make API request for song data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchSongData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    // if a single object is returned place into array so map works
                    let dataPlaceholder = (data.song) ? data.song : [data];

                    dataPlaceholder = dataPlaceholder.map((item, index) => ({ ...item, _id: v4()}));

                    return dataPlaceholder;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };

    /**
     * Get song by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getSong = (id) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=song&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSong");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from album ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getSongsFromAlbum = (id) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=album_songs&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromAlbum");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from artist ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getSongsFromArtist = async (id) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=artist_songs&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromArtist");

        let songs = await fetchSongData(queryURL);
        songs = sortSongsByYear(songs);

        return songs;
    };

    /**
     * Get top songs from artist ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getTopSongsFromArtist = (id) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=artist_songs&filter=" + id;
        queryURL += "&top50=1";
        queryURL += "&limit=20";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getTopSongsFromArtist");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from playlist ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getSongsFromPlaylist = (id) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=playlist_songs&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromPlaylist");
        return fetchSongData(queryURL);
    };

    /**
     * Get a single song from playlist ID
     * @param {number} playlistID
     * @param {number} songIndex
     * @param {number} limit
     * @returns {Promise<*>}
     */
    // TODO can probably refactor into getSongsFromPlaylist
    const getSongFromPlaylist = ({playlistID = '', songIndex = '', limit = 1}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=playlist_songs";
        queryURL += "&filter=" + playlistID;
        queryURL += "&offset=" + songIndex;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongFromPlaylist");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs through advanced search
     * @param {string} filterChar
     * @returns {Promise<*>}
     */
    const getSongsFromAdvancedSearch = ({rows = [], limit = 0, random = false, matchAll = true}) => {
        random = (random) ? 1 : 0;
        matchAll = (matchAll) ? "and" : "or";

        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=" + limit;
        queryURL += "&random=" + random;
        queryURL += "&type=song&operator=" + matchAll;

        for (let i = 0; i < rows.length; i++) {
            let counter = parseInt(i + 1);
            queryURL += `&rule_${counter}=${rows[i].field}&rule_${counter}_operator=${rows[i].operator}&rule_${counter}_input=${encodeURI(rows[i].input)}`;
        }

        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromAdvancedSearch");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from albums starting with specified character
     * @param {string} filterChar
     * @returns {Promise<*>}
     */
    const getSongsFromAlbumsStartingWith = (filterChar) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=album&rule_1_operator=8&rule_1_input=" + encodeURI('^(?!the\\s)') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromAlbumsStartingWith");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from artists starting with specified character
     * @param {string} filterChar
     * @returns {Promise<*>}
     */
    const getSongsFromArtistsStartingWith = (filterChar) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=artist&rule_1_operator=8&rule_1_input=" + encodeURI('^(?!the\\s)') + filterChar;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsFromArtistsStartingWith");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs by year range
     * @param {number} from
     * @param {number} to
     * @returns {Promise<*>}
     */
    const getSongsByYear = async (from, to) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=year&rule_1_operator=0&rule_1_input=" + from;
        queryURL += "&rule_2=year&rule_2_operator=1&rule_2_input=" + to;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSongsByYear");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs that have no rating
     * @returns {Promise<*>}
     */
    const unratedSongs = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&type=song&operator=and&random=1";
        queryURL += "&rule_1=myrating&rule_1_operator=2&rule_1_input=0";

        if (query) {
            queryURL += "&rule_2=title&rule_2_operator=8&rule_2_input=" + encodeURI(query);
        }

        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "unratedSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Returns songs for search
     * @param query
     * @param page
     * @param limit
     * @returns {Promise<*>}
     */
    const searchSongs = ({query = "", page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=songs&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "searchSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get newest songs
     * @returns {Promise<*>}
     */
    const newestSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=newest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "newestSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get recently played songs
     * @returns {Promise<*>}
     */
    const recentSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=recent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "recentSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get favorite songs
     * @returns {Promise<*>}
     */
    const favoriteSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=flagged";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "favoriteSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get frequent songs
     * @returns {Promise<*>}
     */
    const frequentSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=frequent";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "frequentSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get top rated songs
     * @returns {Promise<*>}
     */
    const topSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=highest";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "topSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get forgotten songs
     * @returns {Promise<*>}
     */
    const forgottenSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=forgotten";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "forgottenSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get random songs
     * @returns {Promise<*>}
     */
    const randomSongs = ({page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=stats&type=song&filter=random";
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "randomSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get genre songs (non-advanced search method)
     * @returns {Promise<*>}
     */
    const getGenreSongs = ({query, page = 0, limit = 50}) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=genre_songs&filter=" + query;
        queryURL += "&offset=" + page * limit;
        queryURL += "&limit=" + limit;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getGenreSongs");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs by genre
     * @param {string} genre
     * @returns {Promise<*>}
     */
    const getSomeSongsByGenre = (genre) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=tag&rule_1_operator=4&rule_1_input=" + genre;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSomeSongsByGenre");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from albums by genre
     * @param {string} genre
     * @returns {Promise<*>}
     */
    const getSomeSongsFromAlbumsByGenre = (genre) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=album_tag&rule_1_operator=4&rule_1_input=" + genre;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSomeSongsFromAlbumsByGenre");
        return fetchSongData(queryURL);
    };

    /**
     * Get songs from albums by genre
     * @param {string} genre
     * @returns {Promise<*>}
     */
    const getSomeSongsFromArtistsByGenre = (genre) => {
        let queryURL = serverURL_value$1 + "/server/json.server.php?action=advanced_search";
        queryURL += "&limit=200&random=1";
        queryURL += "&type=song&operator=and";
        queryURL += "&rule_1=artist_tag&rule_1_operator=4&rule_1_input=" + genre;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getSomeSongsFromArtistsByGenre");
        return fetchSongData(queryURL);
    };

    /**
     * Group album songs by disc
     * @param {array} songs
     * @returns {Map<any, any>}
     */
    const groupSongsByDisc = (songs) => {
        let discs = new Map();

        for (let i = 0; i < songs.length; i++) {
            let discID = songs[i].album.id;
            if (!discs.get(discID)) {
                discs.set(discID, []);
            }

            discs.get(discID).push(songs[i]);
        }

        return discs;
    };

    /**
     * Sort songs alphabetically
     * @param {array} songs
     * @returns {*}
     */
    const sortSongsByName = (songs) => {
        return songs.sort(function(obj1, obj2) { return obj1.name.localeCompare(obj2.name) })
    };

    /**
     * Sort songs by album
     * @param {array} songs
     * @returns {*}
     */
    const sortSongsByAlbum = (songs) => {
        return songs.sort(function(obj1, obj2) { return obj1.album.name.localeCompare(obj2.album.name) })
    };

    /**
     * Sort songs by rating
     * @param {array} songs
     * @returns {*}
     */
    const sortSongsByRating = (songs) => {
        return songs.sort(function(obj1, obj2) { return obj1.rating < obj2.rating })
    };

    /**
     * Sort songs from earliest to most recent
     * @param {array} songs
     * @returns {*}
     */
    const sortSongsByYear = (songs) => {
        songs = songs.sort(function(obj1, obj2) {
            // Sort by year
            if (obj1.year > obj2.year) return 1;
            if (obj1.year < obj2.year) return -1;

            // Group by release if same year
            if (obj1.album.name > obj2.album.name) return 1;
            if (obj1.album.name < obj2.album.name) return -1;
        });

        return songs;
    };

    var song = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getSong: getSong,
        getSongsFromAlbum: getSongsFromAlbum,
        getSongsFromArtist: getSongsFromArtist,
        getTopSongsFromArtist: getTopSongsFromArtist,
        getSongsFromPlaylist: getSongsFromPlaylist,
        getSongFromPlaylist: getSongFromPlaylist,
        getSongsFromAdvancedSearch: getSongsFromAdvancedSearch,
        getSongsFromAlbumsStartingWith: getSongsFromAlbumsStartingWith,
        getSongsFromArtistsStartingWith: getSongsFromArtistsStartingWith,
        getSongsByYear: getSongsByYear,
        unratedSongs: unratedSongs,
        searchSongs: searchSongs,
        newestSongs: newestSongs,
        recentSongs: recentSongs,
        favoriteSongs: favoriteSongs,
        frequentSongs: frequentSongs,
        topSongs: topSongs,
        forgottenSongs: forgottenSongs,
        randomSongs: randomSongs,
        getGenreSongs: getGenreSongs,
        getSomeSongsByGenre: getSomeSongsByGenre,
        getSomeSongsFromAlbumsByGenre: getSomeSongsFromAlbumsByGenre,
        getSomeSongsFromArtistsByGenre: getSomeSongsFromArtistsByGenre,
        groupSongsByDisc: groupSongsByDisc,
        sortSongsByName: sortSongsByName,
        sortSongsByAlbum: sortSongsByAlbum,
        sortSongsByRating: sortSongsByRating,
        sortSongsByYear: sortSongsByYear
    });

    /* src\components\playlists\playlist_edit.svelte generated by Svelte v3.38.3 */

    const file$N = "src\\components\\playlists\\playlist_edit.svelte";

    function create_fragment$15(ctx) {
    	let div3;
    	let h4;
    	let t0_value = (/*isNew*/ ctx[0] ? "New" : "Edit") + "";
    	let t0;
    	let t1;
    	let t2;
    	let label0;
    	let t3;
    	let input0;
    	let t4;
    	let div0;
    	let label1;
    	let input1;
    	let t5;
    	let t6;
    	let label2;
    	let input2;
    	let t7;
    	let t8;
    	let div1;
    	let button0;
    	let t10;
    	let button1;
    	let t11_value = (/*isNew*/ ctx[0] ? "Create" : "Update") + "";
    	let t11;
    	let t12;
    	let div2;
    	let t13;
    	let em;
    	let t14;
    	let t15;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = text(" playlist");
    			t2 = space();
    			label0 = element("label");
    			t3 = text("Name\r\n        ");
    			input0 = element("input");
    			t4 = space();
    			div0 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t5 = text("\r\n            Private");
    			t6 = space();
    			label2 = element("label");
    			input2 = element("input");
    			t7 = text("\r\n            Public");
    			t8 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t10 = space();
    			button1 = element("button");
    			t11 = text(t11_value);
    			t12 = space();
    			div2 = element("div");
    			t13 = text("Playlist ");
    			em = element("em");
    			t14 = text(/*playlistName*/ ctx[1]);
    			t15 = text(" already exists");
    			attr_dev(h4, "class", "svelte-754pqf");
    			add_location(h4, file$N, 57, 4, 1801);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "svelte-754pqf");
    			add_location(input0, file$N, 61, 8, 1895);
    			attr_dev(label0, "class", "name svelte-754pqf");
    			add_location(label0, file$N, 59, 4, 1851);
    			attr_dev(input1, "type", "radio");
    			input1.__value = "private";
    			input1.value = input1.__value;
    			/*$$binding_groups*/ ctx[11][0].push(input1);
    			add_location(input1, file$N, 71, 12, 2133);
    			add_location(label1, file$N, 70, 8, 2112);
    			attr_dev(input2, "type", "radio");
    			input2.__value = "public";
    			input2.value = input2.__value;
    			/*$$binding_groups*/ ctx[11][0].push(input2);
    			add_location(input2, file$N, 76, 12, 2269);
    			add_location(label2, file$N, 75, 8, 2248);
    			attr_dev(div0, "class", "types svelte-754pqf");
    			add_location(div0, file$N, 69, 4, 2083);
    			attr_dev(button0, "class", "");
    			add_location(button0, file$N, 82, 8, 2421);
    			attr_dev(button1, "class", "submit primary svelte-754pqf");
    			add_location(button1, file$N, 84, 8, 2489);
    			attr_dev(div1, "class", "actions svelte-754pqf");
    			add_location(div1, file$N, 81, 4, 2390);
    			add_location(em, file$N, 92, 79, 2745);
    			attr_dev(div2, "class", "message badge warning svelte-754pqf");
    			toggle_class(div2, "visible", /*playlistExists*/ ctx[3]);
    			add_location(div2, file$N, 92, 4, 2670);
    			attr_dev(div3, "class", "container svelte-754pqf");
    			add_location(div3, file$N, 56, 0, 1772);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(div3, t2);
    			append_dev(div3, label0);
    			append_dev(label0, t3);
    			append_dev(label0, input0);
    			set_input_value(input0, /*playlistName*/ ctx[1]);
    			append_dev(div3, t4);
    			append_dev(div3, div0);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			input1.checked = input1.__value === /*playlistType*/ ctx[2];
    			append_dev(label1, t5);
    			append_dev(div0, t6);
    			append_dev(div0, label2);
    			append_dev(label2, input2);
    			input2.checked = input2.__value === /*playlistType*/ ctx[2];
    			append_dev(label2, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t10);
    			append_dev(div1, button1);
    			append_dev(button1, t11);
    			append_dev(div3, t12);
    			append_dev(div3, div2);
    			append_dev(div2, t13);
    			append_dev(div2, em);
    			append_dev(em, t14);
    			append_dev(div2, t15);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    					listen_dev(input0, "paste", /*handleInputChange*/ ctx[5], false, false, false),
    					listen_dev(input0, "keyup", /*handleInputChange*/ ctx[5], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[10]),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[12]),
    					listen_dev(button0, "click", /*handleCancel*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*savePlaylist*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isNew*/ 1 && t0_value !== (t0_value = (/*isNew*/ ctx[0] ? "New" : "Edit") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*playlistName*/ 2 && input0.value !== /*playlistName*/ ctx[1]) {
    				set_input_value(input0, /*playlistName*/ ctx[1]);
    			}

    			if (dirty & /*playlistType*/ 4) {
    				input1.checked = input1.__value === /*playlistType*/ ctx[2];
    			}

    			if (dirty & /*playlistType*/ 4) {
    				input2.checked = input2.__value === /*playlistType*/ ctx[2];
    			}

    			if (dirty & /*isNew*/ 1 && t11_value !== (t11_value = (/*isNew*/ ctx[0] ? "Create" : "Update") + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*playlistName*/ 2) set_data_dev(t14, /*playlistName*/ ctx[1]);

    			if (dirty & /*playlistExists*/ 8) {
    				toggle_class(div2, "visible", /*playlistExists*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*$$binding_groups*/ ctx[11][0].splice(/*$$binding_groups*/ ctx[11][0].indexOf(input1), 1);
    			/*$$binding_groups*/ ctx[11][0].splice(/*$$binding_groups*/ ctx[11][0].indexOf(input2), 1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlist_edit", slots, []);
    	let { playlist = null } = $$props;
    	let { isNew = false } = $$props;
    	let { isVisible } = $$props;
    	let playlistName = playlist ? playlist.name : "";
    	let playlistType = playlist ? playlist.type : "private";
    	let playlistExists;

    	async function savePlaylist() {
    		$$invalidate(3, playlistExists = false);
    		$$invalidate(1, playlistName = playlistName.trim());

    		if (playlistName && playlistType) {
    			let playlistTest = await getPlaylistByName(playlistName);

    			if (isNew) {
    				if (playlistTest && playlistTest.id) {
    					$$invalidate(3, playlistExists = true);
    					return;
    				}

    				$$invalidate(7, playlist = await createPlaylist({ name: playlistName, type: playlistType }));
    				$$invalidate(8, isVisible = false);
    			} else {
    				if (playlistTest && playlistTest.id && playlistTest.id !== playlist.id) {
    					$$invalidate(3, playlistExists = true);
    					return;
    				}

    				let result = await editPlaylist({
    					id: playlist.id,
    					name: playlistName,
    					type: playlistType
    				});

    				if (result.success) {
    					let tempPlaylist = await getPlaylist(playlist.id);

    					if (playlist.isNew) {
    						tempPlaylist.isNew = true;
    					}

    					$$invalidate(7, playlist = tempPlaylist);
    					$$invalidate(8, isVisible = false);
    				}
    			}
    		}
    	}

    	function handleInputChange() {
    		$$invalidate(3, playlistExists = false);
    	}

    	function handleCancel() {
    		$$invalidate(8, isVisible = false);
    	}

    	const writable_props = ["playlist", "isNew", "isVisible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlist_edit> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function input0_input_handler() {
    		playlistName = this.value;
    		$$invalidate(1, playlistName);
    	}

    	function input1_change_handler() {
    		playlistType = this.__value;
    		$$invalidate(2, playlistType);
    	}

    	function input2_change_handler() {
    		playlistType = this.__value;
    		$$invalidate(2, playlistType);
    	}

    	$$self.$$set = $$props => {
    		if ("playlist" in $$props) $$invalidate(7, playlist = $$props.playlist);
    		if ("isNew" in $$props) $$invalidate(0, isNew = $$props.isNew);
    		if ("isVisible" in $$props) $$invalidate(8, isVisible = $$props.isVisible);
    	};

    	$$self.$capture_state = () => ({
    		createPlaylist,
    		editPlaylist,
    		getPlaylist,
    		getPlaylistByName,
    		playlist,
    		isNew,
    		isVisible,
    		playlistName,
    		playlistType,
    		playlistExists,
    		savePlaylist,
    		handleInputChange,
    		handleCancel
    	});

    	$$self.$inject_state = $$props => {
    		if ("playlist" in $$props) $$invalidate(7, playlist = $$props.playlist);
    		if ("isNew" in $$props) $$invalidate(0, isNew = $$props.isNew);
    		if ("isVisible" in $$props) $$invalidate(8, isVisible = $$props.isVisible);
    		if ("playlistName" in $$props) $$invalidate(1, playlistName = $$props.playlistName);
    		if ("playlistType" in $$props) $$invalidate(2, playlistType = $$props.playlistType);
    		if ("playlistExists" in $$props) $$invalidate(3, playlistExists = $$props.playlistExists);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isNew,
    		playlistName,
    		playlistType,
    		playlistExists,
    		savePlaylist,
    		handleInputChange,
    		handleCancel,
    		playlist,
    		isVisible,
    		input0_input_handler,
    		input1_change_handler,
    		$$binding_groups,
    		input2_change_handler
    	];
    }

    class Playlist_edit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, { playlist: 7, isNew: 0, isVisible: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlist_edit",
    			options,
    			id: create_fragment$15.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isVisible*/ ctx[8] === undefined && !("isVisible" in props)) {
    			console.warn("<Playlist_edit> was created without expected prop 'isVisible'");
    		}
    	}

    	get playlist() {
    		throw new Error("<Playlist_edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playlist(value) {
    		throw new Error("<Playlist_edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNew() {
    		throw new Error("<Playlist_edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNew(value) {
    		throw new Error("<Playlist_edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVisible() {
    		throw new Error("<Playlist_edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVisible(value) {
    		throw new Error("<Playlist_edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\playlists\playlist_selector.svelte generated by Svelte v3.38.3 */
    const file$M = "src\\components\\playlists\\playlist_selector.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (82:4) {:else}
    function create_else_block$n(ctx) {
    	let t0;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let ul;
    	let t3;
    	let p;
    	let t4;
    	let mounted;
    	let dispose;
    	let if_block0 = /*type*/ ctx[1] === "playlists" && create_if_block_3$e(ctx);
    	let if_block1 = /*filteredList*/ ctx[4].length > 0 && create_if_block_2$l(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*selectedPlaylist*/ ctx[0]) return create_if_block_1$p;
    		return create_else_block_1$9;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block2 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			label = element("label");
    			t1 = text("Filter:\r\n            ");
    			input = element("input");
    			t2 = space();
    			ul = element("ul");
    			if (if_block1) if_block1.c();
    			t3 = space();
    			p = element("p");
    			t4 = text("Selected:\r\n            ");
    			if_block2.c();
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "filter svelte-it8nc3");
    			add_location(input, file$M, 88, 12, 2432);
    			attr_dev(label, "class", "filter svelte-it8nc3");
    			add_location(label, file$M, 86, 8, 2375);
    			attr_dev(ul, "class", "playlists svelte-it8nc3");
    			add_location(ul, file$M, 91, 8, 2518);
    			attr_dev(p, "class", "current svelte-it8nc3");
    			add_location(p, file$M, 101, 8, 2981);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label, anchor);
    			append_dev(label, t1);
    			append_dev(label, input);
    			set_input_value(input, /*search*/ ctx[2]);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, ul, anchor);
    			if (if_block1) if_block1.m(ul, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t4);
    			if_block2.m(p, null);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*type*/ ctx[1] === "playlists") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$e(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*search*/ 4 && input.value !== /*search*/ ctx[2]) {
    				set_input_value(input, /*search*/ ctx[2]);
    			}

    			if (/*filteredList*/ ctx[4].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$l(ctx);
    					if_block1.c();
    					if_block1.m(ul, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(p, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(ul);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p);
    			if_block2.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(82:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (78:4) {#if showPlaylistCreation}
    function create_if_block$y(ctx) {
    	let div;
    	let playlistedit;
    	let updating_playlist;
    	let updating_isVisible;
    	let current;

    	function playlistedit_playlist_binding(value) {
    		/*playlistedit_playlist_binding*/ ctx[9](value);
    	}

    	function playlistedit_isVisible_binding(value) {
    		/*playlistedit_isVisible_binding*/ ctx[10](value);
    	}

    	let playlistedit_props = { isNew: true };

    	if (/*newPlaylist*/ ctx[3] !== void 0) {
    		playlistedit_props.playlist = /*newPlaylist*/ ctx[3];
    	}

    	if (/*showPlaylistCreation*/ ctx[5] !== void 0) {
    		playlistedit_props.isVisible = /*showPlaylistCreation*/ ctx[5];
    	}

    	playlistedit = new Playlist_edit({
    			props: playlistedit_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistedit, "playlist", playlistedit_playlist_binding));
    	binding_callbacks.push(() => bind(playlistedit, "isVisible", playlistedit_isVisible_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(playlistedit.$$.fragment);
    			attr_dev(div, "class", "nested svelte-it8nc3");
    			add_location(div, file$M, 78, 8, 2031);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(playlistedit, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistedit_changes = {};

    			if (!updating_playlist && dirty & /*newPlaylist*/ 8) {
    				updating_playlist = true;
    				playlistedit_changes.playlist = /*newPlaylist*/ ctx[3];
    				add_flush_callback(() => updating_playlist = false);
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistCreation*/ 32) {
    				updating_isVisible = true;
    				playlistedit_changes.isVisible = /*showPlaylistCreation*/ ctx[5];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			playlistedit.$set(playlistedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(playlistedit);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(78:4) {#if showPlaylistCreation}",
    		ctx
    	});

    	return block;
    }

    // (83:8) {#if type === "playlists"}
    function create_if_block_3$e(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "New playlist";
    			attr_dev(button, "id", "js-playlistsNewFromAdd");
    			attr_dev(button, "class", "addNew primary svelte-it8nc3");
    			add_location(button, file$M, 83, 12, 2239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleNewPlaylist*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$e.name,
    		type: "if",
    		source: "(83:8) {#if type === \\\"playlists\\\"}",
    		ctx
    	});

    	return block;
    }

    // (93:12) {#if filteredList.length > 0}
    function create_if_block_2$l(ctx) {
    	let each_1_anchor;
    	let each_value = /*filteredList*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filteredList, selectedPlaylist, handleSelection*/ 81) {
    				each_value = /*filteredList*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$l.name,
    		type: "if",
    		source: "(93:12) {#if filteredList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (94:16) {#each filteredList as item}
    function create_each_block$d(ctx) {
    	let li;
    	let span;
    	let t0_value = /*item*/ ctx[14].name + "";
    	let t0;
    	let span_title_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "class", "inner svelte-it8nc3");
    			attr_dev(span, "title", span_title_value = /*item*/ ctx[14].name);
    			add_location(span, file$M, 95, 24, 2825);
    			attr_dev(li, "class", "item svelte-it8nc3");
    			toggle_class(li, "highlight", /*item*/ ctx[14].isNew);
    			toggle_class(li, "selected", /*selectedPlaylist*/ ctx[0] && /*selectedPlaylist*/ ctx[0].id === /*item*/ ctx[14].id);
    			add_location(li, file$M, 94, 20, 2651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(
    					li,
    					"click",
    					function () {
    						if (is_function(/*handleSelection*/ ctx[6](/*item*/ ctx[14]))) /*handleSelection*/ ctx[6](/*item*/ ctx[14]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*filteredList*/ 16 && t0_value !== (t0_value = /*item*/ ctx[14].name + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*filteredList*/ 16 && span_title_value !== (span_title_value = /*item*/ ctx[14].name)) {
    				attr_dev(span, "title", span_title_value);
    			}

    			if (dirty & /*filteredList*/ 16) {
    				toggle_class(li, "highlight", /*item*/ ctx[14].isNew);
    			}

    			if (dirty & /*selectedPlaylist, filteredList*/ 17) {
    				toggle_class(li, "selected", /*selectedPlaylist*/ ctx[0] && /*selectedPlaylist*/ ctx[0].id === /*item*/ ctx[14].id);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(94:16) {#each filteredList as item}",
    		ctx
    	});

    	return block;
    }

    // (106:12) {:else}
    function create_else_block_1$9(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "No playlist selected";
    			attr_dev(span, "class", "inner badge svelte-it8nc3");
    			add_location(span, file$M, 106, 16, 3244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$9.name,
    		type: "else",
    		source: "(106:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (104:12) {#if selectedPlaylist}
    function create_if_block_1$p(ctx) {
    	let span;
    	let t_value = /*selectedPlaylist*/ ctx[0].name + "";
    	let t;
    	let span_title_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "inner goto badge info svelte-it8nc3");
    			attr_dev(span, "title", span_title_value = /*selectedPlaylist*/ ctx[0].name);
    			add_location(span, file$M, 104, 16, 3077);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", handleGoToSelected, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedPlaylist*/ 1 && t_value !== (t_value = /*selectedPlaylist*/ ctx[0].name + "")) set_data_dev(t, t_value);

    			if (dirty & /*selectedPlaylist*/ 1 && span_title_value !== (span_title_value = /*selectedPlaylist*/ ctx[0].name)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$p.name,
    		type: "if",
    		source: "(104:12) {#if selectedPlaylist}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$14(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$y, create_else_block$n];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*showPlaylistCreation*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "container");
    			add_location(div, file$M, 76, 0, 1966);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleGoToSelected() {
    	document.querySelector(".playlists .selected").scrollIntoView({ behavior: "smooth" });
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlist_selector", slots, []);
    	let { type } = $$props;
    	let { selectedPlaylist } = $$props;
    	const dispatch = createEventDispatcher();
    	let search = "";
    	let filteredList;
    	let playlistItems = [];
    	let showPlaylistCreation = false;
    	let newPlaylist;

    	async function handleSelection(playlist) {
    		// test if selected playlist is still valid (i.e. not deleted)
    		let testPlaylist = await getPlaylist(playlist.id);

    		// if invalid, remove from the list and reload the playlists
    		if (!testPlaylist.id) {
    			await loadData();
    			$$invalidate(0, selectedPlaylist = null);
    			dispatch("cleared");
    			return;
    		}

    		$$invalidate(0, selectedPlaylist = playlist);
    		dispatch("selected");
    	}

    	function handleNewPlaylist() {
    		$$invalidate(5, showPlaylistCreation = !showPlaylistCreation);
    	}

    	async function loadData() {
    		if (type === "smartlists") {
    			$$invalidate(8, playlistItems = await getSmartlists());
    		} else {
    			$$invalidate(8, playlistItems = await getPlaylists());
    		}
    	}

    	onMount(() => {
    		loadData();
    	});

    	const writable_props = ["type", "selectedPlaylist"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlist_selector> was created with unknown prop '${key}'`);
    	});

    	function playlistedit_playlist_binding(value) {
    		newPlaylist = value;
    		($$invalidate(3, newPlaylist), $$invalidate(8, playlistItems));
    	}

    	function playlistedit_isVisible_binding(value) {
    		showPlaylistCreation = value;
    		(($$invalidate(5, showPlaylistCreation), $$invalidate(3, newPlaylist)), $$invalidate(8, playlistItems));
    	}

    	function input_input_handler() {
    		search = this.value;
    		$$invalidate(2, search);
    	}

    	$$self.$$set = $$props => {
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("selectedPlaylist" in $$props) $$invalidate(0, selectedPlaylist = $$props.selectedPlaylist);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		getSmartlists,
    		getPlaylists,
    		getPlaylist,
    		PlaylistEdit: Playlist_edit,
    		type,
    		selectedPlaylist,
    		dispatch,
    		search,
    		filteredList,
    		playlistItems,
    		showPlaylistCreation,
    		newPlaylist,
    		handleSelection,
    		handleGoToSelected,
    		handleNewPlaylist,
    		loadData
    	});

    	$$self.$inject_state = $$props => {
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("selectedPlaylist" in $$props) $$invalidate(0, selectedPlaylist = $$props.selectedPlaylist);
    		if ("search" in $$props) $$invalidate(2, search = $$props.search);
    		if ("filteredList" in $$props) $$invalidate(4, filteredList = $$props.filteredList);
    		if ("playlistItems" in $$props) $$invalidate(8, playlistItems = $$props.playlistItems);
    		if ("showPlaylistCreation" in $$props) $$invalidate(5, showPlaylistCreation = $$props.showPlaylistCreation);
    		if ("newPlaylist" in $$props) $$invalidate(3, newPlaylist = $$props.newPlaylist);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*newPlaylist, playlistItems*/ 264) {
    			{
    				if (newPlaylist) {
    					$$invalidate(3, newPlaylist.isNew = true, newPlaylist);
    					$$invalidate(8, playlistItems = [newPlaylist, ...playlistItems]);

    					// reset
    					$$invalidate(3, newPlaylist = null);

    					$$invalidate(5, showPlaylistCreation = false);
    				}

    				($$invalidate(8, playlistItems), $$invalidate(3, newPlaylist));
    			}
    		}

    		if ($$self.$$.dirty & /*playlistItems, search*/ 260) {
    			$$invalidate(4, filteredList = playlistItems.filter(item => item.name.toLocaleLowerCase().indexOf(search) !== -1));
    		}
    	};

    	return [
    		selectedPlaylist,
    		type,
    		search,
    		newPlaylist,
    		filteredList,
    		showPlaylistCreation,
    		handleSelection,
    		handleNewPlaylist,
    		playlistItems,
    		playlistedit_playlist_binding,
    		playlistedit_isVisible_binding,
    		input_input_handler
    	];
    }

    class Playlist_selector extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { type: 1, selectedPlaylist: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlist_selector",
    			options,
    			id: create_fragment$14.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<Playlist_selector> was created without expected prop 'type'");
    		}

    		if (/*selectedPlaylist*/ ctx[0] === undefined && !("selectedPlaylist" in props)) {
    			console.warn("<Playlist_selector> was created without expected prop 'selectedPlaylist'");
    		}
    	}

    	get type() {
    		throw new Error("<Playlist_selector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Playlist_selector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedPlaylist() {
    		throw new Error("<Playlist_selector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedPlaylist(value) {
    		throw new Error("<Playlist_selector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\queue.svg generated by Svelte v3.38.3 */

    function create_fragment$13(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "18px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "18px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M3 6c-.55 0-1 .45-1 1v13c0 1.1.9 2 2 2h13c.55 0 1-.45 1-1s-.45-1-1-1H5c-.55 0-1-.45-1-1V7c0-.55-.45-1-1-1zm17-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 9h-3v3c0 .55-.45 1-1 1s-1-.45-1-1v-3h-3c-.55 0-1-.45-1-1s.45-1 1-1h3V6c0-.55.45-1 1-1s1 .45 1 1v3h3c.55 0 1 .45 1 1s-.45 1-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "18px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "18px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$13($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Queue extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});
    	}
    }

    /* src\components\player\player_autoPlay.svelte generated by Svelte v3.38.3 */
    const file$L = "src\\components\\player\\player_autoPlay.svelte";

    // (78:0) {#if isVisible}
    function create_if_block$x(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[12](value);
    	}

    	let menu_props = {
    		anchor: "top-center",
    		toggleElement: document.querySelector("#autoPlayMenu"),
    		$$slots: { default: [create_default_slot$o] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, selectedPlaylist, $AutoPlayEnabled*/ 16387) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(78:0) {#if isVisible}",
    		ctx
    	});

    	return block;
    }

    // (79:4) <Menu anchor="top-center" toggleElement={document.querySelector("#autoPlayMenu")} bind:isVisible >
    function create_default_slot$o(ctx) {
    	let div1;
    	let div0;
    	let h4;
    	let t1;
    	let label;
    	let input;
    	let t2;
    	let t3;
    	let playlistselector;
    	let updating_selectedPlaylist;
    	let current;
    	let mounted;
    	let dispose;

    	function playlistselector_selectedPlaylist_binding(value) {
    		/*playlistselector_selectedPlaylist_binding*/ ctx[11](value);
    	}

    	let playlistselector_props = { type: "smartlists" };

    	if (/*selectedPlaylist*/ ctx[0] !== void 0) {
    		playlistselector_props.selectedPlaylist = /*selectedPlaylist*/ ctx[0];
    	}

    	playlistselector = new Playlist_selector({
    			props: playlistselector_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistselector, "selectedPlaylist", playlistselector_selectedPlaylist_binding));
    	playlistselector.$on("selected", /*handleSelected*/ ctx[3]);
    	playlistselector.$on("cleared", /*handleCleared*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Smartlist AutoPlay";
    			t1 = space();
    			label = element("label");
    			input = element("input");
    			t2 = text("\r\n                    Enable");
    			t3 = space();
    			create_component(playlistselector.$$.fragment);
    			add_location(h4, file$L, 81, 16, 2710);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$L, 84, 20, 2801);
    			attr_dev(label, "class", "toggle svelte-1uqbtnl");
    			add_location(label, file$L, 83, 16, 2757);
    			attr_dev(div0, "class", "header svelte-1uqbtnl");
    			add_location(div0, file$L, 80, 12, 2672);
    			attr_dev(div1, "class", "wrapper svelte-1uqbtnl");
    			add_location(div1, file$L, 79, 8, 2637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h4);
    			append_dev(div0, t1);
    			append_dev(div0, label);
    			append_dev(label, input);
    			input.checked = /*$AutoPlayEnabled*/ ctx[1];
    			append_dev(label, t2);
    			append_dev(div1, t3);
    			mount_component(playlistselector, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*toggleEnabled*/ ctx[5], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$AutoPlayEnabled*/ 2) {
    				input.checked = /*$AutoPlayEnabled*/ ctx[1];
    			}

    			const playlistselector_changes = {};

    			if (!updating_selectedPlaylist && dirty & /*selectedPlaylist*/ 1) {
    				updating_selectedPlaylist = true;
    				playlistselector_changes.selectedPlaylist = /*selectedPlaylist*/ ctx[0];
    				add_flush_callback(() => updating_selectedPlaylist = false);
    			}

    			playlistselector.$set(playlistselector_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistselector.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistselector.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(playlistselector);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(79:4) <Menu anchor=\\\"top-center\\\" toggleElement={document.querySelector(\\\"#autoPlayMenu\\\")} bind:isVisible >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let button;
    	let svgautoplay;
    	let t;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	svgautoplay = new Queue({ $$inline: true });
    	let if_block = /*isVisible*/ ctx[2] && create_if_block$x(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(svgautoplay.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button, "id", "autoPlayMenu");
    			attr_dev(button, "class", "icon");
    			attr_dev(button, "title", "Smartlist AutoPlay");
    			add_location(button, file$L, 68, 0, 2362);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(svgautoplay, button, null);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleMenu*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isVisible*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isVisible*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgautoplay.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgautoplay.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(svgautoplay);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let $NowPlayingQueue;
    	let $AutoPlayEnabled;
    	let $NowPlayingIndex;
    	let $MediaPlayer;
    	let $AutoPlayPlaylist;
    	validate_store(NowPlayingQueue, "NowPlayingQueue");
    	component_subscribe($$self, NowPlayingQueue, $$value => $$invalidate(7, $NowPlayingQueue = $$value));
    	validate_store(AutoPlayEnabled, "AutoPlayEnabled");
    	component_subscribe($$self, AutoPlayEnabled, $$value => $$invalidate(1, $AutoPlayEnabled = $$value));
    	validate_store(NowPlayingIndex, "NowPlayingIndex");
    	component_subscribe($$self, NowPlayingIndex, $$value => $$invalidate(8, $NowPlayingIndex = $$value));
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(9, $MediaPlayer = $$value));
    	validate_store(AutoPlayPlaylist, "AutoPlayPlaylist");
    	component_subscribe($$self, AutoPlayPlaylist, $$value => $$invalidate(13, $AutoPlayPlaylist = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player_autoPlay", slots, []);
    	let isVisible = false;
    	let selectedPlaylist;

    	function handleSelected() {
    		localStorage.setItem("AutoPlayPlaylist", JSON.stringify(selectedPlaylist.id));
    		AutoPlayPlaylist.set(selectedPlaylist.id);
    	}

    	function handleCleared() {
    		AutoPlayPlaylist.set(null);
    		localStorage.setItem("AutoPlayPlaylist", JSON.stringify(null));
    	}

    	function toggleEnabled() {
    		let inverted = !$AutoPlayEnabled;
    		localStorage.setItem("AutoPlayEnabled", JSON.stringify(inverted));
    		AutoPlayEnabled.set(inverted);
    	}

    	function toggleMenu() {
    		$$invalidate(2, isVisible = !isVisible);
    	}

    	onMount(async () => {
    		// load from localstorage
    		if ($AutoPlayPlaylist) {
    			$$invalidate(0, selectedPlaylist = await getPlaylist($AutoPlayPlaylist));
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player_autoPlay> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		$AutoPlayEnabled = this.checked;
    		AutoPlayEnabled.set($AutoPlayEnabled);
    	}

    	function playlistselector_selectedPlaylist_binding(value) {
    		selectedPlaylist = value;
    		$$invalidate(0, selectedPlaylist);
    	}

    	function menu_isVisible_binding(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		MediaPlayer,
    		NowPlayingIndex,
    		NowPlayingQueue,
    		AutoPlayEnabled,
    		AutoPlayPlaylist,
    		getPlaylist,
    		getSongsFromPlaylist,
    		PlaylistSelector: Playlist_selector,
    		Menu,
    		SVGAutoPlay: Queue,
    		isVisible,
    		selectedPlaylist,
    		handleSelected,
    		handleCleared,
    		toggleEnabled,
    		toggleMenu,
    		$NowPlayingQueue,
    		$AutoPlayEnabled,
    		$NowPlayingIndex,
    		$MediaPlayer,
    		$AutoPlayPlaylist
    	});

    	$$self.$inject_state = $$props => {
    		if ("isVisible" in $$props) $$invalidate(2, isVisible = $$props.isVisible);
    		if ("selectedPlaylist" in $$props) $$invalidate(0, selectedPlaylist = $$props.selectedPlaylist);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$NowPlayingQueue, $AutoPlayEnabled, selectedPlaylist, $NowPlayingIndex, $MediaPlayer*/ 899) {
    			{
    				// load more songs into queue from AutoPlay
    				if ($NowPlayingQueue.length > 0 && $AutoPlayEnabled && selectedPlaylist) {
    					// when we reach less than 10 songs remaining
    					if ($NowPlayingIndex > $NowPlayingQueue.length - 10) {
    						getSongsFromPlaylist(selectedPlaylist.id).then(result => {
    							if (!result.error && result.length > 0) {
    								result = Array.isArray(result) ? result : [result];

    								// let queue know these are autoloaded
    								result.forEach(function (element) {
    									element.fromAutoPlay = "true";
    								});

    								$MediaPlayer.playLast(result);
    							}
    						});
    					}
    				}
    			}
    		}
    	};

    	return [
    		selectedPlaylist,
    		$AutoPlayEnabled,
    		isVisible,
    		handleSelected,
    		handleCleared,
    		toggleEnabled,
    		toggleMenu,
    		$NowPlayingQueue,
    		$NowPlayingIndex,
    		$MediaPlayer,
    		input_change_handler,
    		playlistselector_selectedPlaylist_binding,
    		menu_isVisible_binding
    	];
    }

    class Player_autoPlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player_autoPlay",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    /* public\images\play.svg generated by Svelte v3.38.3 */

    function create_fragment$11(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.69L9.54 5.98C8.87 5.55 8 6.03 8 6.82z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$11($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Play extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {});
    	}
    }

    /* public\images\pause.svg generated by Svelte v3.38.3 */

    function create_fragment$10(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M8 19c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2s-2 .9-2 2v10c0 1.1.9 2 2 2zm6-12v10c0 1.1.9 2 2 2s2-.9 2-2V7c0-1.1-.9-2-2-2s-2 .9-2 2z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$10($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Pause extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {});
    	}
    }

    /* public\images\skip_next.svg generated by Svelte v3.38.3 */

    function create_fragment$$(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M7.58 16.89l5.77-4.07c.56-.4.56-1.24 0-1.63L7.58 7.11C6.91 6.65 6 7.12 6 7.93v8.14c0 .81.91 1.28 1.58.82zM16 7v10c0 .55.45 1 1 1s1-.45 1-1V7c0-.55-.45-1-1-1s-1 .45-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$$($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Skip_next extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});
    	}
    }

    /* public\images\skip_previous.svg generated by Svelte v3.38.3 */

    function create_fragment$_(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M7 6c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1s-1-.45-1-1V7c0-.55.45-1 1-1zm3.66 6.82l5.77 4.07c.66.47 1.58-.01 1.58-.82V7.93c0-.81-.91-1.28-1.58-.82l-5.77 4.07c-.57.4-.57 1.24 0 1.64z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$_($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Skip_previous extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});
    	}
    }

    /* public\images\shuffle.svg generated by Svelte v3.38.3 */

    function create_fragment$Z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M10.59 9.17L6.12 4.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l4.46 4.46 1.42-1.4zm4.76-4.32l1.19 1.19L4.7 17.88c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L17.96 7.46l1.19 1.19c.31.31.85.09.85-.36V4.5c0-.28-.22-.5-.5-.5h-3.79c-.45 0-.67.54-.36.85zm-.52 8.56l-1.41 1.41 3.13 3.13-1.2 1.2c-.31.31-.09.85.36.85h3.79c.28 0 .5-.22.5-.5v-3.79c0-.45-.54-.67-.85-.35l-1.19 1.19-3.13-3.14z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Shuffle extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});
    	}
    }

    /* public\images\repeat.svg generated by Svelte v3.38.3 */

    function create_fragment$Y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M7 7h10v1.79c0 .45.54.67.85.35l2.79-2.79c.2-.2.2-.51 0-.71l-2.79-2.79c-.31-.31-.85-.09-.85.36V5H6c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1s1-.45 1-1V7zm10 10H7v-1.79c0-.45-.54-.67-.85-.35l-2.79 2.79c-.2.2-.2.51 0 .71l2.79 2.79c.31.31.85.09.85-.36V19h11c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1s-1 .45-1 1v3z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Repeat extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});
    	}
    }

    /* src\components\player\player.svelte generated by Svelte v3.38.3 */
    const file$K = "src\\components\\player\\player.svelte";

    // (62:12) {:else}
    function create_else_block_1$8(ctx) {
    	let svgplay;
    	let current;

    	svgplay = new Play({
    			props: { style: "transform: scale(1.3);" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgplay.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgplay, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgplay, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$8.name,
    		type: "else",
    		source: "(62:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:12) {#if $IsPlaying}
    function create_if_block_3$d(ctx) {
    	let svgpause;
    	let current;

    	svgpause = new Pause({
    			props: { style: "transform: scale(1.3);" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgpause.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgpause, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgpause.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgpause.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgpause, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$d.name,
    		type: "if",
    		source: "(60:12) {#if $IsPlaying}",
    		ctx
    	});

    	return block;
    }

    // (85:8) {#if $CurrentSong}
    function create_if_block_2$k(ctx) {
    	let rating;
    	let current;

    	rating = new Rating({
    			props: {
    				type: "song",
    				id: /*$CurrentSong*/ ctx[6].id,
    				rating: /*$CurrentSong*/ ctx[6].rating,
    				flag: /*$CurrentSong*/ ctx[6].flag,
    				averageRating: /*$CurrentSong*/ ctx[6].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rating.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rating, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rating_changes = {};
    			if (dirty & /*$CurrentSong*/ 64) rating_changes.id = /*$CurrentSong*/ ctx[6].id;
    			if (dirty & /*$CurrentSong*/ 64) rating_changes.rating = /*$CurrentSong*/ ctx[6].rating;
    			if (dirty & /*$CurrentSong*/ 64) rating_changes.flag = /*$CurrentSong*/ ctx[6].flag;
    			if (dirty & /*$CurrentSong*/ 64) rating_changes.averageRating = /*$CurrentSong*/ ctx[6].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rating, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$k.name,
    		type: "if",
    		source: "(85:8) {#if $CurrentSong}",
    		ctx
    	});

    	return block;
    }

    // (91:8) {#if $CurrentSong}
    function create_if_block$w(ctx) {
    	let span;
    	let t0;
    	let t1_value = formatSongLength(/*duration*/ ctx[0]) + "";
    	let t1;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*timeToggled*/ ctx[2]) return create_if_block_1$o;
    		return create_else_block$m;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t0 = text("\r\n\r\n                / ");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "svelte-9mrw93");
    			add_location(span, file$K, 91, 12, 2967);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    			append_dev(span, t0);
    			append_dev(span, t1);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*handleTimeToggle*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, t0);
    				}
    			}

    			if (dirty & /*duration*/ 1 && t1_value !== (t1_value = formatSongLength(/*duration*/ ctx[0]) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(91:8) {#if $CurrentSong}",
    		ctx
    	});

    	return block;
    }

    // (95:16) {:else}
    function create_else_block$m(ctx) {
    	let t_value = formatSongLength(/*currentTime*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentTime*/ 2 && t_value !== (t_value = formatSongLength(/*currentTime*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(95:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (93:16) {#if timeToggled}
    function create_if_block_1$o(ctx) {
    	let t0;
    	let t1_value = formatSongLength(/*duration*/ ctx[0] - /*currentTime*/ ctx[1]) + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("-");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*duration, currentTime*/ 3 && t1_value !== (t1_value = formatSongLength(/*duration*/ ctx[0] - /*currentTime*/ ctx[1]) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$o.name,
    		type: "if",
    		source: "(93:16) {#if timeToggled}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let div9;
    	let playerseekbar;
    	let t0;
    	let div0;
    	let button0;
    	let svgprevious;
    	let button0_disabled_value;
    	let t1;
    	let button1;
    	let current_block_type_index;
    	let if_block0;
    	let button1_disabled_value;
    	let t2;
    	let button2;
    	let svgnext;
    	let button2_disabled_value;
    	let t3;
    	let div1;
    	let playernowplaying;
    	let t4;
    	let div3;
    	let div2;
    	let t5;
    	let div4;
    	let t6;
    	let div5;
    	let t7;
    	let div6;
    	let playervolume;
    	let t8;
    	let div7;
    	let button3;
    	let svgrepeat;
    	let t9;
    	let button4;
    	let svgshuffle;
    	let button4_disabled_value;
    	let t10;
    	let playerautoplay;
    	let t11;
    	let div8;
    	let playerqueue;
    	let current;
    	let mounted;
    	let dispose;
    	playerseekbar = new Player_seekBar({ $$inline: true });
    	svgprevious = new Skip_previous({ $$inline: true });
    	const if_block_creators = [create_if_block_3$d, create_else_block_1$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$IsPlaying*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	svgnext = new Skip_next({ $$inline: true });
    	playernowplaying = new Player_nowPlaying({ $$inline: true });
    	let if_block1 = /*$CurrentSong*/ ctx[6] && create_if_block_2$k(ctx);
    	let if_block2 = /*$CurrentSong*/ ctx[6] && create_if_block$w(ctx);
    	playervolume = new Player_volume({ $$inline: true });

    	svgrepeat = new Repeat({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	svgshuffle = new Shuffle({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	playerautoplay = new Player_autoPlay({ $$inline: true });
    	playerqueue = new Player_queue({ $$inline: true });

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			create_component(playerseekbar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			button0 = element("button");
    			create_component(svgprevious.$$.fragment);
    			t1 = space();
    			button1 = element("button");
    			if_block0.c();
    			t2 = space();
    			button2 = element("button");
    			create_component(svgnext.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(playernowplaying.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t5 = space();
    			div4 = element("div");
    			if (if_block1) if_block1.c();
    			t6 = space();
    			div5 = element("div");
    			if (if_block2) if_block2.c();
    			t7 = space();
    			div6 = element("div");
    			create_component(playervolume.$$.fragment);
    			t8 = space();
    			div7 = element("div");
    			button3 = element("button");
    			create_component(svgrepeat.$$.fragment);
    			t9 = space();
    			button4 = element("button");
    			create_component(svgshuffle.$$.fragment);
    			t10 = space();
    			create_component(playerautoplay.$$.fragment);
    			t11 = space();
    			div8 = element("div");
    			create_component(playerqueue.$$.fragment);
    			attr_dev(button0, "class", "icon");
    			button0.disabled = button0_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0;
    			add_location(button0, file$K, 46, 8, 1672);
    			attr_dev(button1, "class", "icon play svelte-9mrw93");
    			button1.disabled = button1_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0;
    			add_location(button1, file$K, 54, 8, 1878);
    			attr_dev(button2, "class", "icon");
    			button2.disabled = button2_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0;
    			add_location(button2, file$K, 66, 8, 2252);
    			attr_dev(div0, "class", "site-player__controls svelte-9mrw93");
    			add_location(div0, file$K, 45, 4, 1627);
    			attr_dev(div1, "class", "site-player__now-playing svelte-9mrw93");
    			add_location(div1, file$K, 75, 4, 2458);
    			attr_dev(div2, "id", "waveform");
    			attr_dev(div2, "class", "svelte-9mrw93");
    			add_location(div2, file$K, 80, 8, 2590);
    			attr_dev(div3, "class", "site-player__waveform svelte-9mrw93");
    			add_location(div3, file$K, 79, 4, 2545);
    			attr_dev(div4, "class", "site-player__rating svelte-9mrw93");
    			add_location(div4, file$K, 83, 4, 2635);
    			attr_dev(div5, "class", "site-player__times svelte-9mrw93");
    			add_location(div5, file$K, 89, 4, 2893);
    			attr_dev(div6, "class", "site-player__volume svelte-9mrw93");
    			add_location(div6, file$K, 103, 4, 3308);
    			attr_dev(button3, "class", "icon icon-repeat");
    			attr_dev(button3, "title", "Repeat");
    			toggle_class(button3, "active", /*$RepeatEnabled*/ ctx[7]);
    			add_location(button3, file$K, 108, 8, 3441);
    			attr_dev(button4, "class", "icon icon-shuffle");
    			button4.disabled = button4_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0;
    			attr_dev(button4, "title", "Shuffle");
    			add_location(button4, file$K, 117, 8, 3697);
    			attr_dev(div7, "class", "site-player__secondary-controls svelte-9mrw93");
    			add_location(div7, file$K, 107, 4, 3386);
    			attr_dev(div8, "class", "site-player__queue svelte-9mrw93");
    			add_location(div8, file$K, 129, 4, 4006);
    			attr_dev(div9, "class", "site-player svelte-9mrw93");
    			add_location(div9, file$K, 42, 0, 1571);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			mount_component(playerseekbar, div9, null);
    			append_dev(div9, t0);
    			append_dev(div9, div0);
    			append_dev(div0, button0);
    			mount_component(svgprevious, button0, null);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			if_blocks[current_block_type_index].m(button1, null);
    			append_dev(div0, t2);
    			append_dev(div0, button2);
    			mount_component(svgnext, button2, null);
    			append_dev(div9, t3);
    			append_dev(div9, div1);
    			mount_component(playernowplaying, div1, null);
    			append_dev(div9, t4);
    			append_dev(div9, div3);
    			append_dev(div3, div2);
    			append_dev(div9, t5);
    			append_dev(div9, div4);
    			if (if_block1) if_block1.m(div4, null);
    			append_dev(div9, t6);
    			append_dev(div9, div5);
    			if (if_block2) if_block2.m(div5, null);
    			append_dev(div9, t7);
    			append_dev(div9, div6);
    			mount_component(playervolume, div6, null);
    			append_dev(div9, t8);
    			append_dev(div9, div7);
    			append_dev(div7, button3);
    			mount_component(svgrepeat, button3, null);
    			append_dev(div7, t9);
    			append_dev(div7, button4);
    			mount_component(svgshuffle, button4, null);
    			append_dev(div7, t10);
    			mount_component(playerautoplay, div7, null);
    			append_dev(div9, t11);
    			append_dev(div9, div8);
    			mount_component(playerqueue, div8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button0,
    						"click",
    						function () {
    							if (is_function(/*$MediaPlayer*/ ctx[3].previous())) /*$MediaPlayer*/ ctx[3].previous().apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*$MediaPlayer*/ ctx[3].playPause())) /*$MediaPlayer*/ ctx[3].playPause().apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button2,
    						"click",
    						function () {
    							if (is_function(/*$MediaPlayer*/ ctx[3].next())) /*$MediaPlayer*/ ctx[3].next().apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button3,
    						"click",
    						function () {
    							if (is_function(/*$MediaPlayer*/ ctx[3].repeat())) /*$MediaPlayer*/ ctx[3].repeat().apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button4,
    						"click",
    						function () {
    							if (is_function(/*$MediaPlayer*/ ctx[3].shuffle())) /*$MediaPlayer*/ ctx[3].shuffle().apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*$NowPlayingQueue*/ 16 && button0_disabled_value !== (button0_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(button1, null);
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 16 && button1_disabled_value !== (button1_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 16 && button2_disabled_value !== (button2_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0)) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (/*$CurrentSong*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$CurrentSong*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$k(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div4, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$CurrentSong*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$w(ctx);
    					if_block2.c();
    					if_block2.m(div5, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$RepeatEnabled*/ 128) {
    				toggle_class(button3, "active", /*$RepeatEnabled*/ ctx[7]);
    			}

    			if (!current || dirty & /*$NowPlayingQueue*/ 16 && button4_disabled_value !== (button4_disabled_value = /*$NowPlayingQueue*/ ctx[4].length === 0)) {
    				prop_dev(button4, "disabled", button4_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playerseekbar.$$.fragment, local);
    			transition_in(svgprevious.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(svgnext.$$.fragment, local);
    			transition_in(playernowplaying.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(playervolume.$$.fragment, local);
    			transition_in(svgrepeat.$$.fragment, local);
    			transition_in(svgshuffle.$$.fragment, local);
    			transition_in(playerautoplay.$$.fragment, local);
    			transition_in(playerqueue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playerseekbar.$$.fragment, local);
    			transition_out(svgprevious.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(svgnext.$$.fragment, local);
    			transition_out(playernowplaying.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(playervolume.$$.fragment, local);
    			transition_out(svgrepeat.$$.fragment, local);
    			transition_out(svgshuffle.$$.fragment, local);
    			transition_out(playerautoplay.$$.fragment, local);
    			transition_out(playerqueue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			destroy_component(playerseekbar);
    			destroy_component(svgprevious);
    			if_blocks[current_block_type_index].d();
    			destroy_component(svgnext);
    			destroy_component(playernowplaying);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_component(playervolume);
    			destroy_component(svgrepeat);
    			destroy_component(svgshuffle);
    			destroy_component(playerautoplay);
    			destroy_component(playerqueue);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $MediaPlayer;
    	let $NowPlayingQueue;
    	let $IsPlaying;
    	let $CurrentSong;
    	let $RepeatEnabled;
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(3, $MediaPlayer = $$value));
    	validate_store(NowPlayingQueue, "NowPlayingQueue");
    	component_subscribe($$self, NowPlayingQueue, $$value => $$invalidate(4, $NowPlayingQueue = $$value));
    	validate_store(IsPlaying, "IsPlaying");
    	component_subscribe($$self, IsPlaying, $$value => $$invalidate(5, $IsPlaying = $$value));
    	validate_store(CurrentSong, "CurrentSong");
    	component_subscribe($$self, CurrentSong, $$value => $$invalidate(6, $CurrentSong = $$value));
    	validate_store(RepeatEnabled, "RepeatEnabled");
    	component_subscribe($$self, RepeatEnabled, $$value => $$invalidate(7, $RepeatEnabled = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Player", slots, []);
    	let duration;
    	let currentTime;
    	let timeToggled = false;

    	function updateProgress() {
    		$$invalidate(0, duration = $MediaPlayer.wavesurfer
    		? parseInt($MediaPlayer.wavesurfer.getDuration()) || 0
    		: 0);

    		$$invalidate(1, currentTime = $MediaPlayer.wavesurfer
    		? parseInt($MediaPlayer.wavesurfer.getCurrentTime()) || 0
    		: 0);

    		requestAnimationFrame(updateProgress);
    	}

    	function handleTimeToggle() {
    		$$invalidate(2, timeToggled = !timeToggled);
    	}

    	onMount(() => {
    		requestAnimationFrame(updateProgress);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Player> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		MediaPlayer,
    		NowPlayingQueue,
    		IsPlaying,
    		CurrentSong,
    		RepeatEnabled,
    		formatSongLength,
    		Rating,
    		PlayerSeekBar: Player_seekBar,
    		PlayerNowPlaying: Player_nowPlaying,
    		PlayerQueue: Player_queue,
    		PlayerVolume: Player_volume,
    		PlayerAutoPlay: Player_autoPlay,
    		SVGPlay: Play,
    		SVGPause: Pause,
    		SVGNext: Skip_next,
    		SVGPrevious: Skip_previous,
    		SVGShuffle: Shuffle,
    		SVGRepeat: Repeat,
    		duration,
    		currentTime,
    		timeToggled,
    		updateProgress,
    		handleTimeToggle,
    		$MediaPlayer,
    		$NowPlayingQueue,
    		$IsPlaying,
    		$CurrentSong,
    		$RepeatEnabled
    	});

    	$$self.$inject_state = $$props => {
    		if ("duration" in $$props) $$invalidate(0, duration = $$props.duration);
    		if ("currentTime" in $$props) $$invalidate(1, currentTime = $$props.currentTime);
    		if ("timeToggled" in $$props) $$invalidate(2, timeToggled = $$props.timeToggled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		duration,
    		currentTime,
    		timeToggled,
    		$MediaPlayer,
    		$NowPlayingQueue,
    		$IsPlaying,
    		$CurrentSong,
    		$RepeatEnabled,
    		handleTimeToggle
    	];
    }

    class Player extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Player",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src\components\tabs.svelte generated by Svelte v3.38.3 */
    const file$J = "src\\components\\tabs.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (21:4) {#if Array.isArray(items)}
    function create_if_block$v(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*activeTabValue, items, handleClick*/ 7) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(21:4) {#if Array.isArray(items)}",
    		ctx
    	});

    	return block;
    }

    // (25:20) {#if item.icon}
    function create_if_block_1$n(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*item*/ ctx[5].icon;

    	function switch_props(ctx) {
    		return {
    			props: { class: "inline tab-icon" },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*item*/ ctx[5].icon)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$n.name,
    		type: "if",
    		source: "(25:20) {#if item.icon}",
    		ctx
    	});

    	return block;
    }

    // (22:8) {#each items as item}
    function create_each_block$c(ctx) {
    	let li;
    	let span;
    	let t0;
    	let t1_value = /*item*/ ctx[5].label + "";
    	let t1;
    	let t2;
    	let li_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*item*/ ctx[5].icon && create_if_block_1$n(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(span, "class", "svelte-1e7e7yx");
    			add_location(span, file$J, 23, 16, 650);

    			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*activeTabValue*/ ctx[0] === /*item*/ ctx[5].value
    			? "active"
    			: "") + " svelte-1e7e7yx"));

    			add_location(li, file$J, 22, 12, 574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			if (if_block) if_block.m(span, null);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(li, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					span,
    					"click",
    					function () {
    						if (is_function(/*handleClick*/ ctx[2](/*item*/ ctx[5].value))) /*handleClick*/ ctx[2](/*item*/ ctx[5].value).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*item*/ ctx[5].icon) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*items*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(span, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*items*/ 2) && t1_value !== (t1_value = /*item*/ ctx[5].label + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*activeTabValue, items*/ 3 && li_class_value !== (li_class_value = "" + (null_to_empty(/*activeTabValue*/ ctx[0] === /*item*/ ctx[5].value
    			? "active"
    			: "") + " svelte-1e7e7yx"))) {
    				attr_dev(li, "class", li_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(22:8) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let ul;
    	let show_if = Array.isArray(/*items*/ ctx[1]);
    	let t;
    	let div;
    	let current;
    	let if_block = show_if && create_if_block$v(ctx);
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", "tabs svelte-1e7e7yx");
    			add_location(ul, file$J, 19, 0, 480);
    			attr_dev(div, "class", "tab-content");
    			add_location(div, file$J, 34, 0, 959);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			if (if_block) if_block.m(ul, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*items*/ 2) show_if = Array.isArray(/*items*/ ctx[1]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*items*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], !current ? -1 : dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabs", slots, ['default']);
    	let { items = [] } = $$props;
    	let { activeTabValue = null } = $$props;

    	onMount(() => {
    		// Set default tab value
    		if (Array.isArray(items) && items.length && items[0].value) {
    			$$invalidate(0, activeTabValue = items[0].value);
    		}
    	});

    	function handleClick(tabValue) {
    		$$invalidate(0, activeTabValue = tabValue);
    	}

    	const writable_props = ["items", "activeTabValue"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("activeTabValue" in $$props) $$invalidate(0, activeTabValue = $$props.activeTabValue);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		items,
    		activeTabValue,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("activeTabValue" in $$props) $$invalidate(0, activeTabValue = $$props.activeTabValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [activeTabValue, items, handleClick, $$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, { items: 1, activeTabValue: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get items() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeTabValue() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeTabValue(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\login.svg generated by Svelte v3.38.3 */

    function create_fragment$V(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let rect1;
    	let g1;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			g1 = svg_element("g");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			rect0 = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect0).forEach(detach);
    			rect1 = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect1).forEach(detach);
    			g0_nodes.forEach(detach);
    			g1 = claim_element(svg_nodes, "g", {}, 1);
    			var g1_nodes = children(g1);
    			path = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			g1_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect0, "fill", "none");
    			attr(rect0, "height", "24");
    			attr(rect0, "width", "24");
    			attr(rect1, "fill", "none");
    			attr(rect1, "height", "24");
    			attr(rect1, "width", "24");
    			attr(path, "d", "M10.3,7.7L10.3,7.7c-0.39,0.39-0.39,1.01,0,1.4l1.9,1.9H3c-0.55,0-1,0.45-1,1v0c0,0.55,0.45,1,1,1h9.2l-1.9,1.9 c-0.39,0.39-0.39,1.01,0,1.4l0,0c0.39,0.39,1.01,0.39,1.4,0l3.59-3.59c0.39-0.39,0.39-1.02,0-1.41L11.7,7.7 C11.31,7.31,10.69,7.31,10.3,7.7z M20,19h-7c-0.55,0-1,0.45-1,1v0c0,0.55,0.45,1,1,1h7c1.1,0,2-0.9,2-2V5c0-1.1-0.9-2-2-2h-7 c-0.55,0-1,0.45-1,1v0c0,0.55,0.45,1,1,1h7V19z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, rect0);
    			append(g0, rect1);
    			append(svg, g1);
    			append(g1, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$V($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Login$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
    	}
    }

    /* src\views\login.svelte generated by Svelte v3.38.3 */
    const file$I = "src\\views\\login.svelte";

    // (56:4) {#if versionCheck && versionCheck < 5}
    function create_if_block_2$j(ctx) {
    	let p;
    	let t0;
    	let t1;
    	let t2;
    	let p_intro;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Ample only supports Ampache v5 and up. Version ");
    			t1 = text(/*$serverVersion*/ ctx[0]);
    			t2 = text(" detected.");
    			attr_dev(p, "class", "server-message badge danger svelte-ux4mq2");
    			add_location(p, file$I, 56, 8, 1668);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$serverVersion*/ 1) set_data_dev(t1, /*$serverVersion*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (!p_intro) {
    				add_render_callback(() => {
    					p_intro = create_in_transition(p, fade, {});
    					p_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$j.name,
    		type: "if",
    		source: "(56:4) {#if versionCheck && versionCheck < 5}",
    		ctx
    	});

    	return block;
    }

    // (64:4) <Tabs bind:activeTabValue={currentTab} items={tabItems}>
    function create_default_slot$n(ctx) {
    	let div0;
    	let form0;
    	let p0;
    	let label0;
    	let t0;
    	let input0;
    	let t1;
    	let p1;
    	let label1;
    	let t2;
    	let input1;
    	let t3;
    	let button0;
    	let svglogin0;
    	let t4;
    	let t5;
    	let div1;
    	let form1;
    	let p2;
    	let label2;
    	let t6;
    	let input2;
    	let t7;
    	let button1;
    	let svglogin1;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	svglogin0 = new Login$1({ $$inline: true });
    	svglogin1 = new Login$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			form0 = element("form");
    			p0 = element("p");
    			label0 = element("label");
    			t0 = text("Ampache username\r\n                        ");
    			input0 = element("input");
    			t1 = space();
    			p1 = element("p");
    			label1 = element("label");
    			t2 = text("Ampache password\r\n                        ");
    			input1 = element("input");
    			t3 = space();
    			button0 = element("button");
    			create_component(svglogin0.$$.fragment);
    			t4 = text(" Login");
    			t5 = space();
    			div1 = element("div");
    			form1 = element("form");
    			p2 = element("p");
    			label2 = element("label");
    			t6 = text("API key\r\n                        ");
    			input2 = element("input");
    			t7 = space();
    			button1 = element("button");
    			create_component(svglogin1.$$.fragment);
    			t8 = text(" Login");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "svelte-ux4mq2");
    			add_location(input0, file$I, 68, 24, 2178);
    			attr_dev(label0, "class", "svelte-ux4mq2");
    			add_location(label0, file$I, 67, 20, 2129);
    			add_location(p0, file$I, 66, 16, 2104);
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "class", "svelte-ux4mq2");
    			add_location(input1, file$I, 73, 24, 2365);
    			attr_dev(label1, "class", "svelte-ux4mq2");
    			add_location(label1, file$I, 72, 20, 2316);
    			add_location(p1, file$I, 71, 16, 2291);
    			attr_dev(button0, "class", "primary with-icon svelte-ux4mq2");
    			attr_dev(button0, "type", "submit");
    			add_location(button0, file$I, 76, 16, 2482);
    			add_location(form0, file$I, 65, 12, 2032);
    			attr_dev(div0, "class", "username");
    			set_style(div0, "display", /*currentTab*/ ctx[5] === 1 ? "block" : "none");
    			add_location(div0, file$I, 64, 8, 1941);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "svelte-ux4mq2");
    			add_location(input2, file$I, 84, 24, 2824);
    			attr_dev(label2, "class", "svelte-ux4mq2");
    			add_location(label2, file$I, 83, 20, 2784);
    			add_location(p2, file$I, 82, 16, 2759);
    			attr_dev(button1, "class", "primary with-icon svelte-ux4mq2");
    			attr_dev(button1, "type", "submit");
    			add_location(button1, file$I, 88, 16, 2937);
    			add_location(form1, file$I, 81, 12, 2692);
    			attr_dev(div1, "class", "api");
    			set_style(div1, "display", /*currentTab*/ ctx[5] === 2 ? "block" : "none");
    			add_location(div1, file$I, 80, 8, 2606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, form0);
    			append_dev(form0, p0);
    			append_dev(p0, label0);
    			append_dev(label0, t0);
    			append_dev(label0, input0);
    			set_input_value(input0, /*username*/ ctx[1]);
    			append_dev(form0, t1);
    			append_dev(form0, p1);
    			append_dev(p1, label1);
    			append_dev(label1, t2);
    			append_dev(label1, input1);
    			set_input_value(input1, /*password*/ ctx[2]);
    			append_dev(form0, t3);
    			append_dev(form0, button0);
    			mount_component(svglogin0, button0, null);
    			append_dev(button0, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, form1);
    			append_dev(form1, p2);
    			append_dev(p2, label2);
    			append_dev(label2, t6);
    			append_dev(label2, input2);
    			set_input_value(input2, /*apiKey*/ ctx[3]);
    			append_dev(form1, t7);
    			append_dev(form1, button1);
    			mount_component(svglogin1, button1, null);
    			append_dev(button1, t8);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[12]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[13]),
    					listen_dev(form0, "submit", prevent_default(/*handleSubmitUsername*/ ctx[9]), false, true, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[14]),
    					listen_dev(form1, "submit", prevent_default(/*handleSubmitAPI*/ ctx[10]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*username*/ 2 && input0.value !== /*username*/ ctx[1]) {
    				set_input_value(input0, /*username*/ ctx[1]);
    			}

    			if (dirty & /*password*/ 4 && input1.value !== /*password*/ ctx[2]) {
    				set_input_value(input1, /*password*/ ctx[2]);
    			}

    			if (!current || dirty & /*currentTab*/ 32) {
    				set_style(div0, "display", /*currentTab*/ ctx[5] === 1 ? "block" : "none");
    			}

    			if (dirty & /*apiKey*/ 8 && input2.value !== /*apiKey*/ ctx[3]) {
    				set_input_value(input2, /*apiKey*/ ctx[3]);
    			}

    			if (!current || dirty & /*currentTab*/ 32) {
    				set_style(div1, "display", /*currentTab*/ ctx[5] === 2 ? "block" : "none");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svglogin0.$$.fragment, local);
    			transition_in(svglogin1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svglogin0.$$.fragment, local);
    			transition_out(svglogin1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(svglogin0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div1);
    			destroy_component(svglogin1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(64:4) <Tabs bind:activeTabValue={currentTab} items={tabItems}>",
    		ctx
    	});

    	return block;
    }

    // (94:4) {#if message}
    function create_if_block_1$m(ctx) {
    	let p;
    	let t;
    	let p_intro;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*message*/ ctx[4]);
    			attr_dev(p, "class", "login-message badge warning svelte-ux4mq2");
    			add_location(p, file$I, 94, 8, 3093);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 16) set_data_dev(t, /*message*/ ctx[4]);
    		},
    		i: function intro(local) {
    			if (!p_intro) {
    				add_render_callback(() => {
    					p_intro = create_in_transition(p, fade, {});
    					p_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$m.name,
    		type: "if",
    		source: "(94:4) {#if message}",
    		ctx
    	});

    	return block;
    }

    // (99:44) {#if $serverVersion}
    function create_if_block$u(ctx) {
    	let t0;
    	let span;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("- ");
    			span = element("span");
    			t1 = text("Ampache v");
    			t2 = text(/*$serverVersion*/ ctx[0]);
    			add_location(span, file$I, 98, 66, 3258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$serverVersion*/ 1) set_data_dev(t2, /*$serverVersion*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(99:44) {#if $serverVersion}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let div2;
    	let t0;
    	let div0;
    	let svgamplelogo;
    	let t1;
    	let tabs;
    	let updating_activeTabValue;
    	let t2;
    	let t3;
    	let div1;
    	let span;
    	let t4;
    	let t5;
    	let t6;
    	let div2_intro;
    	let div2_outro;
    	let t7;
    	let div7;
    	let div3;
    	let t8;
    	let div4;
    	let t9;
    	let div5;
    	let t10;
    	let div6;
    	let div7_outro;
    	let current;
    	let if_block0 = /*versionCheck*/ ctx[6] && /*versionCheck*/ ctx[6] < 5 && create_if_block_2$j(ctx);
    	svgamplelogo = new Ample_logo({ $$inline: true });

    	function tabs_activeTabValue_binding(value) {
    		/*tabs_activeTabValue_binding*/ ctx[15](value);
    	}

    	let tabs_props = {
    		items: /*tabItems*/ ctx[8],
    		$$slots: { default: [create_default_slot$n] },
    		$$scope: { ctx }
    	};

    	if (/*currentTab*/ ctx[5] !== void 0) {
    		tabs_props.activeTabValue = /*currentTab*/ ctx[5];
    	}

    	tabs = new Tabs({ props: tabs_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabs, "activeTabValue", tabs_activeTabValue_binding));
    	let if_block1 = /*message*/ ctx[4] && create_if_block_1$m(ctx);
    	let if_block2 = /*$serverVersion*/ ctx[0] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			create_component(svgamplelogo.$$.fragment);
    			t1 = space();
    			create_component(tabs.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div1 = element("div");
    			span = element("span");
    			t4 = text("Ample v");
    			t5 = text(/*$ampleVersion*/ ctx[7]);
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			div7 = element("div");
    			div3 = element("div");
    			t8 = space();
    			div4 = element("div");
    			t9 = space();
    			div5 = element("div");
    			t10 = space();
    			div6 = element("div");
    			attr_dev(div0, "class", "logo svelte-ux4mq2");
    			add_location(div0, file$I, 59, 4, 1811);
    			add_location(span, file$I, 98, 8, 3200);
    			attr_dev(div1, "class", "meta svelte-ux4mq2");
    			add_location(div1, file$I, 97, 4, 3172);
    			attr_dev(div2, "class", "container svelte-ux4mq2");
    			add_location(div2, file$I, 54, 0, 1574);
    			attr_dev(div3, "class", "bg svelte-ux4mq2");
    			add_location(div3, file$I, 103, 4, 3366);
    			attr_dev(div4, "class", "bg bg2 svelte-ux4mq2");
    			add_location(div4, file$I, 104, 4, 3394);
    			attr_dev(div5, "class", "bg bg3 svelte-ux4mq2");
    			add_location(div5, file$I, 105, 4, 3426);
    			attr_dev(div6, "class", "bg bg4 svelte-ux4mq2");
    			add_location(div6, file$I, 106, 4, 3458);
    			attr_dev(div7, "class", "bg-container svelte-ux4mq2");
    			add_location(div7, file$I, 102, 0, 3325);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			mount_component(svgamplelogo, div0, null);
    			append_dev(div2, t1);
    			mount_component(tabs, div2, null);
    			append_dev(div2, t2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, span);
    			append_dev(span, t4);
    			append_dev(span, t5);
    			append_dev(div1, t6);
    			if (if_block2) if_block2.m(div1, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div3);
    			append_dev(div7, t8);
    			append_dev(div7, div4);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*versionCheck*/ ctx[6] && /*versionCheck*/ ctx[6] < 5) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*versionCheck*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$j(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const tabs_changes = {};

    			if (dirty & /*$$scope, currentTab, apiKey, password, username*/ 1048622) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeTabValue && dirty & /*currentTab*/ 32) {
    				updating_activeTabValue = true;
    				tabs_changes.activeTabValue = /*currentTab*/ ctx[5];
    				add_flush_callback(() => updating_activeTabValue = false);
    			}

    			tabs.$set(tabs_changes);

    			if (/*message*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*message*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$m(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*$ampleVersion*/ 128) set_data_dev(t5, /*$ampleVersion*/ ctx[7]);

    			if (/*$serverVersion*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$u(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(svgamplelogo.$$.fragment, local);
    			transition_in(tabs.$$.fragment, local);
    			transition_in(if_block1);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				if (!div2_intro) div2_intro = create_in_transition(div2, fade, {});
    				div2_intro.start();
    			});

    			if (div7_outro) div7_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgamplelogo.$$.fragment, local);
    			transition_out(tabs.$$.fragment, local);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, fade, {});
    			div7_outro = create_out_transition(div7, fade, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			destroy_component(svgamplelogo);
    			destroy_component(tabs);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (detaching && div2_outro) div2_outro.end();
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div7);
    			if (detaching && div7_outro) div7_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let theme;
    	let versionCheck;
    	let $ThemeIsLight;
    	let $serverVersion;
    	let $ampleVersion;
    	validate_store(ThemeIsLight, "ThemeIsLight");
    	component_subscribe($$self, ThemeIsLight, $$value => $$invalidate(11, $ThemeIsLight = $$value));
    	validate_store(serverVersion, "serverVersion");
    	component_subscribe($$self, serverVersion, $$value => $$invalidate(0, $serverVersion = $$value));
    	validate_store(ampleVersion, "ampleVersion");
    	component_subscribe($$self, ampleVersion, $$value => $$invalidate(7, $ampleVersion = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Login", slots, []);
    	let username = "";
    	let password = "";
    	let apiKey = "";
    	let promise;
    	let legibleColors;
    	let randomColor = K([50, 50, getRandomInt(360)]);
    	let message = "";

    	// List of tab items with labels and values.
    	let tabItems = [{ label: "Username", value: 1 }, { label: "API key", value: 2 }];

    	// Current active tab
    	let currentTab;

    	const handleSubmitUsername = async e => {
    		$$invalidate(4, message = "");
    		$$invalidate(4, message = await handshake(username, password));
    	};

    	const handleSubmitAPI = async e => {
    		$$invalidate(4, message = "");
    		$$invalidate(4, message = await handshakeAPI(apiKey));
    	};

    	onMount(async () => {
    		legibleColors = await getLegibleColors(randomColor);
    		customColors.set(legibleColors);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		username = this.value;
    		$$invalidate(1, username);
    	}

    	function input1_input_handler() {
    		password = this.value;
    		$$invalidate(2, password);
    	}

    	function input2_input_handler() {
    		apiKey = this.value;
    		$$invalidate(3, apiKey);
    	}

    	function tabs_activeTabValue_binding(value) {
    		currentTab = value;
    		$$invalidate(5, currentTab);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		lchToRgb: K,
    		serverVersion,
    		ThemeIsLight,
    		customColors,
    		ampleVersion,
    		handshake,
    		handshakeAPI,
    		getLegibleColors,
    		getRandomInt,
    		Tabs,
    		SVGAmpleLogo: Ample_logo,
    		SVGLogin: Login$1,
    		username,
    		password,
    		apiKey,
    		promise,
    		legibleColors,
    		randomColor,
    		message,
    		tabItems,
    		currentTab,
    		handleSubmitUsername,
    		handleSubmitAPI,
    		theme,
    		$ThemeIsLight,
    		versionCheck,
    		$serverVersion,
    		$ampleVersion
    	});

    	$$self.$inject_state = $$props => {
    		if ("username" in $$props) $$invalidate(1, username = $$props.username);
    		if ("password" in $$props) $$invalidate(2, password = $$props.password);
    		if ("apiKey" in $$props) $$invalidate(3, apiKey = $$props.apiKey);
    		if ("promise" in $$props) promise = $$props.promise;
    		if ("legibleColors" in $$props) legibleColors = $$props.legibleColors;
    		if ("randomColor" in $$props) randomColor = $$props.randomColor;
    		if ("message" in $$props) $$invalidate(4, message = $$props.message);
    		if ("tabItems" in $$props) $$invalidate(8, tabItems = $$props.tabItems);
    		if ("currentTab" in $$props) $$invalidate(5, currentTab = $$props.currentTab);
    		if ("theme" in $$props) theme = $$props.theme;
    		if ("versionCheck" in $$props) $$invalidate(6, versionCheck = $$props.versionCheck);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ThemeIsLight*/ 2048) {
    			theme = $ThemeIsLight ? "light" : "dark";
    		}

    		if ($$self.$$.dirty & /*$serverVersion*/ 1) {
    			$$invalidate(6, versionCheck = $serverVersion.charAt(0));
    		}
    	};

    	return [
    		$serverVersion,
    		username,
    		password,
    		apiKey,
    		message,
    		currentTab,
    		versionCheck,
    		$ampleVersion,
    		tabItems,
    		handleSubmitUsername,
    		handleSubmitAPI,
    		$ThemeIsLight,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		tabs_activeTabValue_binding
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* src\views\notFound404.svelte generated by Svelte v3.38.3 */

    const file$H = "src\\views\\notFound404.svelte";

    function create_fragment$T(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Sorry not found";
    			add_location(p, file$H, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotFound404", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NotFound404> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class NotFound404 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotFound404",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src\views\home.svelte generated by Svelte v3.38.3 */

    function create_fragment$S(ctx) {
    	let cardlist0;
    	let t0;
    	let cardlist1;
    	let t1;
    	let cardlist2;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "newestAlbums",
    				limit: "12",
    				containerType: "scroll",
    				heading: "Newest albums"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "recentSongs",
    				limit: "9",
    				containerType: "scroll",
    				heading: "Recently played"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "randomAlbums",
    				limit: "12",
    				refresh: "true",
    				containerType: "scroll",
    				heading: "Random albums"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardlist0.$$.fragment);
    			t0 = space();
    			create_component(cardlist1.$$.fragment);
    			t1 = space();
    			create_component(cardlist2.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cardlist1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cardlist1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Home", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CardList,
    		recentSongs,
    		newestAlbums,
    		randomAlbums
    	});

    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    /* src\components\linkCard.svelte generated by Svelte v3.38.3 */
    const file$G = "src\\components\\linkCard.svelte";

    // (8:4) <Link to={url}>
    function create_default_slot$m(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], !current ? -1 : dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(8:4) <Link to={url}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let div;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: /*url*/ ctx[0],
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(div, "class", "link-card svelte-11gazn1");
    			add_location(div, file$G, 6, 0, 90);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(link, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};
    			if (dirty & /*url*/ 1) link_changes.to = /*url*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LinkCard", slots, ['default']);
    	let { url } = $$props;
    	const writable_props = ["url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LinkCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Link, url });

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [url, slots, $$scope];
    }

    class LinkCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { url: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinkCard",
    			options,
    			id: create_fragment$R.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*url*/ ctx[0] === undefined && !("url" in props)) {
    			console.warn("<LinkCard> was created without expected prop 'url'");
    		}
    	}

    	get url() {
    		throw new Error("<LinkCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<LinkCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\artists.svelte generated by Svelte v3.38.3 */
    const file$F = "src\\views\\artists.svelte";

    // (11:4) <LinkCard url="artists/all">
    function create_default_slot$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("All Artists");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(11:4) <LinkCard url=\\\"artists/all\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let h1;
    	let t1;
    	let section;
    	let linkcard;
    	let t2;
    	let cardlist0;
    	let t3;
    	let cardlist1;
    	let current;

    	linkcard = new LinkCard({
    			props: {
    				url: "artists/all",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "newestArtists",
    				limit: "6",
    				heading: "Recently updated"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "randomArtists",
    				limit: "6",
    				refresh: "true",
    				heading: "Random"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Artists";
    			t1 = space();
    			section = element("section");
    			create_component(linkcard.$$.fragment);
    			t2 = space();
    			create_component(cardlist0.$$.fragment);
    			t3 = space();
    			create_component(cardlist1.$$.fragment);
    			add_location(h1, file$F, 7, 0, 212);
    			attr_dev(section, "class", "link-grid");
    			add_location(section, file$F, 9, 0, 232);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section, anchor);
    			mount_component(linkcard, section, null);
    			insert_dev(target, t2, anchor);
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const linkcard_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				linkcard_changes.$$scope = { dirty, ctx };
    			}

    			linkcard.$set(linkcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkcard.$$.fragment, local);
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkcard.$$.fragment, local);
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section);
    			destroy_component(linkcard);
    			if (detaching) detach_dev(t2);
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Artists", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Artists> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LinkCard,
    		CardList,
    		newestArtists,
    		randomArtists
    	});

    	return [];
    }

    class Artists extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Artists",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src\components\alphanumericPagination.svelte generated by Svelte v3.38.3 */
    const file$E = "src\\components\\alphanumericPagination.svelte";

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i][0];
    	child_ctx[11] = list[i][1];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i][0];
    	child_ctx[11] = list[i][1];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (60:12) {#if $albumIndex}
    function create_if_block_3$c(ctx) {
    	let each_1_anchor;
    	let each_value_1 = [.../*$albumIndex*/ ctx[4]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$albumIndex, selectedChar, handleSelection*/ 81) {
    				each_value_1 = [.../*$albumIndex*/ ctx[4]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$c.name,
    		type: "if",
    		source: "(60:12) {#if $albumIndex}",
    		ctx
    	});

    	return block;
    }

    // (39:8) {#if type === "artists"}
    function create_if_block$t(ctx) {
    	let if_block_anchor;
    	let if_block = /*$artistIndex*/ ctx[2] && create_if_block_1$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$artistIndex*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$l(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(39:8) {#if type === \\\"artists\\\"}",
    		ctx
    	});

    	return block;
    }

    // (62:20) {#if value.albumCount > 0}
    function create_if_block_4$a(ctx) {
    	let li;
    	let button;
    	let t0_value = /*key*/ ctx[10] + "";
    	let t0;
    	let button_data_char_id_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "data-char_id", button_data_char_id_value = /*key*/ ctx[10]);
    			attr_dev(button, "class", "svelte-bisr2l");
    			toggle_class(button, "active", /*key*/ ctx[10] === /*selectedChar*/ ctx[0]);
    			add_location(button, file$E, 63, 28, 2198);
    			attr_dev(li, "class", "svelte-bisr2l");
    			add_location(li, file$E, 62, 24, 2164);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleSelection*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$albumIndex*/ 16 && t0_value !== (t0_value = /*key*/ ctx[10] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$albumIndex*/ 16 && button_data_char_id_value !== (button_data_char_id_value = /*key*/ ctx[10])) {
    				attr_dev(button, "data-char_id", button_data_char_id_value);
    			}

    			if (dirty & /*$albumIndex, selectedChar*/ 17) {
    				toggle_class(button, "active", /*key*/ ctx[10] === /*selectedChar*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$a.name,
    		type: "if",
    		source: "(62:20) {#if value.albumCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (61:16) {#each [...$albumIndex] as [key, value], i}
    function create_each_block_1$6(ctx) {
    	let if_block_anchor;
    	let if_block = /*value*/ ctx[11].albumCount > 0 && create_if_block_4$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*value*/ ctx[11].albumCount > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(61:16) {#each [...$albumIndex] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (40:12) {#if $artistIndex}
    function create_if_block_1$l(ctx) {
    	let each_1_anchor;
    	let each_value = [.../*$artistIndex*/ ctx[2]];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$artistIndex, $ShowAlbumArtistsOnly, parseInt, selectedChar, handleSelection*/ 77) {
    				each_value = [.../*$artistIndex*/ ctx[2]];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(40:12) {#if $artistIndex}",
    		ctx
    	});

    	return block;
    }

    // (42:20) {#if value.artistCount > 0 || value.albumArtistCount > 0}
    function create_if_block_2$i(ctx) {
    	let li;
    	let button;
    	let t0_value = /*key*/ ctx[10] + "";
    	let t0;
    	let button_data_char_id_value;
    	let button_disabled_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "data-char_id", button_data_char_id_value = /*key*/ ctx[10]);
    			button.disabled = button_disabled_value = /*$ShowAlbumArtistsOnly*/ ctx[3] && parseInt(/*value*/ ctx[11].albumArtistCount) === 0 || !/*$ShowAlbumArtistsOnly*/ ctx[3] && parseInt(/*value*/ ctx[11].artistCount) === 0;
    			attr_dev(button, "class", "svelte-bisr2l");
    			toggle_class(button, "active", /*key*/ ctx[10] === /*selectedChar*/ ctx[0]);
    			add_location(button, file$E, 43, 28, 1310);
    			attr_dev(li, "class", "svelte-bisr2l");
    			add_location(li, file$E, 42, 24, 1276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleSelection*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$artistIndex*/ 4 && t0_value !== (t0_value = /*key*/ ctx[10] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$artistIndex*/ 4 && button_data_char_id_value !== (button_data_char_id_value = /*key*/ ctx[10])) {
    				attr_dev(button, "data-char_id", button_data_char_id_value);
    			}

    			if (dirty & /*$ShowAlbumArtistsOnly, $artistIndex*/ 12 && button_disabled_value !== (button_disabled_value = /*$ShowAlbumArtistsOnly*/ ctx[3] && parseInt(/*value*/ ctx[11].albumArtistCount) === 0 || !/*$ShowAlbumArtistsOnly*/ ctx[3] && parseInt(/*value*/ ctx[11].artistCount) === 0)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*$artistIndex, selectedChar*/ 5) {
    				toggle_class(button, "active", /*key*/ ctx[10] === /*selectedChar*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$i.name,
    		type: "if",
    		source: "(42:20) {#if value.artistCount > 0 || value.albumArtistCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {#each [...$artistIndex] as [key, value], i}
    function create_each_block$b(ctx) {
    	let if_block_anchor;
    	let if_block = (/*value*/ ctx[11].artistCount > 0 || /*value*/ ctx[11].albumArtistCount > 0) && create_if_block_2$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*value*/ ctx[11].artistCount > 0 || /*value*/ ctx[11].albumArtistCount > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$i(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(41:16) {#each [...$artistIndex] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let div;
    	let button;
    	let t1;
    	let ul;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[1] === "artists") return create_if_block$t;
    		if (/*$albumIndex*/ ctx[4]) return create_if_block_3$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "All";
    			t1 = space();
    			ul = element("ul");
    			if (if_block) if_block.c();
    			attr_dev(button, "class", "all svelte-bisr2l");
    			add_location(button, file$E, 33, 4, 954);
    			attr_dev(ul, "class", "row svelte-bisr2l");
    			add_location(ul, file$E, 37, 4, 1027);
    			attr_dev(div, "class", "container pagination svelte-bisr2l");
    			add_location(div, file$E, 32, 0, 914);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(div, t1);
    			append_dev(div, ul);
    			if (if_block) if_block.m(ul, null);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*clear*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(ul, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $artistIndex;
    	let $ShowAlbumArtistsOnly;
    	let $albumIndex;
    	validate_store(artistIndex, "artistIndex");
    	component_subscribe($$self, artistIndex, $$value => $$invalidate(2, $artistIndex = $$value));
    	validate_store(ShowAlbumArtistsOnly, "ShowAlbumArtistsOnly");
    	component_subscribe($$self, ShowAlbumArtistsOnly, $$value => $$invalidate(3, $ShowAlbumArtistsOnly = $$value));
    	validate_store(albumIndex, "albumIndex");
    	component_subscribe($$self, albumIndex, $$value => $$invalidate(4, $albumIndex = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlphanumericPagination", slots, []);
    	let { selectedChar } = $$props;
    	let { type } = $$props;
    	let params = new URL(document.location).searchParams;

    	// Load from URL otherwise set defaults
    	let charID = params.get("filter") || "";

    	let items = [];

    	function clear() {
    		let url = new URL(window.location);
    		url.searchParams.delete("filter");
    		$$invalidate(7, charID = "");
    		window.history.replaceState({}, "", url);
    	}

    	function handleSelection(e) {
    		let url = new URL(window.location);
    		let charSelected = e.target.dataset.char_id;
    		$$invalidate(7, charID = charSelected);
    		url.searchParams.set("filter", charSelected);
    		window.history.replaceState({}, "", url);
    	}

    	const writable_props = ["selectedChar", "type"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlphanumericPagination> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("selectedChar" in $$props) $$invalidate(0, selectedChar = $$props.selectedChar);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    	};

    	$$self.$capture_state = () => ({
    		ShowAlbumArtistsOnly,
    		artistIndex,
    		albumIndex,
    		selectedChar,
    		type,
    		params,
    		charID,
    		items,
    		clear,
    		handleSelection,
    		$artistIndex,
    		$ShowAlbumArtistsOnly,
    		$albumIndex
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedChar" in $$props) $$invalidate(0, selectedChar = $$props.selectedChar);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("params" in $$props) params = $$props.params;
    		if ("charID" in $$props) $$invalidate(7, charID = $$props.charID);
    		if ("items" in $$props) items = $$props.items;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*charID*/ 128) {
    			$$invalidate(0, selectedChar = charID);
    		}
    	};

    	return [
    		selectedChar,
    		type,
    		$artistIndex,
    		$ShowAlbumArtistsOnly,
    		$albumIndex,
    		clear,
    		handleSelection,
    		charID
    	];
    }

    class AlphanumericPagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { selectedChar: 0, type: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlphanumericPagination",
    			options,
    			id: create_fragment$P.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selectedChar*/ ctx[0] === undefined && !("selectedChar" in props)) {
    			console.warn("<AlphanumericPagination> was created without expected prop 'selectedChar'");
    		}

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<AlphanumericPagination> was created without expected prop 'type'");
    		}
    	}

    	get selectedChar() {
    		throw new Error("<AlphanumericPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedChar(value) {
    		throw new Error("<AlphanumericPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<AlphanumericPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<AlphanumericPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\playlists\playlist_addTo.svelte generated by Svelte v3.38.3 */
    const file$D = "src\\components\\playlists\\playlist_addTo.svelte";

    function create_fragment$O(ctx) {
    	let h4;
    	let t1;
    	let label;
    	let input;
    	let t2;
    	let t3;
    	let playlistselector;
    	let updating_selectedPlaylist;
    	let current;
    	let mounted;
    	let dispose;

    	function playlistselector_selectedPlaylist_binding(value) {
    		/*playlistselector_selectedPlaylist_binding*/ ctx[7](value);
    	}

    	let playlistselector_props = { type: "playlists" };

    	if (/*selectedPlaylist*/ ctx[0] !== void 0) {
    		playlistselector_props.selectedPlaylist = /*selectedPlaylist*/ ctx[0];
    	}

    	playlistselector = new Playlist_selector({
    			props: playlistselector_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistselector, "selectedPlaylist", playlistselector_selectedPlaylist_binding));
    	playlistselector.$on("selected", /*handleSelected*/ ctx[2]);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Add to playlist";
    			t1 = space();
    			label = element("label");
    			input = element("input");
    			t2 = text("\r\n    Skip duplicates");
    			t3 = space();
    			create_component(playlistselector.$$.fragment);
    			attr_dev(h4, "class", "svelte-tkf1fs");
    			add_location(h4, file$D, 28, 0, 699);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$D, 31, 4, 755);
    			attr_dev(label, "class", "toggle");
    			add_location(label, file$D, 30, 0, 727);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			input.checked = /*ignoreDuplicates*/ ctx[1];
    			append_dev(label, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(playlistselector, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*toggleIgnoreDuplicates*/ ctx[3], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[6])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ignoreDuplicates*/ 2) {
    				input.checked = /*ignoreDuplicates*/ ctx[1];
    			}

    			const playlistselector_changes = {};

    			if (!updating_selectedPlaylist && dirty & /*selectedPlaylist*/ 1) {
    				updating_selectedPlaylist = true;
    				playlistselector_changes.selectedPlaylist = /*selectedPlaylist*/ ctx[0];
    				add_flush_callback(() => updating_selectedPlaylist = false);
    			}

    			playlistselector.$set(playlistselector_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistselector.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistselector.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t3);
    			destroy_component(playlistselector, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlist_addTo", slots, []);
    	let { songs } = $$props;
    	let { isVisible } = $$props;
    	let selectedPlaylist;
    	let ignoreDuplicates = true;

    	function handleSelected() {
    		songs.forEach(element => {
    			addToPlaylist({
    				playlistID: selectedPlaylist.id,
    				songID: element.id,
    				ignoreDuplicates: ignoreDuplicates ? 1 : 0
    			});
    		});

    		$$invalidate(4, isVisible = false);
    	}

    	function toggleIgnoreDuplicates() {
    		$$invalidate(1, ignoreDuplicates = !ignoreDuplicates);
    	}

    	const writable_props = ["songs", "isVisible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlist_addTo> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		ignoreDuplicates = this.checked;
    		$$invalidate(1, ignoreDuplicates);
    	}

    	function playlistselector_selectedPlaylist_binding(value) {
    		selectedPlaylist = value;
    		$$invalidate(0, selectedPlaylist);
    	}

    	$$self.$$set = $$props => {
    		if ("songs" in $$props) $$invalidate(5, songs = $$props.songs);
    		if ("isVisible" in $$props) $$invalidate(4, isVisible = $$props.isVisible);
    	};

    	$$self.$capture_state = () => ({
    		addToPlaylist,
    		PlaylistSelector: Playlist_selector,
    		songs,
    		isVisible,
    		selectedPlaylist,
    		ignoreDuplicates,
    		handleSelected,
    		toggleIgnoreDuplicates
    	});

    	$$self.$inject_state = $$props => {
    		if ("songs" in $$props) $$invalidate(5, songs = $$props.songs);
    		if ("isVisible" in $$props) $$invalidate(4, isVisible = $$props.isVisible);
    		if ("selectedPlaylist" in $$props) $$invalidate(0, selectedPlaylist = $$props.selectedPlaylist);
    		if ("ignoreDuplicates" in $$props) $$invalidate(1, ignoreDuplicates = $$props.ignoreDuplicates);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedPlaylist,
    		ignoreDuplicates,
    		handleSelected,
    		toggleIgnoreDuplicates,
    		isVisible,
    		songs,
    		input_change_handler,
    		playlistselector_selectedPlaylist_binding
    	];
    }

    class Playlist_addTo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { songs: 5, isVisible: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlist_addTo",
    			options,
    			id: create_fragment$O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*songs*/ ctx[5] === undefined && !("songs" in props)) {
    			console.warn("<Playlist_addTo> was created without expected prop 'songs'");
    		}

    		if (/*isVisible*/ ctx[4] === undefined && !("isVisible" in props)) {
    			console.warn("<Playlist_addTo> was created without expected prop 'isVisible'");
    		}
    	}

    	get songs() {
    		throw new Error("<Playlist_addTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set songs(value) {
    		throw new Error("<Playlist_addTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVisible() {
    		throw new Error("<Playlist_addTo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVisible(value) {
    		throw new Error("<Playlist_addTo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\playlist_add.svg generated by Svelte v3.38.3 */

    function create_fragment$N(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M13 10H3c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H3c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1zm5 8v-3c0-.55-.45-1-1-1s-1 .45-1 1v3h-3c-.55 0-1 .45-1 1s.45 1 1 1h3v3c0 .55.45 1 1 1s1-.45 1-1v-3h3c.55 0 1-.45 1-1s-.45-1-1-1h-3zM3 16h6c.55 0 1-.45 1-1s-.45-1-1-1H3c-.55 0-1 .45-1 1s.45 1 1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$N($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Playlist_add extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});
    	}
    }

    /* public\images\menu_open.svg generated by Svelte v3.38.3 */

    function create_fragment$M(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			path2 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path2).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0,0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M4,18h11c0.55,0,1-0.45,1-1v0c0-0.55-0.45-1-1-1H4c-0.55,0-1,0.45-1,1v0C3,17.55,3.45,18,4,18z M4,13h8c0.55,0,1-0.45,1-1v0 c0-0.55-0.45-1-1-1H4c-0.55,0-1,0.45-1,1v0C3,12.55,3.45,13,4,13z M3,7L3,7c0,0.55,0.45,1,1,1h11c0.55,0,1-0.45,1-1v0 c0-0.55-0.45-1-1-1H4C3.45,6,3,6.45,3,7z M20.3,14.88L17.42,12l2.88-2.88c0.39-0.39,0.39-1.02,0-1.41l0,0 c-0.39-0.39-1.02-0.39-1.41,0l-3.59,3.59c-0.39,0.39-0.39,1.02,0,1.41l3.59,3.59c0.39,0.39,1.02,0.39,1.41,0l0,0 C20.68,15.91,20.69,15.27,20.3,14.88z");
    			attr(path2, "d", "M0,0h24v24H0V0z");
    			attr(path2, "fill", "none");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    			append(svg, path2);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$M($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Menu_open extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});
    	}
    }

    /* src\components\actions.svelte generated by Svelte v3.38.3 */
    const file$C = "src\\components\\actions.svelte";

    // (244:0) {#if mode === 'menu' || mode === 'subMenu'}
    function create_if_block_8$4(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;
    	let if_block0 = /*mode*/ ctx[1] !== "subMenu" && create_if_block_14$2(ctx);
    	let if_block1 = /*showShuffleNext*/ ctx[13] && create_if_block_13$2(ctx);
    	let if_block2 = /*showShuffleLast*/ ctx[14] && create_if_block_12$2(ctx);
    	let if_block3 = /*showPlaylistAdd*/ ctx[15] && create_if_block_11$2(ctx);
    	let if_block4 = /*showGoToArtist*/ ctx[16] && create_if_block_10$2(ctx);
    	let if_block5 = /*showGoToAlbum*/ ctx[17] && create_if_block_9$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", "c-actions menu svelte-19hv3qq");
    			add_location(div, file$C, 244, 4, 8303);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			/*div_binding*/ ctx[31](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*mode*/ ctx[1] !== "subMenu") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_14$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showShuffleNext*/ ctx[13]) if_block1.p(ctx, dirty);
    			if (/*showShuffleLast*/ ctx[14]) if_block2.p(ctx, dirty);
    			if (/*showPlaylistAdd*/ ctx[15]) if_block3.p(ctx, dirty);
    			if (/*showGoToArtist*/ ctx[16]) if_block4.p(ctx, dirty);
    			if (/*showGoToAlbum*/ ctx[17]) if_block5.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			/*div_binding*/ ctx[31](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$4.name,
    		type: "if",
    		source: "(244:0) {#if mode === 'menu' || mode === 'subMenu'}",
    		ctx
    	});

    	return block;
    }

    // (246:8) {#if mode !== 'subMenu'}
    function create_if_block_14$2(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let if_block3_anchor;
    	let current;
    	let if_block0 = /*showPlay*/ ctx[9] && create_if_block_18$2(ctx);
    	let if_block1 = /*showShuffle*/ ctx[12] && create_if_block_17$2(ctx);
    	let if_block2 = /*showPlayNext*/ ctx[10] && create_if_block_16$2(ctx);
    	let if_block3 = /*showPlayLast*/ ctx[11] && create_if_block_15$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showPlay*/ ctx[9]) if_block0.p(ctx, dirty);
    			if (/*showShuffle*/ ctx[12]) if_block1.p(ctx, dirty);
    			if (/*showPlayNext*/ ctx[10]) if_block2.p(ctx, dirty);
    			if (/*showPlayLast*/ ctx[11]) if_block3.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$2.name,
    		type: "if",
    		source: "(246:8) {#if mode !== 'subMenu'}",
    		ctx
    	});

    	return block;
    }

    // (247:12) {#if showPlay}
    function create_if_block_18$2(ctx) {
    	let div;
    	let button;
    	let svgplay;
    	let current;
    	let mounted;
    	let dispose;

    	svgplay = new Play({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgplay.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "primary svelte-19hv3qq");
    			attr_dev(button, "title", "Play");
    			add_location(button, file$C, 248, 20, 8475);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 247, 16, 8433);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgplay, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlay*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgplay);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$2.name,
    		type: "if",
    		source: "(247:12) {#if showPlay}",
    		ctx
    	});

    	return block;
    }

    // (253:12) {#if showShuffle}
    function create_if_block_17$2(ctx) {
    	let div;
    	let button;
    	let svgshuffle;
    	let current;
    	let mounted;
    	let dispose;

    	svgshuffle = new Shuffle({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgshuffle.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "secondary svelte-19hv3qq");
    			attr_dev(button, "title", "Shuffle");
    			add_location(button, file$C, 254, 20, 8720);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 253, 16, 8678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgshuffle, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShuffle*/ ctx[22], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgshuffle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgshuffle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgshuffle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$2.name,
    		type: "if",
    		source: "(253:12) {#if showShuffle}",
    		ctx
    	});

    	return block;
    }

    // (259:12) {#if showPlayNext}
    function create_if_block_16$2(ctx) {
    	let div;
    	let button;
    	let svgplaynext;
    	let current;
    	let mounted;
    	let dispose;

    	svgplaynext = new Menu_open({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgplaynext.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Play next");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 260, 20, 8978);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 259, 16, 8936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgplaynext, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlayNext*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplaynext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplaynext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgplaynext);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$2.name,
    		type: "if",
    		source: "(259:12) {#if showPlayNext}",
    		ctx
    	});

    	return block;
    }

    // (265:12) {#if showPlayLast}
    function create_if_block_15$2(ctx) {
    	let div;
    	let button;
    	let svgqueue;
    	let current;
    	let mounted;
    	let dispose;

    	svgqueue = new Playlist_add({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgqueue.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Add to queue");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 266, 20, 9221);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 265, 16, 9179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgqueue, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlayLast*/ ctx[21], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgqueue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgqueue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgqueue);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$2.name,
    		type: "if",
    		source: "(265:12) {#if showPlayLast}",
    		ctx
    	});

    	return block;
    }

    // (272:8) {#if showShuffleNext}
    function create_if_block_13$2(ctx) {
    	let div;
    	let button;
    	let svgshuffle;
    	let current;
    	let mounted;
    	let dispose;

    	svgshuffle = new Shuffle({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgshuffle.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Shuffle next");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 273, 16, 9470);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 272, 12, 9432);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgshuffle, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShuffleNext*/ ctx[23], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgshuffle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgshuffle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgshuffle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$2.name,
    		type: "if",
    		source: "(272:8) {#if showShuffleNext}",
    		ctx
    	});

    	return block;
    }

    // (278:8) {#if showShuffleLast}
    function create_if_block_12$2(ctx) {
    	let div;
    	let button;
    	let svgshuffle;
    	let current;
    	let mounted;
    	let dispose;

    	svgshuffle = new Shuffle({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgshuffle.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Shuffle last");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 279, 16, 9701);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 278, 12, 9663);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgshuffle, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShuffleLast*/ ctx[24], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgshuffle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgshuffle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgshuffle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$2.name,
    		type: "if",
    		source: "(278:8) {#if showShuffleLast}",
    		ctx
    	});

    	return block;
    }

    // (284:8) {#if showPlaylistAdd}
    function create_if_block_11$2(ctx) {
    	let div;
    	let button;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "id", button_id_value = "js-action-playlist_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]);
    			attr_dev(button, "title", "Add to playlist");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 285, 16, 9932);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 284, 12, 9894);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleAddToPlaylist*/ ctx[25], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*type, mode, id*/ 7 && button_id_value !== (button_id_value = "js-action-playlist_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2])) {
    				attr_dev(button, "id", button_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$2.name,
    		type: "if",
    		source: "(284:8) {#if showPlaylistAdd}",
    		ctx
    	});

    	return block;
    }

    // (290:8) {#if showGoToArtist}
    function create_if_block_10$2(ctx) {
    	let div;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*artistID*/ ctx[3],
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 290, 12, 10140);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(link, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*artistID*/ 8) link_changes.to = "artists/" + /*artistID*/ ctx[3];

    			if (dirty[1] & /*$$scope*/ 4096) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(290:8) {#if showGoToArtist}",
    		ctx
    	});

    	return block;
    }

    // (292:16) <Link to="artists/{artistID}">
    function create_default_slot_3$6(ctx) {
    	let svgartist;
    	let t;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t = text(" Go to artist");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(292:16) <Link to=\\\"artists/{artistID}\\\">",
    		ctx
    	});

    	return block;
    }

    // (296:8) {#if showGoToAlbum}
    function create_if_block_9$4(ctx) {
    	let div;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/" + /*albumID*/ ctx[4],
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 296, 12, 10336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(link, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*albumID*/ 16) link_changes.to = "albums/" + /*albumID*/ ctx[4];

    			if (dirty[1] & /*$$scope*/ 4096) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$4.name,
    		type: "if",
    		source: "(296:8) {#if showGoToAlbum}",
    		ctx
    	});

    	return block;
    }

    // (298:16) <Link to="albums/{albumID}">
    function create_default_slot_2$8(ctx) {
    	let svgalbum;
    	let t;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t = text(" Go to album");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(298:16) <Link to=\\\"albums/{albumID}\\\">",
    		ctx
    	});

    	return block;
    }

    // (304:0) {#if playlistAddIsVisible}
    function create_if_block_7$6(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[34](value);
    	}

    	let menu_props = {
    		anchor: "left-center",
    		toggleElement: document.querySelector("#js-action-playlist_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]),
    		$$slots: { default: [create_default_slot_1$b] },
    		$$scope: { ctx }
    	};

    	if (/*playlistAddIsVisible*/ ctx[6] !== void 0) {
    		menu_props.isVisible = /*playlistAddIsVisible*/ ctx[6];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty[0] & /*type, mode, id*/ 7) menu_changes.toggleElement = document.querySelector("#js-action-playlist_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]);

    			if (dirty[0] & /*songsForPlaylistAdd, playlistAddIsVisible*/ 192 | dirty[1] & /*$$scope*/ 4096) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty[0] & /*playlistAddIsVisible*/ 64) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*playlistAddIsVisible*/ ctx[6];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$6.name,
    		type: "if",
    		source: "(304:0) {#if playlistAddIsVisible}",
    		ctx
    	});

    	return block;
    }

    // (305:4) <Menu anchor="left-center" toggleElement={document.querySelector("#js-action-playlist_" + type + mode + id)} bind:isVisible={playlistAddIsVisible}>
    function create_default_slot_1$b(ctx) {
    	let playlistaddto;
    	let updating_songs;
    	let updating_isVisible;
    	let current;

    	function playlistaddto_songs_binding(value) {
    		/*playlistaddto_songs_binding*/ ctx[32](value);
    	}

    	function playlistaddto_isVisible_binding(value) {
    		/*playlistaddto_isVisible_binding*/ ctx[33](value);
    	}

    	let playlistaddto_props = {};

    	if (/*songsForPlaylistAdd*/ ctx[7] !== void 0) {
    		playlistaddto_props.songs = /*songsForPlaylistAdd*/ ctx[7];
    	}

    	if (/*playlistAddIsVisible*/ ctx[6] !== void 0) {
    		playlistaddto_props.isVisible = /*playlistAddIsVisible*/ ctx[6];
    	}

    	playlistaddto = new Playlist_addTo({
    			props: playlistaddto_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistaddto, "songs", playlistaddto_songs_binding));
    	binding_callbacks.push(() => bind(playlistaddto, "isVisible", playlistaddto_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(playlistaddto.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistaddto, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistaddto_changes = {};

    			if (!updating_songs && dirty[0] & /*songsForPlaylistAdd*/ 128) {
    				updating_songs = true;
    				playlistaddto_changes.songs = /*songsForPlaylistAdd*/ ctx[7];
    				add_flush_callback(() => updating_songs = false);
    			}

    			if (!updating_isVisible && dirty[0] & /*playlistAddIsVisible*/ 64) {
    				updating_isVisible = true;
    				playlistaddto_changes.isVisible = /*playlistAddIsVisible*/ ctx[6];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			playlistaddto.$set(playlistaddto_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistaddto.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistaddto.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistaddto, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(305:4) <Menu anchor=\\\"left-center\\\" toggleElement={document.querySelector(\\\"#js-action-playlist_\\\" + type + mode + id)} bind:isVisible={playlistAddIsVisible}>",
    		ctx
    	});

    	return block;
    }

    // (310:0) {#if mode === 'miniButtons' || mode === 'fullButtons'}
    function create_if_block$s(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let div_class_value;
    	let current;
    	let if_block0 = /*showPlay*/ ctx[9] && create_if_block_6$7(ctx);
    	let if_block1 = /*showShuffle*/ ctx[12] && create_if_block_5$7(ctx);
    	let if_block2 = /*showPlayNext*/ ctx[10] && create_if_block_4$9(ctx);
    	let if_block3 = /*showPlayLast*/ ctx[11] && create_if_block_3$b(ctx);
    	let if_block4 = /*showMore*/ ctx[18] && create_if_block_2$h(ctx);
    	let if_block5 = /*moreMenuVisible*/ ctx[5] && create_if_block_1$k(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", div_class_value = "c-actions " + /*mode*/ ctx[1] + " svelte-19hv3qq");
    			add_location(div, file$C, 310, 4, 10867);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			/*div_binding_1*/ ctx[36](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showPlay*/ ctx[9]) if_block0.p(ctx, dirty);
    			if (/*showShuffle*/ ctx[12]) if_block1.p(ctx, dirty);
    			if (/*showPlayNext*/ ctx[10]) if_block2.p(ctx, dirty);
    			if (/*showPlayLast*/ ctx[11]) if_block3.p(ctx, dirty);
    			if (/*showMore*/ ctx[18]) if_block4.p(ctx, dirty);

    			if (/*moreMenuVisible*/ ctx[5]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*moreMenuVisible*/ 32) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_1$k(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*mode*/ 2 && div_class_value !== (div_class_value = "c-actions " + /*mode*/ ctx[1] + " svelte-19hv3qq")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			/*div_binding_1*/ ctx[36](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(310:0) {#if mode === 'miniButtons' || mode === 'fullButtons'}",
    		ctx
    	});

    	return block;
    }

    // (312:8) {#if showPlay}
    function create_if_block_6$7(ctx) {
    	let div;
    	let button;
    	let svgplay;
    	let current;
    	let mounted;
    	let dispose;
    	svgplay = new Play({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgplay.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "primary svelte-19hv3qq");
    			attr_dev(button, "title", "Play");
    			add_location(button, file$C, 313, 16, 10995);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 312, 12, 10957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgplay, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlay*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgplay);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$7.name,
    		type: "if",
    		source: "(312:8) {#if showPlay}",
    		ctx
    	});

    	return block;
    }

    // (318:8) {#if showShuffle}
    function create_if_block_5$7(ctx) {
    	let div;
    	let button;
    	let svgshuffle;
    	let current;
    	let mounted;
    	let dispose;

    	svgshuffle = new Shuffle({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgshuffle.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "secondary svelte-19hv3qq");
    			attr_dev(button, "title", "Shuffle");
    			add_location(button, file$C, 319, 16, 11205);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 318, 12, 11167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgshuffle, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShuffle*/ ctx[22], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgshuffle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgshuffle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgshuffle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$7.name,
    		type: "if",
    		source: "(318:8) {#if showShuffle}",
    		ctx
    	});

    	return block;
    }

    // (324:8) {#if showPlayNext}
    function create_if_block_4$9(ctx) {
    	let div;
    	let button;
    	let svgplaynext;
    	let current;
    	let mounted;
    	let dispose;

    	svgplaynext = new Menu_open({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgplaynext.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Play next");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 325, 16, 11452);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 324, 12, 11414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgplaynext, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlayNext*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplaynext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplaynext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgplaynext);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$9.name,
    		type: "if",
    		source: "(324:8) {#if showPlayNext}",
    		ctx
    	});

    	return block;
    }

    // (330:8) {#if showPlayLast}
    function create_if_block_3$b(ctx) {
    	let div;
    	let button;
    	let svgqueue;
    	let current;
    	let mounted;
    	let dispose;

    	svgqueue = new Playlist_add({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgqueue.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "Add to queue");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 331, 16, 11685);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 330, 12, 11647);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgqueue, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handlePlayLast*/ ctx[21], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgqueue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgqueue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgqueue);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$b.name,
    		type: "if",
    		source: "(330:8) {#if showPlayLast}",
    		ctx
    	});

    	return block;
    }

    // (336:8) {#if showMore}
    function create_if_block_2$h(ctx) {
    	let div;
    	let button;
    	let svgmore;
    	let button_id_value;
    	let current;
    	let mounted;
    	let dispose;
    	svgmore = new MoreHori({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgmore.$$.fragment);
    			attr_dev(button, "id", button_id_value = "js-action-menu_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "title", "More");
    			attr_dev(button, "class", "svelte-19hv3qq");
    			add_location(button, file$C, 337, 16, 11914);
    			attr_dev(div, "class", "action");
    			add_location(div, file$C, 336, 12, 11876);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgmore, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleMore*/ ctx[26], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*type, mode, id*/ 7 && button_id_value !== (button_id_value = "js-action-menu_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2])) {
    				attr_dev(button, "id", button_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgmore.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgmore.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgmore);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$h.name,
    		type: "if",
    		source: "(336:8) {#if showMore}",
    		ctx
    	});

    	return block;
    }

    // (342:8) {#if moreMenuVisible}
    function create_if_block_1$k(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_1(value) {
    		/*menu_isVisible_binding_1*/ ctx[35](value);
    	}

    	let menu_props = {
    		anchor: "bottom-center",
    		toggleElement: document.querySelector("#js-action-menu_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]),
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};

    	if (/*moreMenuVisible*/ ctx[5] !== void 0) {
    		menu_props.isVisible = /*moreMenuVisible*/ ctx[5];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_1));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty[0] & /*type, mode, id*/ 7) menu_changes.toggleElement = document.querySelector("#js-action-menu_" + /*type*/ ctx[0] + /*mode*/ ctx[1] + /*id*/ ctx[2]);

    			if (dirty[0] & /*$$props*/ 134217728 | dirty[1] & /*$$scope*/ 4096) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty[0] & /*moreMenuVisible*/ 32) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*moreMenuVisible*/ ctx[5];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(342:8) {#if moreMenuVisible}",
    		ctx
    	});

    	return block;
    }

    // (343:12) <Menu anchor="bottom-center" toggleElement={document.querySelector("#js-action-menu_" + type + mode + id)} bind:isVisible={moreMenuVisible} >
    function create_default_slot$k(ctx) {
    	let actions;
    	let current;
    	const actions_spread_levels = [/*$$props*/ ctx[27], { mode: "subMenu" }];
    	let actions_props = {};

    	for (let i = 0; i < actions_spread_levels.length; i += 1) {
    		actions_props = assign(actions_props, actions_spread_levels[i]);
    	}

    	actions = new Actions({ props: actions_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = (dirty[0] & /*$$props*/ 134217728)
    			? get_spread_update(actions_spread_levels, [get_spread_object(/*$$props*/ ctx[27]), actions_spread_levels[1]])
    			: {};

    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(343:12) <Menu anchor=\\\"bottom-center\\\" toggleElement={document.querySelector(\\\"#js-action-menu_\\\" + type + mode + id)} bind:isVisible={moreMenuVisible} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = (/*mode*/ ctx[1] === "menu" || /*mode*/ ctx[1] === "subMenu") && create_if_block_8$4(ctx);
    	let if_block1 = /*playlistAddIsVisible*/ ctx[6] && create_if_block_7$6(ctx);
    	let if_block2 = (/*mode*/ ctx[1] === "miniButtons" || /*mode*/ ctx[1] === "fullButtons") && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*mode*/ ctx[1] === "menu" || /*mode*/ ctx[1] === "subMenu") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*playlistAddIsVisible*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*playlistAddIsVisible*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_7$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*mode*/ ctx[1] === "miniButtons" || /*mode*/ ctx[1] === "fullButtons") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$s(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function startLoad(el) {
    	let dimensions = el.getBoundingClientRect();
    	let original = el.innerHTML;
    	el.style.width = dimensions.right - dimensions.left + "px";
    	el.style.height = dimensions.bottom - dimensions.top + "px";
    	el.classList.add("loading");
    	el.innerHTML = "";
    	return original;
    }

    function endLoad(el, text) {
    	el.innerHTML = text;
    	el.classList.remove("loading");
    	el.style = null;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $MediaPlayer;
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(38, $MediaPlayer = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Actions", slots, []);
    	let { type } = $$props; // artist, album, playlist, song etc
    	let { mode } = $$props; // menu, miniButtons or fullButtons
    	let { id = null } = $$props; // id of the item passed specified by type
    	let { count = null } = $$props; // how many items
    	let { direct = null } = $$props; // play already loaded items instead of doing a new fetch
    	let { data = null } = $$props; // any additional data to pass
    	let { artistID = null } = $$props;
    	let { albumID = null } = $$props;
    	let fetchURL = null;
    	let message = "";
    	let moreMenuVisible = false;
    	let moreToggle;
    	let playlistAddToggle;
    	let playlistAddIsVisible = false;
    	let songsForPlaylistAdd = [];
    	let container;
    	let showPlay = count > 0 || count === null;
    	let showPlayNext = count > 0 || count === null;
    	let showPlayLast = count > 0 || count === null;
    	let showShuffle = count > 1 || count === null;
    	let showShuffleNext = count > 1 || count === null;
    	let showShuffleLast = count > 1 || count === null;
    	let showPlaylistAdd = true;
    	let showGoToArtist = artistID;
    	let showGoToAlbum = albumID;
    	let showMore = true;

    	function determineFetchURL() {
    		switch (type) {
    			case "artist":
    				fetchURL = getSongsFromArtist(id);
    				break;
    			case "artistAlpha":
    				fetchURL = getSongsFromArtistsStartingWith(data.char);
    				break;
    			case "artistGenre":
    				fetchURL = getSomeSongsFromArtistsByGenre(data);
    				break;
    			case "album":
    				fetchURL = getSongsFromAlbum(id);
    				break;
    			case "albumGenre":
    				fetchURL = getSomeSongsFromAlbumsByGenre(data);
    				break;
    			case "albumAlpha":
    				fetchURL = getSongsFromAlbumsStartingWith(data.char);
    				break;
    			case "song":
    				fetchURL = getSong(id);
    				break;
    			case "songGenre":
    				fetchURL = getSomeSongsByGenre(data);
    				break;
    			case "playlist":
    				fetchURL = getSongsFromPlaylist(id);
    				break;
    			case "year":
    				fetchURL = getSongsByYear(data.from, data.to);
    				break;
    		}

    		return fetchURL;
    	}

    	function handlePlay(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playNow([...direct]);
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				$MediaPlayer.playNow(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	function handlePlayNext(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playNext([...direct]);
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				$MediaPlayer.playNext(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	function handlePlayLast(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playLast([...direct]);
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				$MediaPlayer.playLast(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	function handleShuffle(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playNow(shuffleArray([...direct]));
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				result = shuffleArray(result);
    				$MediaPlayer.playNow(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	function handleShuffleNext(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playNext([...direct]);
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				result = shuffleArray(result);
    				$MediaPlayer.playNext(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	function handleShuffleLast(e) {
    		let originalText = startLoad(e.target);

    		if (direct) {
    			$MediaPlayer.playLast([...direct]);
    			endLoad(e.target, originalText);
    		} else {
    			determineFetchURL().then(result => {
    				result = Array.isArray(result) ? result : [result];
    				result = shuffleArray(result);
    				$MediaPlayer.playLast(result);
    				endLoad(e.target, originalText);
    			});
    		}
    	}

    	// songsForPlaylistAdd is a bind
    	async function handleAddToPlaylist() {
    		$$invalidate(6, playlistAddIsVisible = !playlistAddIsVisible);
    		await tick();

    		if (playlistAddIsVisible) {
    			if (direct) {
    				$$invalidate(7, songsForPlaylistAdd = [...direct]);
    			} else {
    				determineFetchURL().then(result => {
    					result = Array.isArray(result) ? result : [result];
    					$$invalidate(7, songsForPlaylistAdd = result);
    				});
    			}
    		}
    	}

    	function handleMore() {
    		$$invalidate(5, moreMenuVisible = !moreMenuVisible);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(8, container);
    		});
    	}

    	function playlistaddto_songs_binding(value) {
    		songsForPlaylistAdd = value;
    		$$invalidate(7, songsForPlaylistAdd);
    	}

    	function playlistaddto_isVisible_binding(value) {
    		playlistAddIsVisible = value;
    		$$invalidate(6, playlistAddIsVisible);
    	}

    	function menu_isVisible_binding(value) {
    		playlistAddIsVisible = value;
    		$$invalidate(6, playlistAddIsVisible);
    	}

    	function menu_isVisible_binding_1(value) {
    		moreMenuVisible = value;
    		$$invalidate(5, moreMenuVisible);
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(8, container);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
    		if ("mode" in $$new_props) $$invalidate(1, mode = $$new_props.mode);
    		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
    		if ("count" in $$new_props) $$invalidate(28, count = $$new_props.count);
    		if ("direct" in $$new_props) $$invalidate(29, direct = $$new_props.direct);
    		if ("data" in $$new_props) $$invalidate(30, data = $$new_props.data);
    		if ("artistID" in $$new_props) $$invalidate(3, artistID = $$new_props.artistID);
    		if ("albumID" in $$new_props) $$invalidate(4, albumID = $$new_props.albumID);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		Link,
    		MediaPlayer,
    		getSongsFromAlbum,
    		getSongsFromArtist,
    		getSongsFromPlaylist,
    		getSong,
    		getSongsByYear,
    		getSongsFromAlbumsStartingWith,
    		getSongsFromArtistsStartingWith,
    		getSomeSongsFromArtistsByGenre,
    		getSomeSongsFromAlbumsByGenre,
    		getSomeSongsByGenre,
    		shuffleArray,
    		Menu,
    		PlaylistAddTo: Playlist_addTo,
    		SVGPlay: Play,
    		SVGQueue: Playlist_add,
    		SVGPlayNext: Menu_open,
    		SVGShuffle: Shuffle,
    		SVGMore: MoreHori,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		type,
    		mode,
    		id,
    		count,
    		direct,
    		data,
    		artistID,
    		albumID,
    		fetchURL,
    		message,
    		moreMenuVisible,
    		moreToggle,
    		playlistAddToggle,
    		playlistAddIsVisible,
    		songsForPlaylistAdd,
    		container,
    		showPlay,
    		showPlayNext,
    		showPlayLast,
    		showShuffle,
    		showShuffleNext,
    		showShuffleLast,
    		showPlaylistAdd,
    		showGoToArtist,
    		showGoToAlbum,
    		showMore,
    		determineFetchURL,
    		handlePlay,
    		handlePlayNext,
    		handlePlayLast,
    		handleShuffle,
    		handleShuffleNext,
    		handleShuffleLast,
    		handleAddToPlaylist,
    		handleMore,
    		startLoad,
    		endLoad,
    		$MediaPlayer
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
    		if ("mode" in $$props) $$invalidate(1, mode = $$new_props.mode);
    		if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
    		if ("count" in $$props) $$invalidate(28, count = $$new_props.count);
    		if ("direct" in $$props) $$invalidate(29, direct = $$new_props.direct);
    		if ("data" in $$props) $$invalidate(30, data = $$new_props.data);
    		if ("artistID" in $$props) $$invalidate(3, artistID = $$new_props.artistID);
    		if ("albumID" in $$props) $$invalidate(4, albumID = $$new_props.albumID);
    		if ("fetchURL" in $$props) fetchURL = $$new_props.fetchURL;
    		if ("message" in $$props) message = $$new_props.message;
    		if ("moreMenuVisible" in $$props) $$invalidate(5, moreMenuVisible = $$new_props.moreMenuVisible);
    		if ("moreToggle" in $$props) moreToggle = $$new_props.moreToggle;
    		if ("playlistAddToggle" in $$props) playlistAddToggle = $$new_props.playlistAddToggle;
    		if ("playlistAddIsVisible" in $$props) $$invalidate(6, playlistAddIsVisible = $$new_props.playlistAddIsVisible);
    		if ("songsForPlaylistAdd" in $$props) $$invalidate(7, songsForPlaylistAdd = $$new_props.songsForPlaylistAdd);
    		if ("container" in $$props) $$invalidate(8, container = $$new_props.container);
    		if ("showPlay" in $$props) $$invalidate(9, showPlay = $$new_props.showPlay);
    		if ("showPlayNext" in $$props) $$invalidate(10, showPlayNext = $$new_props.showPlayNext);
    		if ("showPlayLast" in $$props) $$invalidate(11, showPlayLast = $$new_props.showPlayLast);
    		if ("showShuffle" in $$props) $$invalidate(12, showShuffle = $$new_props.showShuffle);
    		if ("showShuffleNext" in $$props) $$invalidate(13, showShuffleNext = $$new_props.showShuffleNext);
    		if ("showShuffleLast" in $$props) $$invalidate(14, showShuffleLast = $$new_props.showShuffleLast);
    		if ("showPlaylistAdd" in $$props) $$invalidate(15, showPlaylistAdd = $$new_props.showPlaylistAdd);
    		if ("showGoToArtist" in $$props) $$invalidate(16, showGoToArtist = $$new_props.showGoToArtist);
    		if ("showGoToAlbum" in $$props) $$invalidate(17, showGoToAlbum = $$new_props.showGoToAlbum);
    		if ("showMore" in $$props) $$invalidate(18, showMore = $$new_props.showMore);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		type,
    		mode,
    		id,
    		artistID,
    		albumID,
    		moreMenuVisible,
    		playlistAddIsVisible,
    		songsForPlaylistAdd,
    		container,
    		showPlay,
    		showPlayNext,
    		showPlayLast,
    		showShuffle,
    		showShuffleNext,
    		showShuffleLast,
    		showPlaylistAdd,
    		showGoToArtist,
    		showGoToAlbum,
    		showMore,
    		handlePlay,
    		handlePlayNext,
    		handlePlayLast,
    		handleShuffle,
    		handleShuffleNext,
    		handleShuffleLast,
    		handleAddToPlaylist,
    		handleMore,
    		$$props,
    		count,
    		direct,
    		data,
    		div_binding,
    		playlistaddto_songs_binding,
    		playlistaddto_isVisible_binding,
    		menu_isVisible_binding,
    		menu_isVisible_binding_1,
    		div_binding_1
    	];
    }

    class Actions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$L,
    			create_fragment$L,
    			safe_not_equal,
    			{
    				type: 0,
    				mode: 1,
    				id: 2,
    				count: 28,
    				direct: 29,
    				data: 30,
    				artistID: 3,
    				albumID: 4
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Actions",
    			options,
    			id: create_fragment$L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*type*/ ctx[0] === undefined && !("type" in props)) {
    			console.warn("<Actions> was created without expected prop 'type'");
    		}

    		if (/*mode*/ ctx[1] === undefined && !("mode" in props)) {
    			console.warn("<Actions> was created without expected prop 'mode'");
    		}
    	}

    	get type() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direct() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direct(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get artistID() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set artistID(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get albumID() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set albumID(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\music_note.svg generated by Svelte v3.38.3 */

    function create_fragment$K(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M12 5v8.55c-.94-.54-2.1-.75-3.33-.32-1.34.48-2.37 1.67-2.61 3.07-.46 2.74 1.86 5.08 4.59 4.65 1.96-.31 3.35-2.11 3.35-4.1V7h2c1.1 0 2-.9 2-2s-.9-2-2-2h-2c-1.1 0-2 .9-2 2z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$K($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Music_note extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});
    	}
    }

    /* public\images\center_focus.svg generated by Svelte v3.38.3 */

    function create_fragment$J(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M4 15c-.55 0-1 .45-1 1v3c0 1.1.9 2 2 2h3c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1-.45-1-1v-2c0-.55-.45-1-1-1zm1-9c0-.55.45-1 1-1h2c.55 0 1-.45 1-1s-.45-1-1-1H5c-1.1 0-2 .9-2 2v3c0 .55.45 1 1 1s1-.45 1-1V6zm14-3h-3c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1 .45 1 1v2c0 .55.45 1 1 1s1-.45 1-1V5c0-1.1-.9-2-2-2zm0 15c0 .55-.45 1-1 1h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c1.1 0 2-.9 2-2v-3c0-.55-.45-1-1-1s-1 .45-1 1v2zm-7-9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$J($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Center_focus extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});
    	}
    }

    /* src\components\lister.svelte generated by Svelte v3.38.3 */
    const file$B = "src\\components\\lister.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[49] = list[i];
    	child_ctx[50] = list;
    	child_ctx[51] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[52] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[52] = list[i];
    	return child_ctx;
    }

    // (337:16) {#if type === 'playlist'}
    function create_if_block_19(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = " ";
    			attr_dev(div, "class", "svelte-mv9rt0");
    			add_location(div, file$B, 337, 20, 11486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(337:16) {#if type === 'playlist'}",
    		ctx
    	});

    	return block;
    }

    // (341:16) {#if showIndex}
    function create_if_block_18$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "#";
    			attr_dev(div, "class", "index svelte-mv9rt0");
    			attr_dev(div, "data-sort", "index");
    			add_location(div, file$B, 341, 20, 11583);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*handleSort*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$1.name,
    		type: "if",
    		source: "(341:16) {#if showIndex}",
    		ctx
    	});

    	return block;
    }

    // (345:16) {#if showArt}
    function create_if_block_17$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = " ";
    			attr_dev(div, "class", "thumb svelte-mv9rt0");
    			add_location(div, file$B, 345, 20, 11727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$1.name,
    		type: "if",
    		source: "(345:16) {#if showArt}",
    		ctx
    	});

    	return block;
    }

    // (351:16) {#if type === "song" || type === "playlist" || type === "smartlist"}
    function create_if_block_16$1(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Artist";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Album";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Date";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Length";
    			attr_dev(div0, "class", "artist svelte-mv9rt0");
    			attr_dev(div0, "data-sort", "artist");
    			add_location(div0, file$B, 351, 20, 11980);
    			attr_dev(div1, "class", "album svelte-mv9rt0");
    			attr_dev(div1, "data-sort", "album");
    			add_location(div1, file$B, 352, 20, 12075);
    			attr_dev(div2, "class", "date svelte-mv9rt0");
    			attr_dev(div2, "data-sort", "date");
    			add_location(div2, file$B, 353, 20, 12167);
    			attr_dev(div3, "class", "length svelte-mv9rt0");
    			attr_dev(div3, "data-sort", "time");
    			add_location(div3, file$B, 354, 20, 12256);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div1, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div2, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div3, "click", /*handleSort*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$1.name,
    		type: "if",
    		source: "(351:16) {#if type === \\\"song\\\" || type === \\\"playlist\\\" || type === \\\"smartlist\\\"}",
    		ctx
    	});

    	return block;
    }

    // (358:16) {#if type === "artist"}
    function create_if_block_15$1(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Releases";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Songs";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Genres";
    			attr_dev(div0, "class", "releases svelte-mv9rt0");
    			attr_dev(div0, "data-sort", "releases");
    			add_location(div0, file$B, 358, 20, 12415);
    			attr_dev(div1, "class", "songs svelte-mv9rt0");
    			attr_dev(div1, "data-sort", "songs");
    			add_location(div1, file$B, 359, 20, 12516);
    			attr_dev(div2, "class", "genres svelte-mv9rt0");
    			add_location(div2, file$B, 360, 20, 12608);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div1, "click", /*handleSort*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$1.name,
    		type: "if",
    		source: "(358:16) {#if type === \\\"artist\\\"}",
    		ctx
    	});

    	return block;
    }

    // (364:16) {#if type === "album"}
    function create_if_block_14$1(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Artist";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Date";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Songs";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Genres";
    			attr_dev(div0, "class", "artist svelte-mv9rt0");
    			attr_dev(div0, "data-sort", "artist");
    			add_location(div0, file$B, 364, 20, 12727);
    			attr_dev(div1, "class", "date svelte-mv9rt0");
    			attr_dev(div1, "data-sort", "date");
    			add_location(div1, file$B, 365, 20, 12822);
    			attr_dev(div2, "class", "songs svelte-mv9rt0");
    			attr_dev(div2, "data-sort", "songs");
    			add_location(div2, file$B, 366, 20, 12911);
    			attr_dev(div3, "class", "genres svelte-mv9rt0");
    			add_location(div3, file$B, 367, 20, 13003);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div1, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div2, "click", /*handleSort*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$1.name,
    		type: "if",
    		source: "(364:16) {#if type === \\\"album\\\"}",
    		ctx
    	});

    	return block;
    }

    // (371:16) {#if type === "genre"}
    function create_if_block_13$1(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Artists";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Albums";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Songs";
    			attr_dev(div0, "class", "artists svelte-mv9rt0");
    			attr_dev(div0, "data-sort", "genreArtists");
    			add_location(div0, file$B, 371, 20, 13122);
    			attr_dev(div1, "class", "albums svelte-mv9rt0");
    			attr_dev(div1, "data-sort", "genreAlbums");
    			add_location(div1, file$B, 372, 20, 13225);
    			attr_dev(div2, "class", "songs svelte-mv9rt0");
    			attr_dev(div2, "data-sort", "genreSongs");
    			add_location(div2, file$B, 373, 20, 13325);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div1, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div2, "click", /*handleSort*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(371:16) {#if type === \\\"genre\\\"}",
    		ctx
    	});

    	return block;
    }

    // (377:16) {#if showRating}
    function create_if_block_12$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Rating";
    			attr_dev(div, "class", "rating svelte-mv9rt0");
    			attr_dev(div, "data-sort", "rating");
    			add_location(div, file$B, 377, 20, 13481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*handleSort*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(377:16) {#if showRating}",
    		ctx
    	});

    	return block;
    }

    // (381:16) {#if showActions}
    function create_if_block_11$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = " ";
    			attr_dev(div, "class", "actions svelte-mv9rt0");
    			add_location(div, file$B, 381, 20, 13636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(381:16) {#if showActions}",
    		ctx
    	});

    	return block;
    }

    // (388:20) {#if type === 'playlist'}
    function create_if_block_10$1(ctx) {
    	let div;
    	let button;
    	let svgclose;
    	let current;
    	let mounted;
    	let dispose;
    	svgclose = new Close({ $$inline: true });

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[22](/*item*/ ctx[49], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(svgclose.$$.fragment);
    			attr_dev(button, "class", "icon remove");
    			add_location(button, file$B, 388, 29, 13887);
    			attr_dev(div, "class", "svelte-mv9rt0");
    			add_location(div, file$B, 388, 24, 13882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(svgclose, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(click_handler), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgclose.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgclose.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgclose);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(388:20) {#if type === 'playlist'}",
    		ctx
    	});

    	return block;
    }

    // (392:20) {#if showIndex}
    function create_if_block_9$3(ctx) {
    	let div;
    	let t_value = /*item*/ ctx[49].initialOrder + 1 + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "index svelte-mv9rt0");
    			add_location(div, file$B, 392, 24, 14094);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256 && t_value !== (t_value = /*item*/ ctx[49].initialOrder + 1 + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$3.name,
    		type: "if",
    		source: "(392:20) {#if showIndex}",
    		ctx
    	});

    	return block;
    }

    // (396:20) {#if showArt}
    function create_if_block_8$3(ctx) {
    	let div;
    	let previous_key = /*item*/ ctx[49].art;
    	let key_block = create_key_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "thumb svelte-mv9rt0");
    			add_location(div, file$B, 396, 24, 14232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256 && safe_not_equal(previous_key, previous_key = /*item*/ ctx[49].art)) {
    				key_block.d(1);
    				key_block = create_key_block$5(ctx);
    				key_block.c();
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$3.name,
    		type: "if",
    		source: "(396:20) {#if showArt}",
    		ctx
    	});

    	return block;
    }

    // (398:28) {#key item.art}
    function create_key_block$5(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "" + (/*item*/ ctx[49].art + "&thumb=1"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "height", "40");
    			attr_dev(img, "width", "40");
    			attr_dev(img, "class", "svelte-mv9rt0");
    			add_location(img, file$B, 398, 32, 14330);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256 && img.src !== (img_src_value = "" + (/*item*/ ctx[49].art + "&thumb=1"))) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$5.name,
    		type: "key",
    		source: "(398:28) {#key item.art}",
    		ctx
    	});

    	return block;
    }

    // (404:20) {#if type === "song" || type === "playlist" || type === 'smartlist'}
    function create_if_block_7$5(ctx) {
    	let div0;
    	let span;
    	let t0_value = /*item*/ ctx[49].name + "";
    	let t0;
    	let div0_title_value;
    	let t1;
    	let div1;
    	let link0;
    	let div1_title_value;
    	let t2;
    	let div2;
    	let link1;
    	let div2_title_value;
    	let t3;
    	let div3;
    	let link2;
    	let t4;
    	let div4;
    	let t5_value = formatSongLength(/*item*/ ctx[49].time) + "";
    	let t5;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "artists/" + /*item*/ ctx[49].artist.id,
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "albums/" + /*item*/ ctx[49].album.id,
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				to: "albums/year/" + /*item*/ ctx[49].year,
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(link1.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(link2.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			t5 = text(t5_value);
    			attr_dev(span, "class", "svelte-mv9rt0");
    			add_location(span, file$B, 405, 28, 14673);
    			attr_dev(div0, "class", "title svelte-mv9rt0");
    			attr_dev(div0, "title", div0_title_value = /*item*/ ctx[49].name);
    			add_location(div0, file$B, 404, 24, 14604);
    			attr_dev(div1, "class", "artist svelte-mv9rt0");
    			attr_dev(div1, "title", div1_title_value = /*item*/ ctx[49].artist.name);
    			add_location(div1, file$B, 408, 24, 14757);
    			attr_dev(div2, "class", "album svelte-mv9rt0");
    			attr_dev(div2, "title", div2_title_value = /*item*/ ctx[49].album.name);
    			add_location(div2, file$B, 414, 24, 15047);
    			attr_dev(div3, "class", "date svelte-mv9rt0");
    			add_location(div3, file$B, 420, 24, 15331);
    			attr_dev(div4, "class", "length svelte-mv9rt0");
    			add_location(div4, file$B, 424, 24, 15528);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link0, div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(link1, div2, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(link2, div3, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, t5);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t0_value !== (t0_value = /*item*/ ctx[49].name + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty[0] & /*visible*/ 256 && div0_title_value !== (div0_title_value = /*item*/ ctx[49].name)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			const link0_changes = {};
    			if (dirty[0] & /*visible*/ 256) link0_changes.to = "artists/" + /*item*/ ctx[49].artist.id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div1_title_value !== (div1_title_value = /*item*/ ctx[49].artist.name)) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			const link1_changes = {};
    			if (dirty[0] & /*visible*/ 256) link1_changes.to = "albums/" + /*item*/ ctx[49].album.id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div2_title_value !== (div2_title_value = /*item*/ ctx[49].album.name)) {
    				attr_dev(div2, "title", div2_title_value);
    			}

    			const link2_changes = {};
    			if (dirty[0] & /*visible*/ 256) link2_changes.to = "albums/year/" + /*item*/ ctx[49].year;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			if ((!current || dirty[0] & /*visible*/ 256) && t5_value !== (t5_value = formatSongLength(/*item*/ ctx[49].time) + "")) set_data_dev(t5, t5_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(link0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			destroy_component(link1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div3);
    			destroy_component(link2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$5.name,
    		type: "if",
    		source: "(404:20) {#if type === \\\"song\\\" || type === \\\"playlist\\\" || type === 'smartlist'}",
    		ctx
    	});

    	return block;
    }

    // (410:28) <Link to="artists/{item.artist.id}">
    function create_default_slot_12(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*item*/ ctx[49].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(410:28) <Link to=\\\"artists/{item.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (416:28) <Link to="albums/{item.album.id}">
    function create_default_slot_11(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*item*/ ctx[49].album.name + "";
    	let t1;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].album.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(416:28) <Link to=\\\"albums/{item.album.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (422:28) <Link to="albums/year/{item.year}">
    function create_default_slot_10(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = (/*item*/ ctx[49].year || "None") + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = (/*item*/ ctx[49].year || "None") + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(422:28) <Link to=\\\"albums/year/{item.year}\\\">",
    		ctx
    	});

    	return block;
    }

    // (428:20) {#if type === "artist"}
    function create_if_block_5$6(ctx) {
    	let div0;
    	let link;
    	let div0_title_value;
    	let t0;
    	let div1;
    	let t1_value = /*item*/ ctx[49].albumcount + "";
    	let t1;
    	let t2;
    	let div2;
    	let t3_value = /*item*/ ctx[49].songcount + "";
    	let t3;
    	let t4;
    	let div3;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*item*/ ctx[49].id,
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*item*/ ctx[49].genre.length > 0 && create_if_block_6$6(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(link.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div3 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "title svelte-mv9rt0");
    			attr_dev(div0, "title", div0_title_value = /*item*/ ctx[49].name);
    			add_location(div0, file$B, 428, 24, 15683);
    			attr_dev(div1, "class", "releases svelte-mv9rt0");
    			add_location(div1, file$B, 434, 24, 15936);
    			attr_dev(div2, "class", "songs svelte-mv9rt0");
    			add_location(div2, file$B, 438, 24, 16065);
    			attr_dev(div3, "class", "genres svelte-mv9rt0");
    			add_location(div3, file$B, 442, 24, 16190);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(link, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div3, anchor);
    			if (if_block) if_block.m(div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*visible*/ 256) link_changes.to = "artists/" + /*item*/ ctx[49].id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div0_title_value !== (div0_title_value = /*item*/ ctx[49].name)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].albumcount + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty[0] & /*visible*/ 256) && t3_value !== (t3_value = /*item*/ ctx[49].songcount + "")) set_data_dev(t3, t3_value);

    			if (/*item*/ ctx[49].genre.length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*visible*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(428:20) {#if type === \\\"artist\\\"}",
    		ctx
    	});

    	return block;
    }

    // (430:28) <Link to="artists/{item.id}">
    function create_default_slot_9(ctx) {
    	let span;
    	let t_value = /*item*/ ctx[49].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "svelte-mv9rt0");
    			add_location(span, file$B, 430, 32, 15815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256 && t_value !== (t_value = /*item*/ ctx[49].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(430:28) <Link to=\\\"artists/{item.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (444:28) {#if item.genre.length > 0}
    function create_if_block_6$6(ctx) {
    	let ul;
    	let current;
    	let each_value_2 = /*item*/ ctx[49].genre;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-mv9rt0");
    			add_location(ul, file$B, 444, 32, 16301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256) {
    				each_value_2 = /*item*/ ctx[49].genre;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$6.name,
    		type: "if",
    		source: "(444:28) {#if item.genre.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (447:44) <Link to="genres/{genre.id}">
    function create_default_slot_8(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[52].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*genre*/ ctx[52].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(447:44) <Link to=\\\"genres/{genre.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (446:36) {#each item.genre as genre}
    function create_each_block_2$3(ctx) {
    	let li;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "genres/" + /*genre*/ ctx[52].id,
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			attr_dev(li, "class", "svelte-mv9rt0");
    			add_location(li, file$B, 446, 40, 16412);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*visible*/ 256) link_changes.to = "genres/" + /*genre*/ ctx[52].id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(446:36) {#each item.genre as genre}",
    		ctx
    	});

    	return block;
    }

    // (454:20) {#if type === "album"}
    function create_if_block_3$a(ctx) {
    	let div0;
    	let link0;
    	let div0_title_value;
    	let t0;
    	let div1;
    	let link1;
    	let div1_title_value;
    	let t1;
    	let div2;
    	let link2;
    	let t2;
    	let div3;
    	let t3_value = /*item*/ ctx[49].songcount + "";
    	let t3;
    	let t4;
    	let div4;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "albums/" + /*item*/ ctx[49].id,
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "artists/" + /*item*/ ctx[49].artist.id,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				to: "albums/year/" + /*item*/ ctx[49].year,
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*item*/ ctx[49].genre.length > 0 && create_if_block_4$8(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(link0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(link1.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(link2.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div4 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "title svelte-mv9rt0");
    			attr_dev(div0, "title", div0_title_value = /*item*/ ctx[49].name);
    			add_location(div0, file$B, 454, 24, 16747);
    			attr_dev(div1, "class", "artist svelte-mv9rt0");
    			attr_dev(div1, "title", div1_title_value = /*item*/ ctx[49].artist.name);
    			add_location(div1, file$B, 460, 24, 16999);
    			attr_dev(div2, "class", "date svelte-mv9rt0");
    			add_location(div2, file$B, 466, 24, 17289);
    			attr_dev(div3, "class", "songs svelte-mv9rt0");
    			add_location(div3, file$B, 470, 24, 17486);
    			attr_dev(div4, "class", "genres svelte-mv9rt0");
    			add_location(div4, file$B, 474, 24, 17611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(link0, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link1, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(link2, div2, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div4, anchor);
    			if (if_block) if_block.m(div4, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};
    			if (dirty[0] & /*visible*/ 256) link0_changes.to = "albums/" + /*item*/ ctx[49].id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div0_title_value !== (div0_title_value = /*item*/ ctx[49].name)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			const link1_changes = {};
    			if (dirty[0] & /*visible*/ 256) link1_changes.to = "artists/" + /*item*/ ctx[49].artist.id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div1_title_value !== (div1_title_value = /*item*/ ctx[49].artist.name)) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			const link2_changes = {};
    			if (dirty[0] & /*visible*/ 256) link2_changes.to = "albums/year/" + /*item*/ ctx[49].year;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			if ((!current || dirty[0] & /*visible*/ 256) && t3_value !== (t3_value = /*item*/ ctx[49].songcount + "")) set_data_dev(t3, t3_value);

    			if (/*item*/ ctx[49].genre.length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*visible*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div4, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(link0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(link1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(link2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div4);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$a.name,
    		type: "if",
    		source: "(454:20) {#if type === \\\"album\\\"}",
    		ctx
    	});

    	return block;
    }

    // (456:28) <Link to="albums/{item.id}">
    function create_default_slot_7(ctx) {
    	let span;
    	let t_value = /*item*/ ctx[49].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "svelte-mv9rt0");
    			add_location(span, file$B, 456, 32, 16878);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256 && t_value !== (t_value = /*item*/ ctx[49].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(456:28) <Link to=\\\"albums/{item.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (462:28) <Link to="artists/{item.artist.id}">
    function create_default_slot_6(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*item*/ ctx[49].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(462:28) <Link to=\\\"artists/{item.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (468:28) <Link to="albums/year/{item.year}">
    function create_default_slot_5$1(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = (/*item*/ ctx[49].year || "None") + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = (/*item*/ ctx[49].year || "None") + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(468:28) <Link to=\\\"albums/year/{item.year}\\\">",
    		ctx
    	});

    	return block;
    }

    // (476:28) {#if item.genre.length > 0}
    function create_if_block_4$8(ctx) {
    	let ul;
    	let current;
    	let each_value_1 = /*item*/ ctx[49].genre;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-mv9rt0");
    			add_location(ul, file$B, 476, 32, 17722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visible*/ 256) {
    				each_value_1 = /*item*/ ctx[49].genre;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$8.name,
    		type: "if",
    		source: "(476:28) {#if item.genre.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (479:44) <Link to="genres/{genre.id}">
    function create_default_slot_4$1(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[52].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*genre*/ ctx[52].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(479:44) <Link to=\\\"genres/{genre.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (478:36) {#each item.genre as genre}
    function create_each_block_1$5(ctx) {
    	let li;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "genres/" + /*genre*/ ctx[52].id,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			attr_dev(li, "class", "svelte-mv9rt0");
    			add_location(li, file$B, 478, 40, 17833);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*visible*/ 256) link_changes.to = "genres/" + /*genre*/ ctx[52].id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(478:36) {#each item.genre as genre}",
    		ctx
    	});

    	return block;
    }

    // (486:20) {#if type === "genre"}
    function create_if_block_2$g(ctx) {
    	let div0;
    	let link0;
    	let div0_title_value;
    	let t0;
    	let div1;
    	let link1;
    	let t1;
    	let div2;
    	let link2;
    	let t2;
    	let div3;
    	let link3;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "genres/" + /*item*/ ctx[49].id,
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "genres/" + /*item*/ ctx[49].id + "/artists",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				to: "genres/" + /*item*/ ctx[49].id + "/albums",
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link3 = new Link({
    			props: {
    				to: "genres/" + /*item*/ ctx[49].id + "/songs",
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(link0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(link1.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(link2.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			create_component(link3.$$.fragment);
    			attr_dev(div0, "class", "title svelte-mv9rt0");
    			attr_dev(div0, "title", div0_title_value = /*item*/ ctx[49].name);
    			add_location(div0, file$B, 486, 24, 18168);
    			attr_dev(div1, "class", "artistsCount svelte-mv9rt0");
    			add_location(div1, file$B, 492, 24, 18435);
    			attr_dev(div2, "class", "albumsCount svelte-mv9rt0");
    			add_location(div2, file$B, 496, 24, 18637);
    			attr_dev(div3, "class", "songsCount svelte-mv9rt0");
    			add_location(div3, file$B, 500, 24, 18835);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(link0, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link1, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(link2, div2, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(link3, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};
    			if (dirty[0] & /*visible*/ 256) link0_changes.to = "genres/" + /*item*/ ctx[49].id;

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);

    			if (!current || dirty[0] & /*visible*/ 256 && div0_title_value !== (div0_title_value = /*item*/ ctx[49].name)) {
    				attr_dev(div0, "title", div0_title_value);
    			}

    			const link1_changes = {};
    			if (dirty[0] & /*visible*/ 256) link1_changes.to = "genres/" + /*item*/ ctx[49].id + "/artists";

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};
    			if (dirty[0] & /*visible*/ 256) link2_changes.to = "genres/" + /*item*/ ctx[49].id + "/albums";

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			const link3_changes = {};
    			if (dirty[0] & /*visible*/ 256) link3_changes.to = "genres/" + /*item*/ ctx[49].id + "/songs";

    			if (dirty[0] & /*visible*/ 256 | dirty[1] & /*$$scope*/ 67108864) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(link3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(link3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(link0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(link1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(link2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div3);
    			destroy_component(link3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$g.name,
    		type: "if",
    		source: "(486:20) {#if type === \\\"genre\\\"}",
    		ctx
    	});

    	return block;
    }

    // (488:28) <Link to="genres/{item.id}">
    function create_default_slot_3$5(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*item*/ ctx[49].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(488:28) <Link to=\\\"genres/{item.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (494:28) <Link to="genres/{item.id}/artists">
    function create_default_slot_2$7(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*item*/ ctx[49].artists + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].artists + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(494:28) <Link to=\\\"genres/{item.id}/artists\\\">",
    		ctx
    	});

    	return block;
    }

    // (498:28) <Link to="genres/{item.id}/albums">
    function create_default_slot_1$a(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*item*/ ctx[49].albums + "";
    	let t1;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].albums + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(498:28) <Link to=\\\"genres/{item.id}/albums\\\">",
    		ctx
    	});

    	return block;
    }

    // (502:28) <Link to="genres/{item.id}/songs">
    function create_default_slot$j(ctx) {
    	let svgsong;
    	let t0;
    	let t1_value = /*item*/ ctx[49].songs + "";
    	let t1;
    	let current;

    	svgsong = new Music_note({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgsong.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgsong, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = /*item*/ ctx[49].songs + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgsong.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgsong.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgsong, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(502:28) <Link to=\\\"genres/{item.id}/songs\\\">",
    		ctx
    	});

    	return block;
    }

    // (506:20) {#if showRating}
    function create_if_block_1$j(ctx) {
    	let div;
    	let rating;
    	let updating_rating;
    	let current;

    	function rating_rating_binding(value) {
    		/*rating_rating_binding*/ ctx[23](value, /*item*/ ctx[49]);
    	}

    	let rating_props = {
    		type: /*type*/ ctx[1],
    		id: /*item*/ ctx[49].id,
    		flag: /*item*/ ctx[49].flag,
    		averageRating: /*item*/ ctx[49].averagerating
    	};

    	if (/*item*/ ctx[49].rating !== void 0) {
    		rating_props.rating = /*item*/ ctx[49].rating;
    	}

    	rating = new Rating({ props: rating_props, $$inline: true });
    	binding_callbacks.push(() => bind(rating, "rating", rating_rating_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(rating.$$.fragment);
    			attr_dev(div, "class", "rating svelte-mv9rt0");
    			add_location(div, file$B, 506, 24, 19094);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(rating, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const rating_changes = {};
    			if (dirty[0] & /*type*/ 2) rating_changes.type = /*type*/ ctx[1];
    			if (dirty[0] & /*visible*/ 256) rating_changes.id = /*item*/ ctx[49].id;
    			if (dirty[0] & /*visible*/ 256) rating_changes.flag = /*item*/ ctx[49].flag;
    			if (dirty[0] & /*visible*/ 256) rating_changes.averageRating = /*item*/ ctx[49].averagerating;

    			if (!updating_rating && dirty[0] & /*visible*/ 256) {
    				updating_rating = true;
    				rating_changes.rating = /*item*/ ctx[49].rating;
    				add_flush_callback(() => updating_rating = false);
    			}

    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(506:20) {#if showRating}",
    		ctx
    	});

    	return block;
    }

    // (512:20) {#if showActions}
    function create_if_block$r(ctx) {
    	let div;
    	let actions;
    	let current;

    	actions = new Actions({
    			props: {
    				type: /*type*/ ctx[1],
    				mode: "miniButtons",
    				id: /*item*/ ctx[49].id,
    				count: "1",
    				artistID: /*item*/ ctx[49].artist
    				? /*item*/ ctx[49].artist.id
    				: null,
    				albumID: /*item*/ ctx[49].album
    				? /*item*/ ctx[49].album.id
    				: null
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(div, "class", "actions svelte-mv9rt0");
    			add_location(div, file$B, 512, 24, 19391);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(actions, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty[0] & /*type*/ 2) actions_changes.type = /*type*/ ctx[1];
    			if (dirty[0] & /*visible*/ 256) actions_changes.id = /*item*/ ctx[49].id;

    			if (dirty[0] & /*visible*/ 256) actions_changes.artistID = /*item*/ ctx[49].artist
    			? /*item*/ ctx[49].artist.id
    			: null;

    			if (dirty[0] & /*visible*/ 256) actions_changes.albumID = /*item*/ ctx[49].album
    			? /*item*/ ctx[49].album.id
    			: null;

    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(512:20) {#if showActions}",
    		ctx
    	});

    	return block;
    }

    // (386:12) {#each visible as item, index (index)}
    function create_each_block$a(key_1, ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let if_block0 = /*type*/ ctx[1] === "playlist" && create_if_block_10$1(ctx);
    	let if_block1 = /*showIndex*/ ctx[0] && create_if_block_9$3(ctx);
    	let if_block2 = /*showArt*/ ctx[5] && create_if_block_8$3(ctx);
    	let if_block3 = (/*type*/ ctx[1] === "song" || /*type*/ ctx[1] === "playlist" || /*type*/ ctx[1] === "smartlist") && create_if_block_7$5(ctx);
    	let if_block4 = /*type*/ ctx[1] === "artist" && create_if_block_5$6(ctx);
    	let if_block5 = /*type*/ ctx[1] === "album" && create_if_block_3$a(ctx);
    	let if_block6 = /*type*/ ctx[1] === "genre" && create_if_block_2$g(ctx);
    	let if_block7 = /*showRating*/ ctx[6] && create_if_block_1$j(ctx);
    	let if_block8 = /*showActions*/ ctx[7] && create_if_block$r(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			t6 = space();
    			if (if_block7) if_block7.c();
    			t7 = space();
    			if (if_block8) if_block8.c();
    			t8 = space();
    			attr_dev(div, "class", "lister-item svelte-mv9rt0");
    			add_location(div, file$B, 386, 16, 13784);
    			this.first = div;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t6);
    			if (if_block7) if_block7.m(div, null);
    			append_dev(div, t7);
    			if (if_block8) if_block8.m(div, null);
    			append_dev(div, t8);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*type*/ ctx[1] === "playlist") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showIndex*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$3(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*showArt*/ ctx[5]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8$3(ctx);
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*type*/ ctx[1] === "song" || /*type*/ ctx[1] === "playlist" || /*type*/ ctx[1] === "smartlist") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 2) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_7$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "artist") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_5$6(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 2) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_3$a(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "genre") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 2) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_2$g(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div, t6);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*showRating*/ ctx[6]) {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);

    					if (dirty[0] & /*showRating*/ 64) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_1$j(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(div, t7);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (/*showActions*/ ctx[7]) {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);

    					if (dirty[0] & /*showActions*/ 128) {
    						transition_in(if_block8, 1);
    					}
    				} else {
    					if_block8 = create_if_block$r(ctx);
    					if_block8.c();
    					transition_in(if_block8, 1);
    					if_block8.m(div, t8);
    				}
    			} else if (if_block8) {
    				group_outros();

    				transition_out(if_block8, 1, 1, () => {
    					if_block8 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(386:12) {#each visible as item, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div5;
    	let div0;
    	let button;
    	let svgcenter;
    	let t0;
    	let div4;
    	let div3;
    	let div2;
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;

    	svgcenter = new Center_focus({
    			props: { style: "padding: 0.05em;" },
    			$$inline: true
    		});

    	let if_block0 = /*type*/ ctx[1] === "playlist" && create_if_block_19(ctx);
    	let if_block1 = /*showIndex*/ ctx[0] && create_if_block_18$1(ctx);
    	let if_block2 = /*showArt*/ ctx[5] && create_if_block_17$1(ctx);
    	let if_block3 = (/*type*/ ctx[1] === "song" || /*type*/ ctx[1] === "playlist" || /*type*/ ctx[1] === "smartlist") && create_if_block_16$1(ctx);
    	let if_block4 = /*type*/ ctx[1] === "artist" && create_if_block_15$1(ctx);
    	let if_block5 = /*type*/ ctx[1] === "album" && create_if_block_14$1(ctx);
    	let if_block6 = /*type*/ ctx[1] === "genre" && create_if_block_13$1(ctx);
    	let if_block7 = /*showRating*/ ctx[6] && create_if_block_12$1(ctx);
    	let if_block8 = /*showActions*/ ctx[7] && create_if_block_11$1(ctx);
    	let each_value = /*visible*/ ctx[8];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[51];
    	validate_each_keys(ctx, each_value, get_each_context$a, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$a(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			button = element("button");
    			create_component(svgcenter.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Name";
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			if (if_block4) if_block4.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			t9 = space();
    			if (if_block7) if_block7.c();
    			t10 = space();
    			if (if_block8) if_block8.c();
    			t11 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "center-lister just-icon");
    			attr_dev(button, "title", "Center");
    			add_location(button, file$B, 326, 8, 11027);
    			attr_dev(div0, "class", "lister-actions svelte-mv9rt0");
    			add_location(div0, file$B, 325, 4, 10989);
    			attr_dev(div1, "class", "title svelte-mv9rt0");
    			attr_dev(div1, "data-sort", "title");
    			add_location(div1, file$B, 348, 16, 11801);
    			attr_dev(div2, "class", "lister-header svelte-mv9rt0");
    			add_location(div2, file$B, 335, 12, 11369);
    			attr_dev(div3, "class", "c-lister svelte-mv9rt0");
    			add_location(div3, file$B, 334, 8, 11314);
    			attr_dev(div4, "class", "c-lister-container svelte-mv9rt0");
    			add_location(div4, file$B, 329, 4, 11187);
    			attr_dev(div5, "class", "c-lister-wrapper svelte-mv9rt0");
    			add_location(div5, file$B, 324, 0, 10953);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div0, button);
    			mount_component(svgcenter, button, null);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div2, t5);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div2, t6);
    			if (if_block4) if_block4.m(div2, null);
    			append_dev(div2, t7);
    			if (if_block5) if_block5.m(div2, null);
    			append_dev(div2, t8);
    			if (if_block6) if_block6.m(div2, null);
    			append_dev(div2, t9);
    			if (if_block7) if_block7.m(div2, null);
    			append_dev(div2, t10);
    			if (if_block8) if_block8.m(div2, null);
    			/*div2_binding*/ ctx[21](div2);
    			append_dev(div3, t11);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			/*div3_binding*/ ctx[24](div3);
    			/*div4_binding*/ ctx[25](div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*centerLister*/ ctx[11], false, false, false),
    					listen_dev(div1, "click", /*handleSort*/ ctx[9], false, false, false),
    					listen_dev(div4, "scroll", /*limitScroll*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*type*/ ctx[1] === "playlist") {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_19(ctx);
    					if_block0.c();
    					if_block0.m(div2, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*showIndex*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_18$1(ctx);
    					if_block1.c();
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*showArt*/ ctx[5]) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_17$1(ctx);
    					if_block2.c();
    					if_block2.m(div2, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*type*/ ctx[1] === "song" || /*type*/ ctx[1] === "playlist" || /*type*/ ctx[1] === "smartlist") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_16$1(ctx);
    					if_block3.c();
    					if_block3.m(div2, t6);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*type*/ ctx[1] === "artist") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_15$1(ctx);
    					if_block4.c();
    					if_block4.m(div2, t7);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_14$1(ctx);
    					if_block5.c();
    					if_block5.m(div2, t8);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*type*/ ctx[1] === "genre") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);
    				} else {
    					if_block6 = create_if_block_13$1(ctx);
    					if_block6.c();
    					if_block6.m(div2, t9);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*showRating*/ ctx[6]) {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);
    				} else {
    					if_block7 = create_if_block_12$1(ctx);
    					if_block7.c();
    					if_block7.m(div2, t10);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (/*showActions*/ ctx[7]) {
    				if (if_block8) ; else {
    					if_block8 = create_if_block_11$1(ctx);
    					if_block8.c();
    					if_block8.m(div2, null);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (dirty[0] & /*type, visible, showActions, showRating, showArt, showIndex, handleRemove*/ 1507) {
    				each_value = /*visible*/ ctx[8];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$a, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgcenter.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgcenter.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(svgcenter);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			/*div2_binding*/ ctx[21](null);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div3_binding*/ ctx[24](null);
    			/*div4_binding*/ ctx[25](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function setOrders(arr) {
    	for (let i = 0; i < arr.length; i++) {
    		arr[i].initialOrder = i;
    	}

    	return arr;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Lister", slots, []);
    	let { data } = $$props;
    	let { type } = $$props;
    	let { id = null } = $$props;
    	let { showIndex = false } = $$props;
    	let { activeSort = null } = $$props;
    	let { sortReverse = null } = $$props;
    	let moreMenuID;
    	let moreMenuIsOpen = false;
    	let dataDisplay;
    	let allHeaders;
    	let dataCopy = [];

    	// lister element binds
    	let lister;

    	let listerContainer;
    	let listerHeader;

    	// conditional columns
    	let showArt = true;

    	let showRating = true;
    	let showActions = true;

    	// virtual stuff
    	let start = 0;

    	let end = 0;
    	let visible = [];
    	let top = 0;
    	let itemHeight = 47;
    	let columnWidths = [];
    	let myObserver;
    	let nodePadding = 5;
    	let viewportHeight;
    	let totalContentHeight;
    	let startNode;
    	let visibleNodesCount;
    	let offsetY;
    	let currentAF;
    	let scrollTimer;
    	let lastKnownScroll = 0;
    	let ticking = false;

    	function handleActionMenu(index) {
    		moreMenuID = index;
    		moreMenuIsOpen = !moreMenuIsOpen;
    	}

    	function applySort(type) {
    		switch (type) {
    			case "index":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.initialOrder > obj2.initialOrder;
    				}));
    				break;
    			case "date":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.year > obj2.year;
    				}));
    				break;
    			case "releases":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.albumcount > obj2.albumcount;
    				}));
    				break;
    			case "songs":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.songcount > obj2.songcount;
    				}));
    				break;
    			case "genreArtists":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.artists > obj2.artists;
    				}));
    				break;
    			case "genreAlbums":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.albums > obj2.albums;
    				}));
    				break;
    			case "genreSongs":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.songs > obj2.songs;
    				}));
    				break;
    			case "time":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.time.toString().localeCompare(obj2.time.toString(), undefined, { numeric: true });
    				}));
    				break;
    			case "rating":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.rating > obj2.rating;
    				}));
    				break;
    			case "title":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.name.localeCompare(obj2.name);
    				}));
    				break;
    			case "artist":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.artist.name.localeCompare(obj2.artist.name);
    				}));
    				break;
    			case "album":
    				$$invalidate(18, dataCopy = dataCopy.sort(function (obj1, obj2) {
    					return obj1.album.name.localeCompare(obj2.album.name);
    				}));
    				break;
    		}
    	}

    	async function handleSort(e) {
    		let sortType = e.target.dataset.sort;
    		$$invalidate(15, activeSort = sortType);

    		$$invalidate(14, sortReverse = e.target.dataset.reverse
    		? JSON.parse(e.target.dataset.reverse)
    		: null);

    		applySort(sortType);

    		// reset other items
    		for (const header of allHeaders) {
    			header.removeAttribute("data-reverse");
    		}

    		if (sortReverse === null) {
    			// hasn't been clicked yet, apply no reversal
    			$$invalidate(14, sortReverse = false);
    		} else {
    			// invert the reversal
    			$$invalidate(14, sortReverse = !sortReverse);
    		}

    		await tick();
    		e.target.setAttribute("data-reverse", sortReverse);
    	}

    	// currently just playlist specific
    	async function handleRemove(event, item) {
    		Promise.resolve([]);

    		// before we attempt to remove, double check things are ok.
    		event.target.classList.add("loading");

    		listerContainer.classList.add("refreshing");

    		// query song at requested index to see if it matches
    		let testSong = await getSongFromPlaylist({
    			playlistID: id,
    			songIndex: item.initialOrder
    		});

    		// if testSong equals correct song, request to remove via API
    		if (testSong[0].id === item.id) {
    			await removeFromPlaylist({
    				playlistID: id,
    				trackNo: item.initialOrder + 1
    			});
    		}

    		// reload playlist songs regardless of match or success
    		let newData = await getSongsFromPlaylist(id);

    		newData = setOrders(newData);
    		event.target.classList.remove("loading");
    		listerContainer.classList.remove("refreshing");
    		$$invalidate(13, data = newData);
    		await updateData();
    		updateTotalHeight();
    		applySort(activeSort);
    	}

    	async function updateData() {
    		$$invalidate(13, data);
    		$$invalidate(18, dataCopy = data.slice());
    		await tick();
    	}

    	function centerLister() {
    		listerContainer.scrollIntoView({
    			behavior: "smooth",
    			block: "center",
    			inline: "center"
    		});
    	}

    	function limitScroll() {
    		lastKnownScroll = listerContainer.scrollTop;
    		requestTick();
    	}

    	function requestTick() {
    		if (!ticking) {
    			requestAnimationFrame(update);
    		}

    		ticking = true;
    	}

    	beforeUpdate(() => {
    		// determine columns
    		switch (type) {
    			case "genre":
    				$$invalidate(5, showArt = false);
    				$$invalidate(6, showRating = false);
    				$$invalidate(7, showActions = false);
    				break;
    			case "playlist":
    				$$invalidate(0, showIndex = true);
    				break;
    		}
    	});

    	async function update() {
    		ticking = false;
    		clearTimeout(scrollTimer);

    		// ensure listerContainer is present before continuing
    		while (!listerContainer) {
    			await new Promise(r => setTimeout(r, 100));
    		}

    		listerContainer.classList.add("disable-hover");

    		scrollTimer = setTimeout(
    			function () {
    				if (listerContainer) {
    					listerContainer.classList.remove("disable-hover");
    				}
    			},
    			200
    		);

    		$$invalidate(19, startNode = Math.floor(lastKnownScroll / itemHeight) - nodePadding);
    		$$invalidate(19, startNode = Math.max(0, startNode));
    		$$invalidate(20, visibleNodesCount = Math.ceil(viewportHeight / itemHeight) + 2 * nodePadding);
    		$$invalidate(20, visibleNodesCount = Math.min(dataDisplay.length - startNode, visibleNodesCount));

    		// account for sticky header taking up a slot at the start
    		if (startNode === 0 && dataDisplay.length > visibleNodesCount) {
    			$$invalidate(20, visibleNodesCount = visibleNodesCount - 1);
    		}

    		offsetY = startNode * itemHeight;
    		listerContainer.style.setProperty("--c-lister-offset", offsetY + "px");
    	} // DEBUG ZONE
    	// console.debug('==========================');

    	function updateTotalHeight() {
    		listerContainer.style.setProperty("--c-lister-total-height", totalContentHeight + "px");
    	}

    	onMount(async () => {
    		await updateData();

    		// save initial orders
    		setOrders(data);

    		// ensure listerContainer is present before continuing
    		while (!listerContainer) {
    			await new Promise(r => setTimeout(r, 100));
    		}

    		viewportHeight = parseInt(window.getComputedStyle(listerContainer).maxHeight, 10);
    		viewportHeight = Math.min(itemHeight * dataDisplay.length, viewportHeight);

    		// set column count based on how many header items exist
    		allHeaders = lister.querySelectorAll(".lister-header div");

    		listerContainer.style.setProperty("--c-lister-column-count", allHeaders.length);
    		listerContainer.style.setProperty("--c-lister-item-height", itemHeight + "px");
    		listerContainer.style.setProperty("--c-lister-offset", 0 + "px");
    		updateTotalHeight();
    		applySort(activeSort);
    		update();
    		let observed = false;

    		// use ResizeObserver on Lister to grab column widths after it is rendered
    		myObserver = new ResizeObserver(entries => {
    				entries.forEach(entry => {
    					columnWidths = window.getComputedStyle(entry.target).gridTemplateColumns;
    				});

    				if (!observed) {
    					observed = true;
    					listerContainer.style.setProperty("--c-lister-column-widths", columnWidths);

    					// move header to be child of lister container once sizes are set so sticky works again
    					listerHeader.classList.add("moved");

    					listerContainer.prepend(listerHeader);
    				}
    			});

    		myObserver.observe(lister);
    	});

    	onDestroy(() => {
    		if (myObserver) {
    			myObserver.disconnect();
    		}
    	});

    	const writable_props = ["data", "type", "id", "showIndex", "activeSort", "sortReverse"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Lister> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			listerHeader = $$value;
    			$$invalidate(4, listerHeader);
    		});
    	}

    	const click_handler = (item, e) => {
    		handleRemove(e, item);
    	};

    	function rating_rating_binding(value, item) {
    		if ($$self.$$.not_equal(item.rating, value)) {
    			item.rating = value;
    			((((($$invalidate(8, visible), $$invalidate(17, dataDisplay)), $$invalidate(19, startNode)), $$invalidate(20, visibleNodesCount)), $$invalidate(14, sortReverse)), $$invalidate(18, dataCopy));
    		}
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			lister = $$value;
    			$$invalidate(2, lister);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			listerContainer = $$value;
    			$$invalidate(3, listerContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("id" in $$props) $$invalidate(16, id = $$props.id);
    		if ("showIndex" in $$props) $$invalidate(0, showIndex = $$props.showIndex);
    		if ("activeSort" in $$props) $$invalidate(15, activeSort = $$props.activeSort);
    		if ("sortReverse" in $$props) $$invalidate(14, sortReverse = $$props.sortReverse);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		beforeUpdate,
    		onDestroy,
    		Link,
    		formatSongLength,
    		removeFromPlaylist,
    		getSongsFromPlaylist,
    		getSongFromPlaylist,
    		Rating,
    		Actions,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGSong: Music_note,
    		SVGYear: Year,
    		SVGGenre: Label,
    		SVGCenter: Center_focus,
    		SVGClose: Close,
    		data,
    		type,
    		id,
    		showIndex,
    		activeSort,
    		sortReverse,
    		moreMenuID,
    		moreMenuIsOpen,
    		dataDisplay,
    		allHeaders,
    		dataCopy,
    		lister,
    		listerContainer,
    		listerHeader,
    		showArt,
    		showRating,
    		showActions,
    		start,
    		end,
    		visible,
    		top,
    		itemHeight,
    		columnWidths,
    		myObserver,
    		nodePadding,
    		viewportHeight,
    		totalContentHeight,
    		startNode,
    		visibleNodesCount,
    		offsetY,
    		currentAF,
    		scrollTimer,
    		lastKnownScroll,
    		ticking,
    		handleActionMenu,
    		applySort,
    		handleSort,
    		handleRemove,
    		updateData,
    		centerLister,
    		limitScroll,
    		requestTick,
    		update,
    		setOrders,
    		updateTotalHeight
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("id" in $$props) $$invalidate(16, id = $$props.id);
    		if ("showIndex" in $$props) $$invalidate(0, showIndex = $$props.showIndex);
    		if ("activeSort" in $$props) $$invalidate(15, activeSort = $$props.activeSort);
    		if ("sortReverse" in $$props) $$invalidate(14, sortReverse = $$props.sortReverse);
    		if ("moreMenuID" in $$props) moreMenuID = $$props.moreMenuID;
    		if ("moreMenuIsOpen" in $$props) moreMenuIsOpen = $$props.moreMenuIsOpen;
    		if ("dataDisplay" in $$props) $$invalidate(17, dataDisplay = $$props.dataDisplay);
    		if ("allHeaders" in $$props) allHeaders = $$props.allHeaders;
    		if ("dataCopy" in $$props) $$invalidate(18, dataCopy = $$props.dataCopy);
    		if ("lister" in $$props) $$invalidate(2, lister = $$props.lister);
    		if ("listerContainer" in $$props) $$invalidate(3, listerContainer = $$props.listerContainer);
    		if ("listerHeader" in $$props) $$invalidate(4, listerHeader = $$props.listerHeader);
    		if ("showArt" in $$props) $$invalidate(5, showArt = $$props.showArt);
    		if ("showRating" in $$props) $$invalidate(6, showRating = $$props.showRating);
    		if ("showActions" in $$props) $$invalidate(7, showActions = $$props.showActions);
    		if ("start" in $$props) start = $$props.start;
    		if ("end" in $$props) end = $$props.end;
    		if ("visible" in $$props) $$invalidate(8, visible = $$props.visible);
    		if ("top" in $$props) top = $$props.top;
    		if ("itemHeight" in $$props) $$invalidate(40, itemHeight = $$props.itemHeight);
    		if ("columnWidths" in $$props) columnWidths = $$props.columnWidths;
    		if ("myObserver" in $$props) myObserver = $$props.myObserver;
    		if ("nodePadding" in $$props) nodePadding = $$props.nodePadding;
    		if ("viewportHeight" in $$props) viewportHeight = $$props.viewportHeight;
    		if ("totalContentHeight" in $$props) totalContentHeight = $$props.totalContentHeight;
    		if ("startNode" in $$props) $$invalidate(19, startNode = $$props.startNode);
    		if ("visibleNodesCount" in $$props) $$invalidate(20, visibleNodesCount = $$props.visibleNodesCount);
    		if ("offsetY" in $$props) offsetY = $$props.offsetY;
    		if ("currentAF" in $$props) currentAF = $$props.currentAF;
    		if ("scrollTimer" in $$props) scrollTimer = $$props.scrollTimer;
    		if ("lastKnownScroll" in $$props) lastKnownScroll = $$props.lastKnownScroll;
    		if ("ticking" in $$props) ticking = $$props.ticking;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data*/ 8192) {
    			$$invalidate(13, data); //immutable
    		}

    		if ($$self.$$.dirty[0] & /*sortReverse, dataCopy*/ 278528) {
    			$$invalidate(17, dataDisplay = sortReverse ? dataCopy.slice().reverse() : dataCopy);
    		}

    		if ($$self.$$.dirty[0] & /*dataDisplay, startNode, visibleNodesCount*/ 1703936) {
    			$$invalidate(8, visible = dataDisplay.slice(startNode, startNode + visibleNodesCount).map((data, i) => {
    				return data;
    			}));
    		}

    		if ($$self.$$.dirty[0] & /*dataDisplay*/ 131072) {
    			totalContentHeight = dataDisplay.length * itemHeight;
    		}
    	};

    	return [
    		showIndex,
    		type,
    		lister,
    		listerContainer,
    		listerHeader,
    		showArt,
    		showRating,
    		showActions,
    		visible,
    		handleSort,
    		handleRemove,
    		centerLister,
    		limitScroll,
    		data,
    		sortReverse,
    		activeSort,
    		id,
    		dataDisplay,
    		dataCopy,
    		startNode,
    		visibleNodesCount,
    		div2_binding,
    		click_handler,
    		rating_rating_binding,
    		div3_binding,
    		div4_binding
    	];
    }

    class Lister extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$I,
    			create_fragment$I,
    			safe_not_equal,
    			{
    				data: 13,
    				type: 1,
    				id: 16,
    				showIndex: 0,
    				activeSort: 15,
    				sortReverse: 14
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lister",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[13] === undefined && !("data" in props)) {
    			console.warn("<Lister> was created without expected prop 'data'");
    		}

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<Lister> was created without expected prop 'type'");
    		}
    	}

    	get data() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showIndex() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showIndex(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeSort() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeSort(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortReverse() {
    		throw new Error("<Lister>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortReverse(value) {
    		throw new Error("<Lister>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\artistsAll.svelte generated by Svelte v3.38.3 */
    const file$A = "src\\views\\artistsAll.svelte";

    // (42:0) {#if $allArtists.loaded}
    function create_if_block$q(ctx) {
    	let previous_key = /*selectedChar*/ ctx[0] + /*$ShowAlbumArtistsOnly*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$4(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedChar, $ShowAlbumArtistsOnly*/ 5 && safe_not_equal(previous_key, previous_key = /*selectedChar*/ ctx[0] + /*$ShowAlbumArtistsOnly*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$4(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(42:0) {#if $allArtists.loaded}",
    		ctx
    	});

    	return block;
    }

    // (43:4) {#key selectedChar + $ShowAlbumArtistsOnly}
    function create_key_block$4(ctx) {
    	let actions;
    	let t;
    	let lister;
    	let updating_data;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "artistAlpha",
    				mode: "fullButtons",
    				data: { char: /*selectedChar*/ ctx[0] }
    			},
    			$$inline: true
    		});

    	function lister_data_binding(value) {
    		/*lister_data_binding*/ ctx[8](value);
    	}

    	let lister_props = { type: "artist" };

    	if (/*dataDisplay*/ ctx[3] !== void 0) {
    		lister_props.data = /*dataDisplay*/ ctx[3];
    	}

    	lister = new Lister({ props: lister_props, $$inline: true });
    	binding_callbacks.push(() => bind(lister, "data", lister_data_binding));

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*selectedChar*/ 1) actions_changes.data = { char: /*selectedChar*/ ctx[0] };
    			actions.$set(actions_changes);
    			const lister_changes = {};

    			if (!updating_data && dirty & /*dataDisplay*/ 8) {
    				updating_data = true;
    				lister_changes.data = /*dataDisplay*/ ctx[3];
    				add_flush_callback(() => updating_data = false);
    			}

    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$4.name,
    		type: "key",
    		source: "(43:4) {#key selectedChar + $ShowAlbumArtistsOnly}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let h1;
    	let t1;
    	let label;
    	let input;
    	let t2;
    	let t3;
    	let alphanumericpagination;
    	let updating_selectedChar;
    	let t4;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	function alphanumericpagination_selectedChar_binding(value) {
    		/*alphanumericpagination_selectedChar_binding*/ ctx[7](value);
    	}

    	let alphanumericpagination_props = { type: "artists" };

    	if (/*selectedChar*/ ctx[0] !== void 0) {
    		alphanumericpagination_props.selectedChar = /*selectedChar*/ ctx[0];
    	}

    	alphanumericpagination = new AlphanumericPagination({
    			props: alphanumericpagination_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(alphanumericpagination, "selectedChar", alphanumericpagination_selectedChar_binding));
    	let if_block = /*$allArtists*/ ctx[1].loaded && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "All artists";
    			t1 = space();
    			label = element("label");
    			input = element("input");
    			t2 = text("\r\n    Show album artists only");
    			t3 = space();
    			create_component(alphanumericpagination.$$.fragment);
    			t4 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$A, 32, 0, 1065);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$A, 35, 4, 1102);
    			attr_dev(label, "class", "svelte-1rumxdb");
    			add_location(label, file$A, 34, 0, 1089);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			input.checked = /*$ShowAlbumArtistsOnly*/ ctx[2];
    			append_dev(label, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(alphanumericpagination, target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$ShowAlbumArtistsOnly*/ 4) {
    				input.checked = /*$ShowAlbumArtistsOnly*/ ctx[2];
    			}

    			const alphanumericpagination_changes = {};

    			if (!updating_selectedChar && dirty & /*selectedChar*/ 1) {
    				updating_selectedChar = true;
    				alphanumericpagination_changes.selectedChar = /*selectedChar*/ ctx[0];
    				add_flush_callback(() => updating_selectedChar = false);
    			}

    			alphanumericpagination.$set(alphanumericpagination_changes);

    			if (/*$allArtists*/ ctx[1].loaded) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$allArtists*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alphanumericpagination.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alphanumericpagination.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t3);
    			destroy_component(alphanumericpagination, detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $allArtists;
    	let $ShowAlbumArtistsOnly;
    	validate_store(allArtists, "allArtists");
    	component_subscribe($$self, allArtists, $$value => $$invalidate(1, $allArtists = $$value));
    	validate_store(ShowAlbumArtistsOnly, "ShowAlbumArtistsOnly");
    	component_subscribe($$self, ShowAlbumArtistsOnly, $$value => $$invalidate(2, $ShowAlbumArtistsOnly = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArtistsAll", slots, []);
    	let selectedChar = ""; // bound from alphanumericPagination
    	let filterChars = "";
    	let filteredData = [];
    	let dataDisplay = [];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArtistsAll> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		$ShowAlbumArtistsOnly = this.checked;
    		ShowAlbumArtistsOnly.set($ShowAlbumArtistsOnly);
    	}

    	function alphanumericpagination_selectedChar_binding(value) {
    		selectedChar = value;
    		$$invalidate(0, selectedChar);
    	}

    	function lister_data_binding(value) {
    		dataDisplay = value;
    		((((($$invalidate(3, dataDisplay), $$invalidate(1, $allArtists)), $$invalidate(2, $ShowAlbumArtistsOnly)), $$invalidate(0, selectedChar)), $$invalidate(5, filteredData)), $$invalidate(4, filterChars));
    	}

    	$$self.$capture_state = () => ({
    		allArtists,
    		ShowAlbumArtistsOnly,
    		AlphanumericPagination,
    		Actions,
    		Lister,
    		selectedChar,
    		filterChars,
    		filteredData,
    		dataDisplay,
    		$allArtists,
    		$ShowAlbumArtistsOnly
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedChar" in $$props) $$invalidate(0, selectedChar = $$props.selectedChar);
    		if ("filterChars" in $$props) $$invalidate(4, filterChars = $$props.filterChars);
    		if ("filteredData" in $$props) $$invalidate(5, filteredData = $$props.filteredData);
    		if ("dataDisplay" in $$props) $$invalidate(3, dataDisplay = $$props.dataDisplay);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$allArtists, $ShowAlbumArtistsOnly, selectedChar, filteredData, filterChars*/ 55) {
    			{
    				if ($allArtists.loaded) {
    					$$invalidate(5, filteredData = $ShowAlbumArtistsOnly
    					? $allArtists.data.filter(a => a.albumcount > 0)
    					: $allArtists.data);

    					$$invalidate(4, filterChars = selectedChar.replaceAll("#", "(\\d|\\W)"));

    					if (selectedChar) {
    						$$invalidate(3, dataDisplay = filteredData.filter(function (a) {
    							let regex = new RegExp("^" + filterChars, "i");
    							return regex.test(a.name);
    						}));
    					} else {
    						$$invalidate(3, dataDisplay = filteredData);
    					}
    				}
    			}
    		}
    	};

    	return [
    		selectedChar,
    		$allArtists,
    		$ShowAlbumArtistsOnly,
    		dataDisplay,
    		filterChars,
    		filteredData,
    		input_change_handler,
    		alphanumericpagination_selectedChar_binding,
    		lister_data_binding
    	];
    }

    class ArtistsAll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtistsAll",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\components\artistCard.svelte generated by Svelte v3.38.3 */
    const file$z = "src\\components\\artistCard.svelte";

    // (20:4) {:else}
    function create_else_block$l(ctx) {
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let t2;
    	let div1;
    	let rating;
    	let current;
    	rating = new Rating({ $$inline: true });

    	const block = {
    		c: function create() {
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Loading";
    			t2 = space();
    			div1 = element("div");
    			create_component(rating.$$.fragment);
    			attr_dev(img, "class", "image svelte-inu0lc");
    			attr_dev(img, "height", "400");
    			attr_dev(img, "width", "400");
    			if (img.src !== (img_src_value = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$z, 20, 8, 695);
    			attr_dev(div0, "class", "title svelte-inu0lc");
    			add_location(div0, file$z, 21, 8, 841);
    			attr_dev(div1, "class", "rating-container svelte-inu0lc");
    			add_location(div1, file$z, 23, 8, 885);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(rating, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#if artist}
    function create_if_block$p(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t0;
    	let div0;
    	let link;
    	let t1;
    	let div1;
    	let rating;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*artist*/ ctx[0].id,
    				title: /*artist*/ ctx[0].name,
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	rating = new Rating({
    			props: {
    				type: "artist",
    				id: /*artist*/ ctx[0].id,
    				rating: /*artist*/ ctx[0].rating,
    				flag: /*artist*/ ctx[0].flag,
    				averageRating: /*artist*/ ctx[0].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			create_component(link.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(rating.$$.fragment);
    			attr_dev(img, "class", "image svelte-inu0lc");
    			attr_dev(img, "height", "400");
    			attr_dev(img, "width", "400");
    			if (img.src !== (img_src_value = "" + (/*artist*/ ctx[0].art + "&thumb=22"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*artist*/ ctx[0].name);
    			attr_dev(img, "loading", "lazy");
    			add_location(img, file$z, 13, 8, 250);
    			attr_dev(div0, "class", "title svelte-inu0lc");
    			add_location(div0, file$z, 14, 8, 376);
    			attr_dev(div1, "class", "rating-container svelte-inu0lc");
    			add_location(div1, file$z, 16, 8, 486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(link, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(rating, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*artist*/ 1 && img.src !== (img_src_value = "" + (/*artist*/ ctx[0].art + "&thumb=22"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*artist*/ 1 && img_alt_value !== (img_alt_value = "Image of " + /*artist*/ ctx[0].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			const link_changes = {};
    			if (dirty & /*artist*/ 1) link_changes.to = "artists/" + /*artist*/ ctx[0].id;
    			if (dirty & /*artist*/ 1) link_changes.title = /*artist*/ ctx[0].name;

    			if (dirty & /*$$scope, artist*/ 5) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    			const rating_changes = {};
    			if (dirty & /*artist*/ 1) rating_changes.id = /*artist*/ ctx[0].id;
    			if (dirty & /*artist*/ 1) rating_changes.rating = /*artist*/ ctx[0].rating;
    			if (dirty & /*artist*/ 1) rating_changes.flag = /*artist*/ ctx[0].flag;
    			if (dirty & /*artist*/ 1) rating_changes.averageRating = /*artist*/ ctx[0].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(link);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(13:4) {#if artist}",
    		ctx
    	});

    	return block;
    }

    // (15:27) <Link to="artists/{artist.id}" title="{artist.name}">
    function create_default_slot$i(ctx) {
    	let t_value = /*artist*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*artist*/ 1 && t_value !== (t_value = /*artist*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(15:27) <Link to=\\\"artists/{artist.id}\\\" title=\\\"{artist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block$l];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*artist*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "artist-card svelte-inu0lc");
    			add_location(div, file$z, 11, 0, 197);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArtistCard", slots, []);
    	let { data = null } = $$props;
    	let artist;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArtistCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ Link, Rating, data, artist });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("artist" in $$props) $$invalidate(0, artist = $$props.artist);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, artist = data);
    		}
    	};

    	return [artist, data];
    }

    class ArtistCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtistCard",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get data() {
    		throw new Error("<ArtistCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ArtistCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var artistCard = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': ArtistCard
    });

    /* src\components\albumCard.svelte generated by Svelte v3.38.3 */
    const file$y = "src\\components\\albumCard.svelte";

    // (48:4) {:else}
    function create_else_block$k(ctx) {
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div4;
    	let div1;
    	let t2;
    	let div2;
    	let br0;
    	let t3;
    	let div3;
    	let br1;
    	let t4;
    	let div5;
    	let rating;
    	let current;
    	rating = new Rating({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div4 = element("div");
    			div1 = element("div");
    			div1.textContent = "Loading";
    			t2 = space();
    			div2 = element("div");
    			br0 = element("br");
    			t3 = space();
    			div3 = element("div");
    			br1 = element("br");
    			t4 = space();
    			div5 = element("div");
    			create_component(rating.$$.fragment);
    			attr_dev(img, "width", "160");
    			attr_dev(img, "height", "160");
    			attr_dev(img, "class", "image svelte-kodszt");
    			if (img.src !== (img_src_value = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$y, 49, 12, 1929);
    			attr_dev(div0, "class", "image-container svelte-kodszt");
    			add_location(div0, file$y, 48, 8, 1886);
    			attr_dev(div1, "class", "title svelte-kodszt");
    			add_location(div1, file$y, 53, 12, 2128);
    			add_location(br0, file$y, 54, 32, 2194);
    			attr_dev(div2, "class", "artist svelte-kodszt");
    			add_location(div2, file$y, 54, 12, 2174);
    			add_location(br1, file$y, 55, 30, 2236);
    			attr_dev(div3, "class", "year");
    			add_location(div3, file$y, 55, 12, 2218);
    			attr_dev(div4, "class", "details svelte-kodszt");
    			add_location(div4, file$y, 52, 8, 2093);
    			attr_dev(div5, "class", "rating-container svelte-kodszt");
    			add_location(div5, file$y, 58, 8, 2274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, img);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div2, br0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, br1);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(rating, div5, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div5);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(48:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if album}
    function create_if_block$o(ctx) {
    	let div1;
    	let img0;
    	let img0_src_value;
    	let img0_alt_value;
    	let t0;
    	let img1;
    	let img1_src_value;
    	let t1;
    	let div0;
    	let actions;
    	let t2;
    	let div5;
    	let div2;
    	let link0;
    	let t3;
    	let div3;
    	let link1;
    	let t4;
    	let div4;
    	let t5;
    	let t6_value = /*album*/ ctx[0].songcount + "";
    	let t6;
    	let t7;

    	let t8_value = (parseInt(/*album*/ ctx[0].songcount) === 1
    	? "song"
    	: "songs") + "";

    	let t8;
    	let t9;
    	let div6;
    	let rating;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "album",
    				mode: "miniButtons",
    				id: /*album*/ ctx[0].id,
    				count: /*album*/ ctx[0].songcount,
    				albumID: /*album*/ ctx[0].id,
    				artistID: /*album*/ ctx[0].artist.id
    			},
    			$$inline: true
    		});

    	link0 = new Link({
    			props: {
    				to: "albums/" + /*album*/ ctx[0].id,
    				title: /*album*/ ctx[0].name,
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "artists/" + /*album*/ ctx[0].artist.id,
    				title: /*album*/ ctx[0].artist.name,
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*album*/ ctx[0].year > 0 && create_if_block_1$i(ctx);

    	rating = new Rating({
    			props: {
    				type: "album",
    				id: /*album*/ ctx[0].id,
    				rating: /*album*/ ctx[0].rating,
    				flag: /*album*/ ctx[0].flag,
    				averageRating: /*album*/ ctx[0].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img0 = element("img");
    			t0 = space();
    			img1 = element("img");
    			t1 = space();
    			div0 = element("div");
    			create_component(actions.$$.fragment);
    			t2 = space();
    			div5 = element("div");
    			div2 = element("div");
    			create_component(link0.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(link1.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			if (if_block) if_block.c();
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			div6 = element("div");
    			create_component(rating.$$.fragment);
    			attr_dev(img0, "width", "160");
    			attr_dev(img0, "height", "160");
    			attr_dev(img0, "class", "image svelte-kodszt");
    			if (img0.src !== (img0_src_value = "" + (/*album*/ ctx[0].art + "&thumb=22"))) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", img0_alt_value = "Image of " + /*album*/ ctx[0].name);
    			add_location(img0, file$y, 18, 12, 466);
    			attr_dev(img1, "width", "160");
    			attr_dev(img1, "height", "160");
    			attr_dev(img1, "class", "image-thumb svelte-kodszt");
    			if (img1.src !== (img1_src_value = "" + (/*album*/ ctx[0].art + "&thumb=1"))) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "loading", "lazy");
    			add_location(img1, file$y, 19, 12, 579);
    			attr_dev(div0, "class", "actions svelte-kodszt");
    			add_location(div0, file$y, 21, 12, 693);
    			attr_dev(div1, "class", "image-container svelte-kodszt");
    			add_location(div1, file$y, 17, 8, 423);
    			attr_dev(div2, "class", "title svelte-kodszt");
    			add_location(div2, file$y, 34, 12, 1091);
    			attr_dev(div3, "class", "artist svelte-kodszt");
    			add_location(div3, file$y, 35, 12, 1199);
    			attr_dev(div4, "class", "year");
    			add_location(div4, file$y, 36, 12, 1358);
    			attr_dev(div5, "class", "details svelte-kodszt");
    			add_location(div5, file$y, 33, 8, 1056);
    			attr_dev(div6, "class", "rating-container svelte-kodszt");
    			add_location(div6, file$y, 44, 8, 1683);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img0);
    			append_dev(div1, t0);
    			append_dev(div1, img1);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			mount_component(actions, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div2);
    			mount_component(link0, div2, null);
    			append_dev(div5, t3);
    			append_dev(div5, div3);
    			mount_component(link1, div3, null);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			if (if_block) if_block.m(div4, null);
    			append_dev(div4, t5);
    			append_dev(div4, t6);
    			append_dev(div4, t7);
    			append_dev(div4, t8);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div6, anchor);
    			mount_component(rating, div6, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*album*/ 1 && img0.src !== (img0_src_value = "" + (/*album*/ ctx[0].art + "&thumb=22"))) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (!current || dirty & /*album*/ 1 && img0_alt_value !== (img0_alt_value = "Image of " + /*album*/ ctx[0].name)) {
    				attr_dev(img0, "alt", img0_alt_value);
    			}

    			if (!current || dirty & /*album*/ 1 && img1.src !== (img1_src_value = "" + (/*album*/ ctx[0].art + "&thumb=1"))) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			const actions_changes = {};
    			if (dirty & /*album*/ 1) actions_changes.id = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) actions_changes.count = /*album*/ ctx[0].songcount;
    			if (dirty & /*album*/ 1) actions_changes.albumID = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) actions_changes.artistID = /*album*/ ctx[0].artist.id;
    			actions.$set(actions_changes);
    			const link0_changes = {};
    			if (dirty & /*album*/ 1) link0_changes.to = "albums/" + /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) link0_changes.title = /*album*/ ctx[0].name;

    			if (dirty & /*$$scope, album*/ 5) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty & /*album*/ 1) link1_changes.to = "artists/" + /*album*/ ctx[0].artist.id;
    			if (dirty & /*album*/ 1) link1_changes.title = /*album*/ ctx[0].artist.name;

    			if (dirty & /*$$scope, album*/ 5) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);

    			if (/*album*/ ctx[0].year > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*album*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div4, t5);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*album*/ 1) && t6_value !== (t6_value = /*album*/ ctx[0].songcount + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty & /*album*/ 1) && t8_value !== (t8_value = (parseInt(/*album*/ ctx[0].songcount) === 1
    			? "song"
    			: "songs") + "")) set_data_dev(t8, t8_value);

    			const rating_changes = {};
    			if (dirty & /*album*/ 1) rating_changes.id = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) rating_changes.rating = /*album*/ ctx[0].rating;
    			if (dirty & /*album*/ 1) rating_changes.flag = /*album*/ ctx[0].flag;
    			if (dirty & /*album*/ 1) rating_changes.averageRating = /*album*/ ctx[0].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(actions);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div5);
    			destroy_component(link0);
    			destroy_component(link1);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div6);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(17:4) {#if album}",
    		ctx
    	});

    	return block;
    }

    // (35:31) <Link to="albums/{album.id}" title="{album.name}">
    function create_default_slot_2$6(ctx) {
    	let t_value = /*album*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*album*/ 1 && t_value !== (t_value = /*album*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(35:31) <Link to=\\\"albums/{album.id}\\\" title=\\\"{album.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:32) <Link to="artists/{album.artist.id}" title="{album.artist.name}">
    function create_default_slot_1$9(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*album*/ ctx[0].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*album*/ 1) && t1_value !== (t1_value = /*album*/ ctx[0].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(36:32) <Link to=\\\"artists/{album.artist.id}\\\" title=\\\"{album.artist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:16) {#if album.year > 0}
    function create_if_block_1$i(ctx) {
    	let link;
    	let t;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/year/" + /*album*/ ctx[0].year,
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    			t = text(" •");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*album*/ 1) link_changes.to = "albums/year/" + /*album*/ ctx[0].year;

    			if (dirty & /*$$scope, album*/ 5) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(38:16) {#if album.year > 0}",
    		ctx
    	});

    	return block;
    }

    // (39:20) <Link to="albums/year/{album.year}">
    function create_default_slot$h(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = /*album*/ ctx[0].year + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*album*/ 1) && t1_value !== (t1_value = /*album*/ ctx[0].year + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(39:20) <Link to=\\\"albums/year/{album.year}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$o, create_else_block$k];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*album*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "album-card svelte-kodszt");
    			add_location(div, file$y, 15, 0, 372);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlbumCard", slots, []);
    	let { data = null } = $$props;
    	let album;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlbumCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		Link,
    		Rating,
    		Actions,
    		SVGArtist: Artist$1,
    		SVGYear: Year,
    		data,
    		album
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("album" in $$props) $$invalidate(0, album = $$props.album);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, album = data);
    		}
    	};

    	return [album, data];
    }

    class AlbumCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumCard",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get data() {
    		throw new Error("<AlbumCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<AlbumCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var albumCard = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': AlbumCard
    });

    /* src\components\albumSongs.svelte generated by Svelte v3.38.3 */
    const file$x = "src\\components\\albumSongs.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i][0];
    	child_ctx[5] = list[i][1];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (74:0) {:catch error}
    function create_catch_block$5(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*error*/ ctx[11].message + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Something went wrong: ");
    			t1 = text(t1_value);
    			add_location(p, file$x, 74, 4, 3136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && t1_value !== (t1_value = /*error*/ ctx[11].message + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$5.name,
    		type: "catch",
    		source: "(74:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (24:0) {:then songs}
    function create_then_block$5(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$j];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*songs*/ ctx[3].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$5.name,
    		type: "then",
    		source: "(24:0) {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (71:4) {:else}
    function create_else_block$j(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find songs";
    			add_location(p, file$x, 71, 8, 3076);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(71:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:4) {#if songs.length > 0}
    function create_if_block$n(ctx) {
    	let t0_value = /*_groupSongs*/ ctx[2](/*songs*/ ctx[3]) + "";
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let if_block = /*groupedSongs*/ ctx[1] && create_if_block_1$h(ctx);

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t0_value !== (t0_value = /*_groupSongs*/ ctx[2](/*songs*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

    			if (/*groupedSongs*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*groupedSongs*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(25:4) {#if songs.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (27:8) {#if groupedSongs}
    function create_if_block_1$h(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = [.../*groupedSongs*/ ctx[1]];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedSongs, formatSongLength*/ 2) {
    				each_value = [.../*groupedSongs*/ ctx[1]];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(27:8) {#if groupedSongs}",
    		ctx
    	});

    	return block;
    }

    // (30:20) {#if groupedSongs.size > 1}
    function create_if_block_3$9(ctx) {
    	let div;
    	let p;
    	let t0;
    	let t1_value = /*i*/ ctx[7] + 1 + "";
    	let t1;
    	let t2;
    	let span;
    	let actions;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "album",
    				mode: "miniButtons",
    				count: /*value*/ ctx[5].length,
    				direct: /*value*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text("Disc ");
    			t1 = text(t1_value);
    			t2 = space();
    			span = element("span");
    			create_component(actions.$$.fragment);
    			add_location(p, file$x, 31, 28, 973);
    			attr_dev(span, "class", "disc-actions svelte-8sp5wu");
    			add_location(span, file$x, 32, 28, 1020);
    			attr_dev(div, "class", "disc-info svelte-8sp5wu");
    			add_location(div, file$x, 30, 24, 920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(div, t2);
    			append_dev(div, span);
    			mount_component(actions, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*groupedSongs*/ 2) actions_changes.count = /*value*/ ctx[5].length;
    			if (dirty & /*groupedSongs*/ 2) actions_changes.direct = /*value*/ ctx[5];
    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$9.name,
    		type: "if",
    		source: "(30:20) {#if groupedSongs.size > 1}",
    		ctx
    	});

    	return block;
    }

    // (49:36) {#if song.albumartist.id !== song.artist.id}
    function create_if_block_2$f(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*song*/ ctx[8].artist.id,
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "class", "artist svelte-8sp5wu");
    			add_location(span, file$x, 49, 40, 1915);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*groupedSongs*/ 2) link_changes.to = "artists/" + /*song*/ ctx[8].artist.id;

    			if (dirty & /*$$scope, groupedSongs*/ 4098) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$f.name,
    		type: "if",
    		source: "(49:36) {#if song.albumartist.id !== song.artist.id}",
    		ctx
    	});

    	return block;
    }

    // (50:61) <Link to="artists/{song.artist.id}">
    function create_default_slot$g(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*song*/ ctx[8].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*groupedSongs*/ 2) && t1_value !== (t1_value = /*song*/ ctx[8].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(50:61) <Link to=\\\"artists/{song.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:24) {#each value as song}
    function create_each_block_1$4(ctx) {
    	let li;
    	let span0;
    	let t0_value = /*song*/ ctx[8].track + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*song*/ ctx[8].name + "";
    	let t2;
    	let t3;
    	let t4;
    	let span2;
    	let actions;
    	let t5;
    	let span3;
    	let t6_value = formatSongLength(/*song*/ ctx[8].time) + "";
    	let t6;
    	let t7;
    	let rating;
    	let t8;
    	let current;
    	let if_block = /*song*/ ctx[8].albumartist.id !== /*song*/ ctx[8].artist.id && create_if_block_2$f(ctx);

    	actions = new Actions({
    			props: {
    				type: "song",
    				mode: "miniButtons",
    				id: /*song*/ ctx[8].id,
    				count: "1",
    				artistID: /*song*/ ctx[8].artist.id,
    				albumID: /*song*/ ctx[8].album.id
    			},
    			$$inline: true
    		});

    	rating = new Rating({
    			props: {
    				type: "song",
    				id: /*song*/ ctx[8].id,
    				rating: /*song*/ ctx[8].rating,
    				flag: /*song*/ ctx[8].flag,
    				averageRating: /*song*/ ctx[8].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			span2 = element("span");
    			create_component(actions.$$.fragment);
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(rating.$$.fragment);
    			t8 = space();
    			attr_dev(span0, "class", "track svelte-8sp5wu");
    			add_location(span0, file$x, 45, 32, 1649);
    			attr_dev(span1, "class", "title svelte-8sp5wu");
    			add_location(span1, file$x, 46, 32, 1722);
    			attr_dev(span2, "class", "actions svelte-8sp5wu");
    			add_location(span2, file$x, 52, 32, 2150);
    			attr_dev(span3, "class", "time svelte-8sp5wu");
    			add_location(span3, file$x, 62, 32, 2689);
    			attr_dev(li, "class", "song-row svelte-8sp5wu");
    			add_location(li, file$x, 44, 28, 1594);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span0);
    			append_dev(span0, t0);
    			append_dev(li, t1);
    			append_dev(li, span1);
    			append_dev(span1, t2);
    			append_dev(span1, t3);
    			if (if_block) if_block.m(span1, null);
    			append_dev(li, t4);
    			append_dev(li, span2);
    			mount_component(actions, span2, null);
    			append_dev(li, t5);
    			append_dev(li, span3);
    			append_dev(span3, t6);
    			append_dev(li, t7);
    			mount_component(rating, li, null);
    			append_dev(li, t8);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*groupedSongs*/ 2) && t0_value !== (t0_value = /*song*/ ctx[8].track + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*groupedSongs*/ 2) && t2_value !== (t2_value = /*song*/ ctx[8].name + "")) set_data_dev(t2, t2_value);

    			if (/*song*/ ctx[8].albumartist.id !== /*song*/ ctx[8].artist.id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*groupedSongs*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(span1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const actions_changes = {};
    			if (dirty & /*groupedSongs*/ 2) actions_changes.id = /*song*/ ctx[8].id;
    			if (dirty & /*groupedSongs*/ 2) actions_changes.artistID = /*song*/ ctx[8].artist.id;
    			if (dirty & /*groupedSongs*/ 2) actions_changes.albumID = /*song*/ ctx[8].album.id;
    			actions.$set(actions_changes);
    			if ((!current || dirty & /*groupedSongs*/ 2) && t6_value !== (t6_value = formatSongLength(/*song*/ ctx[8].time) + "")) set_data_dev(t6, t6_value);
    			const rating_changes = {};
    			if (dirty & /*groupedSongs*/ 2) rating_changes.id = /*song*/ ctx[8].id;
    			if (dirty & /*groupedSongs*/ 2) rating_changes.rating = /*song*/ ctx[8].rating;
    			if (dirty & /*groupedSongs*/ 2) rating_changes.flag = /*song*/ ctx[8].flag;
    			if (dirty & /*groupedSongs*/ 2) rating_changes.averageRating = /*song*/ ctx[8].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(actions.$$.fragment, local);
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(actions.$$.fragment, local);
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			destroy_component(actions);
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(44:24) {#each value as song}",
    		ctx
    	});

    	return block;
    }

    // (28:12) {#each [...groupedSongs] as [key, value], i}
    function create_each_block$9(ctx) {
    	let section;
    	let t0;
    	let ul;
    	let ul_class_value;
    	let t1;
    	let section_intro;
    	let current;
    	let if_block = /*groupedSongs*/ ctx[1].size > 1 && create_if_block_3$9(ctx);
    	let each_value_1 = /*value*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");
    			if (if_block) if_block.c();
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			attr_dev(ul, "class", ul_class_value = "song-list " + (/*value*/ ctx[5].length > 5 ? "split" : "") + " svelte-8sp5wu");
    			add_location(ul, file$x, 42, 20, 1461);
    			add_location(section, file$x, 28, 16, 828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    			append_dev(section, t0);
    			append_dev(section, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(section, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*groupedSongs*/ ctx[1].size > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*groupedSongs*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*groupedSongs, formatSongLength*/ 2) {
    				each_value_1 = /*value*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*groupedSongs*/ 2 && ul_class_value !== (ul_class_value = "song-list " + (/*value*/ ctx[5].length > 5 ? "split" : "") + " svelte-8sp5wu")) {
    				attr_dev(ul, "class", ul_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			if (!section_intro) {
    				add_render_callback(() => {
    					section_intro = create_in_transition(section, fade, {});
    					section_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(28:12) {#each [...groupedSongs] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (22:30)       <p class="temp">Loading songs</p>  {:then songs}
    function create_pending_block$5(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading songs";
    			attr_dev(p, "class", "temp svelte-8sp5wu");
    			add_location(p, file$x, 22, 4, 618);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$5.name,
    		type: "pending",
    		source: "(22:30)       <p class=\\\"temp\\\">Loading songs</p>  {:then songs}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$5,
    		then: create_then_block$5,
    		catch: create_catch_block$5,
    		value: 3,
    		error: 11,
    		blocks: [,,,]
    	};

    	handle_promise(promise = getSongsFromAlbum(/*id*/ ctx[0]), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*id*/ 1 && promise !== (promise = getSongsFromAlbum(/*id*/ ctx[0])) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlbumSongs", slots, []);
    	let { id } = $$props;
    	let groupedSongs;

    	function _groupSongs(songs) {
    		$$invalidate(1, groupedSongs = groupSongsByDisc(songs));
    		return "";
    	}

    	const writable_props = ["id"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlbumSongs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Link,
    		getSongsFromAlbum,
    		groupSongsByDisc,
    		formatSongLength,
    		Rating,
    		Actions,
    		SVGArtist: Artist$1,
    		id,
    		groupedSongs,
    		_groupSongs
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("groupedSongs" in $$props) $$invalidate(1, groupedSongs = $$props.groupedSongs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, groupedSongs, _groupSongs];
    }

    class AlbumSongs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumSongs",
    			options,
    			id: create_fragment$E.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<AlbumSongs> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<AlbumSongs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<AlbumSongs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\visibility.svelte generated by Svelte v3.38.3 */
    const file$w = "src\\components\\visibility.svelte";

    const get_default_slot_changes = dirty => ({
    	percent: dirty & /*percent*/ 2,
    	unobserve: dirty & /*unobserve*/ 4
    });

    const get_default_slot_context = ctx => ({
    	percent: /*percent*/ ctx[1],
    	unobserve: /*unobserve*/ ctx[2]
    });

    function create_fragment$D(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div, file$w, 49, 0, 1248);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[10](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, percent, unobserve*/ 262)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[10](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function stepsToThreshold(steps) {
    	return [...Array(steps).keys()].map(n => n / steps);
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Visibility", slots, ['default']);
    	let { top = 0 } = $$props;
    	let { bottom = 500 } = $$props;
    	let { left = 0 } = $$props;
    	let { right = 0 } = $$props;
    	let { steps = 100 } = $$props;
    	let element;
    	let percent;
    	let observer;

    	let unobserve = () => {
    		
    	};

    	let intersectionObserverSupport = false;

    	function intersectPercent(entries) {
    		entries.forEach(entry => {
    			$$invalidate(1, percent = Math.round(Math.ceil(entry.intersectionRatio * 100)));
    		});
    	}

    	onMount(() => {
    		intersectionObserverSupport = "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype;

    		const options = {
    			root: document.querySelector(".site-content-inner"),
    			rootMargin: `${top}px ${right}px ${bottom}px ${left}px`,
    			threshold: stepsToThreshold(steps)
    		};

    		if (intersectionObserverSupport) {
    			observer = new IntersectionObserver(intersectPercent, options);
    			observer.observe(element);
    			$$invalidate(2, unobserve = () => observer.unobserve(element));
    		}

    		return unobserve;
    	});

    	const writable_props = ["top", "bottom", "left", "right", "steps"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Visibility> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("top" in $$props) $$invalidate(3, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(4, bottom = $$props.bottom);
    		if ("left" in $$props) $$invalidate(5, left = $$props.left);
    		if ("right" in $$props) $$invalidate(6, right = $$props.right);
    		if ("steps" in $$props) $$invalidate(7, steps = $$props.steps);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		top,
    		bottom,
    		left,
    		right,
    		steps,
    		element,
    		percent,
    		observer,
    		unobserve,
    		intersectionObserverSupport,
    		intersectPercent,
    		stepsToThreshold
    	});

    	$$self.$inject_state = $$props => {
    		if ("top" in $$props) $$invalidate(3, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(4, bottom = $$props.bottom);
    		if ("left" in $$props) $$invalidate(5, left = $$props.left);
    		if ("right" in $$props) $$invalidate(6, right = $$props.right);
    		if ("steps" in $$props) $$invalidate(7, steps = $$props.steps);
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("percent" in $$props) $$invalidate(1, percent = $$props.percent);
    		if ("observer" in $$props) observer = $$props.observer;
    		if ("unobserve" in $$props) $$invalidate(2, unobserve = $$props.unobserve);
    		if ("intersectionObserverSupport" in $$props) intersectionObserverSupport = $$props.intersectionObserverSupport;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		percent,
    		unobserve,
    		top,
    		bottom,
    		left,
    		right,
    		steps,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Visibility extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			top: 3,
    			bottom: 4,
    			left: 5,
    			right: 6,
    			steps: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Visibility",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get top() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottom() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottom(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get steps() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set steps(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\albumCardExpanded.svelte generated by Svelte v3.38.3 */
    const file$v = "src\\components\\albumCardExpanded.svelte";

    // (25:31) <Link to="albums/{album.id}">
    function create_default_slot_3$4(ctx) {
    	let t_value = /*album*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*album*/ 1 && t_value !== (t_value = /*album*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(25:31) <Link to=\\\"albums/{album.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:32) <Link to="artists/{album.artist.id}">
    function create_default_slot_2$5(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*album*/ ctx[0].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*album*/ 1) && t1_value !== (t1_value = /*album*/ ctx[0].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(26:32) <Link to=\\\"artists/{album.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:16) {:else}
    function create_else_block$i(ctx) {
    	let br;

    	const block = {
    		c: function create() {
    			br = element("br");
    			add_location(br, file$v, 30, 20, 1209);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(30:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (28:16) {#if album.year > 0}
    function create_if_block_1$g(ctx) {
    	let link;
    	let t;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/year/" + /*album*/ ctx[0].year,
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    			t = text(" •");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*album*/ 1) link_changes.to = "albums/year/" + /*album*/ ctx[0].year;

    			if (dirty & /*$$scope, album*/ 17) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(28:16) {#if album.year > 0}",
    		ctx
    	});

    	return block;
    }

    // (29:20) <Link to="albums/year/{album.year}">
    function create_default_slot_1$8(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = /*album*/ ctx[0].year + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*album*/ 1) && t1_value !== (t1_value = /*album*/ ctx[0].year + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(29:20) <Link to=\\\"albums/year/{album.year}\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:8) {#if percent > 0}
    function create_if_block$m(ctx) {
    	let div;
    	let albumsongs;
    	let current;
    	let mounted;
    	let dispose;

    	albumsongs = new AlbumSongs({
    			props: { id: /*album*/ ctx[0].id },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(albumsongs.$$.fragment);
    			attr_dev(div, "class", "songs");
    			add_location(div, file$v, 54, 12, 2069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(albumsongs, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*unobserve*/ ctx[3].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const albumsongs_changes = {};
    			if (dirty & /*album*/ 1) albumsongs_changes.id = /*album*/ ctx[0].id;
    			albumsongs.$set(albumsongs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumsongs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumsongs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(albumsongs);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(54:8) {#if percent > 0}",
    		ctx
    	});

    	return block;
    }

    // (53:4) <Visibility steps={100} let:percent let:unobserve>
    function create_default_slot$f(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*percent*/ ctx[2] > 0 && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*percent*/ ctx[2] > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*percent*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(53:4) <Visibility steps={100} let:percent let:unobserve>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t0;
    	let div6;
    	let div1;
    	let link0;
    	let t1;
    	let div2;
    	let link1;
    	let t2;
    	let div3;
    	let current_block_type_index;
    	let if_block;
    	let t3;
    	let t4_value = /*album*/ ctx[0].songcount + "";
    	let t4;
    	let t5;

    	let t6_value = (parseInt(/*album*/ ctx[0].songcount) === 1
    	? "song"
    	: "songs") + "";

    	let t6;
    	let t7;
    	let div5;
    	let rating;
    	let t8;
    	let div4;
    	let actions;
    	let t9;
    	let visibility;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "albums/" + /*album*/ ctx[0].id,
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "artists/" + /*album*/ ctx[0].artist.id,
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1$g, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*album*/ ctx[0].year > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	rating = new Rating({
    			props: {
    				type: "album",
    				id: /*album*/ ctx[0].id,
    				rating: /*album*/ ctx[0].rating,
    				flag: /*album*/ ctx[0].flag,
    				averageRating: /*album*/ ctx[0].averagerating
    			},
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				type: "album",
    				mode: "miniButtons",
    				id: /*album*/ ctx[0].id,
    				count: /*album*/ ctx[0].songcount,
    				albumID: /*album*/ ctx[0].id,
    				artistID: /*album*/ ctx[0].artist.id
    			},
    			$$inline: true
    		});

    	visibility = new Visibility({
    			props: {
    				steps: 100,
    				$$slots: {
    					default: [
    						create_default_slot$f,
    						({ percent, unobserve }) => ({ 2: percent, 3: unobserve }),
    						({ percent, unobserve }) => (percent ? 4 : 0) | (unobserve ? 8 : 0)
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div6 = element("div");
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(link1.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			if_block.c();
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			div5 = element("div");
    			create_component(rating.$$.fragment);
    			t8 = space();
    			div4 = element("div");
    			create_component(actions.$$.fragment);
    			t9 = space();
    			create_component(visibility.$$.fragment);
    			attr_dev(img, "width", "125");
    			attr_dev(img, "height", "125");
    			attr_dev(img, "class", "image svelte-1ihu8nd");
    			if (img.src !== (img_src_value = "" + (/*album*/ ctx[0].art + "&thumb=22"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*album*/ ctx[0].name);
    			attr_dev(img, "loading", "lazy");
    			add_location(img, file$v, 20, 12, 601);
    			attr_dev(div0, "class", "image-container svelte-1ihu8nd");
    			add_location(div0, file$v, 19, 8, 558);
    			attr_dev(div1, "class", "title svelte-1ihu8nd");
    			add_location(div1, file$v, 24, 12, 778);
    			attr_dev(div2, "class", "artist");
    			add_location(div2, file$v, 25, 12, 865);
    			attr_dev(div3, "class", "year");
    			add_location(div3, file$v, 26, 12, 996);
    			attr_dev(div4, "class", "actions");
    			add_location(div4, file$v, 38, 16, 1549);
    			attr_dev(div5, "class", "actions-container svelte-1ihu8nd");
    			add_location(div5, file$v, 35, 12, 1360);
    			attr_dev(div6, "class", "details");
    			add_location(div6, file$v, 23, 8, 743);
    			attr_dev(div7, "class", "info svelte-1ihu8nd");
    			add_location(div7, file$v, 18, 4, 530);
    			attr_dev(div8, "class", "album-card-expanded svelte-1ihu8nd");
    			add_location(div8, file$v, 17, 0, 491);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, img);
    			append_dev(div7, t0);
    			append_dev(div7, div6);
    			append_dev(div6, div1);
    			mount_component(link0, div1, null);
    			append_dev(div6, t1);
    			append_dev(div6, div2);
    			mount_component(link1, div2, null);
    			append_dev(div6, t2);
    			append_dev(div6, div3);
    			if_blocks[current_block_type_index].m(div3, null);
    			append_dev(div3, t3);
    			append_dev(div3, t4);
    			append_dev(div3, t5);
    			append_dev(div3, t6);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			mount_component(rating, div5, null);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			mount_component(actions, div4, null);
    			append_dev(div8, t9);
    			mount_component(visibility, div8, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*album*/ 1 && img.src !== (img_src_value = "" + (/*album*/ ctx[0].art + "&thumb=22"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*album*/ 1 && img_alt_value !== (img_alt_value = "Image of " + /*album*/ ctx[0].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			const link0_changes = {};
    			if (dirty & /*album*/ 1) link0_changes.to = "albums/" + /*album*/ ctx[0].id;

    			if (dirty & /*$$scope, album*/ 17) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty & /*album*/ 1) link1_changes.to = "artists/" + /*album*/ ctx[0].artist.id;

    			if (dirty & /*$$scope, album*/ 17) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div3, t3);
    			}

    			if ((!current || dirty & /*album*/ 1) && t4_value !== (t4_value = /*album*/ ctx[0].songcount + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*album*/ 1) && t6_value !== (t6_value = (parseInt(/*album*/ ctx[0].songcount) === 1
    			? "song"
    			: "songs") + "")) set_data_dev(t6, t6_value);

    			const rating_changes = {};
    			if (dirty & /*album*/ 1) rating_changes.id = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) rating_changes.rating = /*album*/ ctx[0].rating;
    			if (dirty & /*album*/ 1) rating_changes.flag = /*album*/ ctx[0].flag;
    			if (dirty & /*album*/ 1) rating_changes.averageRating = /*album*/ ctx[0].averagerating;
    			rating.$set(rating_changes);
    			const actions_changes = {};
    			if (dirty & /*album*/ 1) actions_changes.id = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) actions_changes.count = /*album*/ ctx[0].songcount;
    			if (dirty & /*album*/ 1) actions_changes.albumID = /*album*/ ctx[0].id;
    			if (dirty & /*album*/ 1) actions_changes.artistID = /*album*/ ctx[0].artist.id;
    			actions.$set(actions_changes);
    			const visibility_changes = {};

    			if (dirty & /*$$scope, album, percent*/ 21) {
    				visibility_changes.$$scope = { dirty, ctx };
    			}

    			visibility.$set(visibility_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(rating.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			transition_in(visibility.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(rating.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			transition_out(visibility.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(link0);
    			destroy_component(link1);
    			if_blocks[current_block_type_index].d();
    			destroy_component(rating);
    			destroy_component(actions);
    			destroy_component(visibility);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlbumCardExpanded", slots, []);
    	let { data } = $$props;
    	let album;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlbumCardExpanded> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		Link,
    		AlbumSongs,
    		Rating,
    		Visibility,
    		Actions,
    		SVGArtist: Artist$1,
    		SVGYear: Year,
    		data,
    		album
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("album" in $$props) $$invalidate(0, album = $$props.album);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, album = data);
    		}
    	};

    	return [album, data];
    }

    class AlbumCardExpanded extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumCardExpanded",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[1] === undefined && !("data" in props)) {
    			console.warn("<AlbumCardExpanded> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<AlbumCardExpanded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<AlbumCardExpanded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\artistReleases.svelte generated by Svelte v3.38.3 */
    const file$u = "src\\components\\artistReleases.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i][0];
    	child_ctx[7] = list[i][1];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (54:4) {:else}
    function create_else_block_1$7(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find any albums";
    			add_location(p, file$u, 54, 8, 1920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$7.name,
    		type: "else",
    		source: "(54:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#if groupedAlbums}
    function create_if_block_1$f(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = [.../*groupedAlbums*/ ctx[0]];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedAlbums, $ShowExpandedAlbums*/ 5) {
    				each_value = [.../*groupedAlbums*/ ctx[0]];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(29:4) {#if groupedAlbums}",
    		ctx
    	});

    	return block;
    }

    // (26:0) {#if loading}
    function create_if_block$l(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading releases";
    			add_location(p, file$u, 26, 4, 794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(26:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (31:12) {#if value.length > 0}
    function create_if_block_2$e(ctx) {
    	let section;
    	let t0;
    	let div;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let section_intro;
    	let current;
    	let if_block0 = /*key*/ ctx[6] !== "ungrouped" && create_if_block_4$7(ctx);
    	const if_block_creators = [create_if_block_3$8, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$ShowExpandedAlbums*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if_block1.c();
    			t1 = space();
    			attr_dev(div, "class", "items");
    			add_location(div, file$u, 35, 20, 1174);
    			add_location(section, file$u, 31, 16, 960);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			if (if_block0) if_block0.m(section, null);
    			append_dev(section, t0);
    			append_dev(section, div);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(section, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*key*/ ctx[6] !== "ungrouped") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$7(ctx);
    					if_block0.c();
    					if_block0.m(section, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			if (!section_intro) {
    				add_render_callback(() => {
    					section_intro = create_in_transition(section, fade, {
    						duration: /*i*/ ctx[9] === 0 ? undefined : 0
    					});

    					section_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$e.name,
    		type: "if",
    		source: "(31:12) {#if value.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (33:20) {#if key !== "ungrouped"}
    function create_if_block_4$7(ctx) {
    	let h3;
    	let t_value = /*key*/ ctx[6] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t = text(t_value);
    			attr_dev(h3, "class", "release-type svelte-fiu86");
    			add_location(h3, file$u, 33, 24, 1090);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedAlbums*/ 1 && t_value !== (t_value = /*key*/ ctx[6] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(33:20) {#if key !== \\\"ungrouped\\\"}",
    		ctx
    	});

    	return block;
    }

    // (41:24) {:else}
    function create_else_block$h(ctx) {
    	let ul;
    	let current;
    	let each_value_2 = /*value*/ ctx[7];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "album-grid");
    			add_location(ul, file$u, 41, 28, 1465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedAlbums*/ 1) {
    				each_value_2 = /*value*/ ctx[7];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(41:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:24) {#if $ShowExpandedAlbums}
    function create_if_block_3$8(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*value*/ ctx[7];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedAlbums*/ 1) {
    				each_value_1 = /*value*/ ctx[7];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(37:24) {#if $ShowExpandedAlbums}",
    		ctx
    	});

    	return block;
    }

    // (43:32) {#each value as album}
    function create_each_block_2$2(ctx) {
    	let li;
    	let albumcard;
    	let t;
    	let current;

    	albumcard = new AlbumCard({
    			props: { data: /*album*/ ctx[10] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(albumcard.$$.fragment);
    			t = space();
    			add_location(li, file$u, 43, 36, 1582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(albumcard, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const albumcard_changes = {};
    			if (dirty & /*groupedAlbums*/ 1) albumcard_changes.data = /*album*/ ctx[10];
    			albumcard.$set(albumcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(albumcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(43:32) {#each value as album}",
    		ctx
    	});

    	return block;
    }

    // (38:28) {#each value as album}
    function create_each_block_1$3(ctx) {
    	let albumcardexpanded;
    	let current;

    	albumcardexpanded = new AlbumCardExpanded({
    			props: { data: /*album*/ ctx[10] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(albumcardexpanded.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(albumcardexpanded, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const albumcardexpanded_changes = {};
    			if (dirty & /*groupedAlbums*/ 1) albumcardexpanded_changes.data = /*album*/ ctx[10];
    			albumcardexpanded.$set(albumcardexpanded_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumcardexpanded.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumcardexpanded.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(albumcardexpanded, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(38:28) {#each value as album}",
    		ctx
    	});

    	return block;
    }

    // (30:8) {#each [...groupedAlbums] as [key, value], i}
    function create_each_block$8(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*value*/ ctx[7].length > 0 && create_if_block_2$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*value*/ ctx[7].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*groupedAlbums*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(30:8) {#each [...groupedAlbums] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$l, create_if_block_1$f, create_else_block_1$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[1]) return 0;
    		if (/*groupedAlbums*/ ctx[0]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $ShowExpandedAlbums;
    	validate_store(ShowExpandedAlbums, "ShowExpandedAlbums");
    	component_subscribe($$self, ShowExpandedAlbums, $$value => $$invalidate(2, $ShowExpandedAlbums = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArtistReleases", slots, []);
    	let { artistID } = $$props;
    	let albums;
    	let sortedAlbums;
    	let groupedAlbums;
    	let loading = true;

    	onMount(async () => {
    		albums = await getAlbumsByArtist(artistID);
    		sortedAlbums = await sortAlbumsByDate(albums);
    		$$invalidate(0, groupedAlbums = await groupAlbumsByReleaseType(sortedAlbums));
    		$$invalidate(1, loading = false);
    	});

    	const writable_props = ["artistID"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArtistReleases> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("artistID" in $$props) $$invalidate(3, artistID = $$props.artistID);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		ShowExpandedAlbums,
    		getAlbumsByArtist,
    		sortAlbumsByDate,
    		groupAlbumsByReleaseType,
    		AlbumCard,
    		AlbumCardExpanded,
    		artistID,
    		albums,
    		sortedAlbums,
    		groupedAlbums,
    		loading,
    		$ShowExpandedAlbums
    	});

    	$$self.$inject_state = $$props => {
    		if ("artistID" in $$props) $$invalidate(3, artistID = $$props.artistID);
    		if ("albums" in $$props) albums = $$props.albums;
    		if ("sortedAlbums" in $$props) sortedAlbums = $$props.sortedAlbums;
    		if ("groupedAlbums" in $$props) $$invalidate(0, groupedAlbums = $$props.groupedAlbums);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [groupedAlbums, loading, $ShowExpandedAlbums, artistID];
    }

    class ArtistReleases extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { artistID: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtistReleases",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*artistID*/ ctx[3] === undefined && !("artistID" in props)) {
    			console.warn("<ArtistReleases> was created without expected prop 'artistID'");
    		}
    	}

    	get artistID() {
    		throw new Error("<ArtistReleases>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set artistID(value) {
    		throw new Error("<ArtistReleases>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\artistSongs.svelte generated by Svelte v3.38.3 */
    const file$t = "src\\components\\artistSongs.svelte";

    // (28:0) {:else}
    function create_else_block$g(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading songs";
    			add_location(p, file$t, 28, 4, 655);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(28:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:0) {#if !loading && songs && songs.length > 0}
    function create_if_block$k(ctx) {
    	let lister;
    	let updating_data;
    	let current;

    	function lister_data_binding(value) {
    		/*lister_data_binding*/ ctx[3](value);
    	}

    	let lister_props = { type: "song" };

    	if (/*songs*/ ctx[0] !== void 0) {
    		lister_props.data = /*songs*/ ctx[0];
    	}

    	lister = new Lister({ props: lister_props, $$inline: true });
    	binding_callbacks.push(() => bind(lister, "data", lister_data_binding));

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};

    			if (!updating_data && dirty & /*songs*/ 1) {
    				updating_data = true;
    				lister_changes.data = /*songs*/ ctx[0];
    				add_flush_callback(() => updating_data = false);
    			}

    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(26:0) {#if !loading && songs && songs.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*loading*/ ctx[1] && /*songs*/ ctx[0] && /*songs*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArtistSongs", slots, []);
    	let { artistID } = $$props;
    	let songs = [];
    	let loading = false;

    	function handleSortByName() {
    		$$invalidate(1, loading = true);
    		$$invalidate(0, songs = sortSongsByName(songs));
    		$$invalidate(1, loading = false);
    	}

    	onMount(async () => {
    		$$invalidate(0, songs = await getSongsFromArtist(artistID));
    		handleSortByName();
    	});

    	const writable_props = ["artistID"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArtistSongs> was created with unknown prop '${key}'`);
    	});

    	function lister_data_binding(value) {
    		songs = value;
    		$$invalidate(0, songs);
    	}

    	$$self.$$set = $$props => {
    		if ("artistID" in $$props) $$invalidate(2, artistID = $$props.artistID);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		getSongsFromArtist,
    		sortSongsByName,
    		Lister,
    		artistID,
    		songs,
    		loading,
    		handleSortByName
    	});

    	$$self.$inject_state = $$props => {
    		if ("artistID" in $$props) $$invalidate(2, artistID = $$props.artistID);
    		if ("songs" in $$props) $$invalidate(0, songs = $$props.songs);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*songs*/ 1) {
    			$$invalidate(0, songs);
    		}
    	};

    	return [songs, loading, artistID, lister_data_binding];
    }

    class ArtistSongs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { artistID: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtistSongs",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*artistID*/ ctx[2] === undefined && !("artistID" in props)) {
    			console.warn("<ArtistSongs> was created without expected prop 'artistID'");
    		}
    	}

    	get artistID() {
    		throw new Error("<ArtistSongs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set artistID(value) {
    		throw new Error("<ArtistSongs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var throttle_1 = createCommonjsModule(function (module, exports) {
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Throttle = exports.throttle = void 0;
    var defaultOptions = {
        max: 100,
    };
    /**
     * Wraps a function into a function that checks and wait until the time has passed before calling the original function
     * @param time The time to wait in milliseconds
     * @param cb The function to call
     */
    function throttle(time, cb, options) {
        if (options === void 0) { options = defaultOptions; }
        var opt = __assign(__assign({}, defaultOptions), options);
        var throttleInfo = {
            next: new Date().getTime(),
            queue: 0,
            bump: function () {
                var now = new Date().getTime();
                var next = throttleInfo.next - now;
                throttleInfo.next = throttleInfo.next + time + 50; // because of setTimeout inaccuracy, adding some buffer to be sure
                throttleInfo.queue += 1;
                if (throttleInfo.queue > opt.max) {
                    throw new Error("Throttle backpressure error: Throttle is being called faster than it can run (queue=" + throttleInfo.queue + " max=" + opt.max + " throttle=" + time + " wait=" + next + ")");
                }
                return next;
            },
        };
        return function (context, args) {
            var go = function () {
                var result = cb.apply(context, args);
                throttleInfo.queue -= 1;
                return result;
            };
            var nextRun = throttleInfo.bump();
            if (nextRun > 0) {
                if (opt.onThrottle) {
                    opt.onThrottle(nextRun, throttleInfo.queue);
                }
                return new Promise(function (resolve, reject) {
                    return setTimeout(function () {
                        try {
                            resolve(go());
                        }
                        catch (err) {
                            reject(err);
                            return;
                        }
                    }, nextRun);
                });
            }
            return go();
        };
    }
    exports.throttle = throttle;
    /**
     * Ensures that a funciton is not called more than once per specified time
     * @param time The time to wait in milliseconds
     */
    exports.Throttle = function (time, options) { return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        var methodT = throttle(time, method, options);
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodT(this, args);
        };
    }; };
    });

    var dist = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(throttle_1, exports);
    });

    /* src\components\musicbrainzScan.svelte generated by Svelte v3.38.3 */

    const { console: console_1 } = globals;
    const file$s = "src\\components\\musicbrainzScan.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	child_ctx[48] = i;
    	return child_ctx;
    }

    // (334:8) {#if loading && additionalQueries > 0}
    function create_if_block_9$2(ctx) {
    	let div;
    	let span;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "progress-value svelte-1r3lg3i");
    			attr_dev(span, "style", span_style_value = `width: ${/*loadCount*/ ctx[1] / (/*additionalQueries*/ ctx[17] + 1) * 100}%;`);
    			add_location(span, file$s, 335, 16, 10654);
    			attr_dev(div, "class", "progress-bar svelte-1r3lg3i");
    			add_location(div, file$s, 334, 12, 10610);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*loadCount, additionalQueries*/ 131074 && span_style_value !== (span_style_value = `width: ${/*loadCount*/ ctx[1] / (/*additionalQueries*/ ctx[17] + 1) * 100}%;`)) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(334:8) {#if loading && additionalQueries > 0}",
    		ctx
    	});

    	return block;
    }

    // (344:8) {:else}
    function create_else_block_1$6(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Artist is missing a MusicBrainz Artist ID tag";
    			add_location(p, file$s, 344, 12, 11000);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(344:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (340:8) {#if hasMusicbrainz}
    function create_if_block_7$4(ctx) {
    	let if_block_anchor;
    	let if_block = /*loadCount*/ ctx[1] < 1 && create_if_block_8$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*loadCount*/ ctx[1] < 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_8$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$4.name,
    		type: "if",
    		source: "(340:8) {#if hasMusicbrainz}",
    		ctx
    	});

    	return block;
    }

    // (341:12) {#if loadCount < 1}
    function create_if_block_8$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Begin comparison";
    			attr_dev(button, "class", "submit primary svelte-1r3lg3i");
    			add_location(button, file$s, 341, 16, 10874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleGo*/ ctx[22], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(341:12) {#if loadCount < 1}",
    		ctx
    	});

    	return block;
    }

    // (348:8) {#if !loading & loadCount > 0}
    function create_if_block$j(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*filteredRecordings*/ ctx[2].length > 0) return create_if_block_1$e;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block);
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(348:8) {#if !loading & loadCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (387:12) {:else}
    function create_else_block$f(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No recordings found or scan has not begun";
    			add_location(p, file$s, 387, 16, 13040);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(387:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (349:12) {#if filteredRecordings.length > 0}
    function create_if_block_1$e(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let tbody;
    	let table_intro;
    	let each_value = /*filteredRecordings*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Title";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Length";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Result";
    			t5 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$s, 352, 24, 11272);
    			add_location(th1, file$s, 353, 24, 11312);
    			add_location(th2, file$s, 354, 24, 11353);
    			add_location(tr, file$s, 351, 20, 11242);
    			add_location(thead, file$s, 350, 20, 11213);
    			add_location(tbody, file$s, 357, 20, 11447);
    			add_location(table, file$s, 349, 16, 11176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(table, t5);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredRecordings*/ 4) {
    				each_value = /*filteredRecordings*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (!table_intro) {
    				add_render_callback(() => {
    					table_intro = create_in_transition(table, fade, {});
    					table_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(349:12) {#if filteredRecordings.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (363:36) {#if mbRecording.video}
    function create_if_block_6$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("[VIDEO]");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$5.name,
    		type: "if",
    		source: "(363:36) {#if mbRecording.video}",
    		ctx
    	});

    	return block;
    }

    // (366:32) {#if mbRecording.disambiguation}
    function create_if_block_5$5(ctx) {
    	let em;
    	let t0;
    	let t1_value = /*mbRecording*/ ctx[46].disambiguation + "";
    	let t1;

    	const block = {
    		c: function create() {
    			em = element("em");
    			t0 = text("- ");
    			t1 = text(t1_value);
    			add_location(em, file$s, 366, 36, 11935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, em, anchor);
    			append_dev(em, t0);
    			append_dev(em, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredRecordings*/ 4 && t1_value !== (t1_value = /*mbRecording*/ ctx[46].disambiguation + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(em);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(366:32) {#if mbRecording.disambiguation}",
    		ctx
    	});

    	return block;
    }

    // (378:36) {#if mbRecording.result === 'exact'}
    function create_if_block_4$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Exact MBID match");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(378:36) {#if mbRecording.result === 'exact'}",
    		ctx
    	});

    	return block;
    }

    // (379:36) {#if mbRecording.result === 'name'}
    function create_if_block_3$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Duplicate name of exact match");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(379:36) {#if mbRecording.result === 'name'}",
    		ctx
    	});

    	return block;
    }

    // (380:36) {#if !mbRecording.result}
    function create_if_block_2$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Missing");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(380:36) {#if !mbRecording.result}",
    		ctx
    	});

    	return block;
    }

    // (359:20) {#each filteredRecordings as mbRecording, i}
    function create_each_block$7(ctx) {
    	let tr;
    	let td0;
    	let a;
    	let t0;
    	let t1_value = /*mbRecording*/ ctx[46].title + "";
    	let t1;
    	let a_href_value;
    	let t2;
    	let t3;
    	let td1;
    	let t4_value = formatTotalTime(/*mbRecording*/ ctx[46]["length"] / 1000) + "";
    	let t4;
    	let t5;
    	let td2;
    	let span;
    	let t6;
    	let t7;
    	let t8;
    	let if_block0 = /*mbRecording*/ ctx[46].video && create_if_block_6$5(ctx);
    	let if_block1 = /*mbRecording*/ ctx[46].disambiguation && create_if_block_5$5(ctx);
    	let if_block2 = /*mbRecording*/ ctx[46].result === "exact" && create_if_block_4$6(ctx);
    	let if_block3 = /*mbRecording*/ ctx[46].result === "name" && create_if_block_3$7(ctx);
    	let if_block4 = !/*mbRecording*/ ctx[46].result && create_if_block_2$d(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			td1 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td2 = element("td");
    			span = element("span");
    			if (if_block2) if_block2.c();
    			t6 = space();
    			if (if_block3) if_block3.c();
    			t7 = space();
    			if (if_block4) if_block4.c();
    			t8 = space();
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "href", a_href_value = `https://musicbrainz.org/recording/${/*mbRecording*/ ctx[46].id}`);
    			add_location(a, file$s, 361, 32, 11618);
    			add_location(td0, file$s, 360, 28, 11580);
    			add_location(td1, file$s, 369, 28, 12078);
    			attr_dev(span, "class", "badge");
    			toggle_class(span, "success", /*mbRecording*/ ctx[46].result === "exact");
    			toggle_class(span, "warning", /*mbRecording*/ ctx[46].result === "name");
    			toggle_class(span, "danger", !/*mbRecording*/ ctx[46].result);
    			add_location(span, file$s, 371, 32, 12202);
    			add_location(td2, file$s, 370, 28, 12164);
    			add_location(tr, file$s, 359, 24, 11546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, a);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);
    			append_dev(a, t1);
    			append_dev(td0, t2);
    			if (if_block1) if_block1.m(td0, null);
    			append_dev(tr, t3);
    			append_dev(tr, td1);
    			append_dev(td1, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td2);
    			append_dev(td2, span);
    			if (if_block2) if_block2.m(span, null);
    			append_dev(span, t6);
    			if (if_block3) if_block3.m(span, null);
    			append_dev(span, t7);
    			if (if_block4) if_block4.m(span, null);
    			append_dev(tr, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (/*mbRecording*/ ctx[46].video) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_6$5(ctx);
    					if_block0.c();
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*filteredRecordings*/ 4 && t1_value !== (t1_value = /*mbRecording*/ ctx[46].title + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*filteredRecordings*/ 4 && a_href_value !== (a_href_value = `https://musicbrainz.org/recording/${/*mbRecording*/ ctx[46].id}`)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (/*mbRecording*/ ctx[46].disambiguation) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_5$5(ctx);
    					if_block1.c();
    					if_block1.m(td0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*filteredRecordings*/ 4 && t4_value !== (t4_value = formatTotalTime(/*mbRecording*/ ctx[46]["length"] / 1000) + "")) set_data_dev(t4, t4_value);

    			if (/*mbRecording*/ ctx[46].result === "exact") {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_4$6(ctx);
    					if_block2.c();
    					if_block2.m(span, t6);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*mbRecording*/ ctx[46].result === "name") {
    				if (if_block3) ; else {
    					if_block3 = create_if_block_3$7(ctx);
    					if_block3.c();
    					if_block3.m(span, t7);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!/*mbRecording*/ ctx[46].result) {
    				if (if_block4) ; else {
    					if_block4 = create_if_block_2$d(ctx);
    					if_block4.c();
    					if_block4.m(span, null);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (dirty[0] & /*filteredRecordings*/ 4) {
    				toggle_class(span, "success", /*mbRecording*/ ctx[46].result === "exact");
    			}

    			if (dirty[0] & /*filteredRecordings*/ 4) {
    				toggle_class(span, "warning", /*mbRecording*/ ctx[46].result === "name");
    			}

    			if (dirty[0] & /*filteredRecordings*/ 4) {
    				toggle_class(span, "danger", !/*mbRecording*/ ctx[46].result);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(359:20) {#each filteredRecordings as mbRecording, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0;
    	let t1_value = /*filteredRecordings*/ ctx[2].length + "";
    	let t1;
    	let t2;
    	let t3_value = /*allRecordings*/ ctx[0].length + "";
    	let t3;
    	let t4;
    	let h40;
    	let t6;
    	let label0;
    	let input0;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let label1;
    	let input1;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let label2;
    	let input2;
    	let t15;
    	let t16;
    	let t17;
    	let t18;
    	let label3;
    	let input3;
    	let t19;
    	let t20;
    	let label4;
    	let input4;
    	let t21;
    	let t22;
    	let label5;
    	let input5;
    	let t23;
    	let t24;
    	let label6;
    	let input6;
    	let t25;
    	let t26;
    	let label7;
    	let input7;
    	let t27;
    	let t28;
    	let label8;
    	let input8;
    	let t29;
    	let t30;
    	let label9;
    	let input9;
    	let t31;
    	let t32;
    	let label10;
    	let input10;
    	let t33;
    	let t34;
    	let label11;
    	let input11;
    	let t35;
    	let t36;
    	let h41;
    	let t38;
    	let label12;
    	let t39;
    	let input12;
    	let t40;
    	let div2;
    	let t41;
    	let t42;
    	let mounted;
    	let dispose;
    	let if_block0 = /*loading*/ ctx[16] && /*additionalQueries*/ ctx[17] > 0 && create_if_block_9$2(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*hasMusicbrainz*/ ctx[21]) return create_if_block_7$4;
    		return create_else_block_1$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = !/*loading*/ ctx[16] & /*loadCount*/ ctx[1] > 0 && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Showing ");
    			t1 = text(t1_value);
    			t2 = text(" of ");
    			t3 = text(t3_value);
    			t4 = space();
    			h40 = element("h4");
    			h40.textContent = "Show";
    			t6 = space();
    			label0 = element("label");
    			input0 = element("input");
    			t7 = text("\r\n            Matches (");
    			t8 = text(/*countMatches*/ ctx[18]);
    			t9 = text(")");
    			t10 = space();
    			label1 = element("label");
    			input1 = element("input");
    			t11 = text("\r\n            Duplicates (");
    			t12 = text(/*countDuplicates*/ ctx[19]);
    			t13 = text(")");
    			t14 = space();
    			label2 = element("label");
    			input2 = element("input");
    			t15 = text("\r\n            Missing (");
    			t16 = text(/*countMissing*/ ctx[20]);
    			t17 = text(")");
    			t18 = space();
    			label3 = element("label");
    			input3 = element("input");
    			t19 = text("\r\n            Remixes");
    			t20 = space();
    			label4 = element("label");
    			input4 = element("input");
    			t21 = text("\r\n            Instrumentals/Acapellas");
    			t22 = space();
    			label5 = element("label");
    			input5 = element("input");
    			t23 = text("\r\n            Radio edits");
    			t24 = space();
    			label6 = element("label");
    			input6 = element("input");
    			t25 = text("\r\n            Live recordings");
    			t26 = space();
    			label7 = element("label");
    			input7 = element("input");
    			t27 = text("\r\n            Length under 60 seconds");
    			t28 = space();
    			label8 = element("label");
    			input8 = element("input");
    			t29 = text("\r\n            Demos");
    			t30 = space();
    			label9 = element("label");
    			input9 = element("input");
    			t31 = text("\r\n            Interviews/commentary");
    			t32 = space();
    			label10 = element("label");
    			input10 = element("input");
    			t33 = text("\r\n            Zero length tracks");
    			t34 = space();
    			label11 = element("label");
    			input11 = element("input");
    			t35 = text("\r\n            Videos");
    			t36 = space();
    			h41 = element("h4");
    			h41.textContent = "Hide";
    			t38 = space();
    			label12 = element("label");
    			t39 = text("Regex pattern:\r\n            ");
    			input12 = element("input");
    			t40 = space();
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t41 = space();
    			if_block1.c();
    			t42 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div0, "class", "total badge info svelte-1r3lg3i");
    			add_location(div0, file$s, 260, 8, 8575);
    			attr_dev(h40, "class", "svelte-1r3lg3i");
    			add_location(h40, file$s, 262, 8, 8684);
    			attr_dev(input0, "type", "checkbox");
    			add_location(input0, file$s, 265, 12, 8730);
    			attr_dev(label0, "class", "svelte-1r3lg3i");
    			add_location(label0, file$s, 264, 8, 8709);
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$s, 270, 12, 8872);
    			attr_dev(label1, "class", "svelte-1r3lg3i");
    			add_location(label1, file$s, 269, 8, 8851);
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$s, 275, 12, 9023);
    			attr_dev(label2, "class", "svelte-1r3lg3i");
    			add_location(label2, file$s, 274, 8, 9002);
    			attr_dev(input3, "type", "checkbox");
    			add_location(input3, file$s, 280, 12, 9190);
    			attr_dev(label3, "class", "filter-separator svelte-1r3lg3i");
    			add_location(label3, file$s, 279, 8, 9144);
    			attr_dev(input4, "type", "checkbox");
    			add_location(input4, file$s, 285, 12, 9315);
    			attr_dev(label4, "class", "svelte-1r3lg3i");
    			add_location(label4, file$s, 284, 8, 9294);
    			attr_dev(input5, "type", "checkbox");
    			add_location(input5, file$s, 290, 12, 9462);
    			attr_dev(label5, "class", "svelte-1r3lg3i");
    			add_location(label5, file$s, 289, 8, 9441);
    			attr_dev(input6, "type", "checkbox");
    			add_location(input6, file$s, 295, 12, 9594);
    			attr_dev(label6, "class", "svelte-1r3lg3i");
    			add_location(label6, file$s, 294, 8, 9573);
    			attr_dev(input7, "type", "checkbox");
    			add_location(input7, file$s, 300, 12, 9724);
    			attr_dev(label7, "class", "svelte-1r3lg3i");
    			add_location(label7, file$s, 299, 8, 9703);
    			attr_dev(input8, "type", "checkbox");
    			add_location(input8, file$s, 305, 12, 9868);
    			attr_dev(label8, "class", "svelte-1r3lg3i");
    			add_location(label8, file$s, 304, 8, 9847);
    			attr_dev(input9, "type", "checkbox");
    			add_location(input9, file$s, 310, 12, 9989);
    			attr_dev(label9, "class", "svelte-1r3lg3i");
    			add_location(label9, file$s, 309, 8, 9968);
    			attr_dev(input10, "type", "checkbox");
    			add_location(input10, file$s, 315, 12, 10131);
    			attr_dev(label10, "class", "svelte-1r3lg3i");
    			add_location(label10, file$s, 314, 8, 10110);
    			attr_dev(input11, "type", "checkbox");
    			add_location(input11, file$s, 320, 12, 10269);
    			attr_dev(label11, "class", "svelte-1r3lg3i");
    			add_location(label11, file$s, 319, 8, 10248);
    			attr_dev(h41, "class", "svelte-1r3lg3i");
    			add_location(h41, file$s, 324, 8, 10371);
    			attr_dev(input12, "type", "text");
    			add_location(input12, file$s, 328, 12, 10445);
    			attr_dev(label12, "class", "svelte-1r3lg3i");
    			add_location(label12, file$s, 326, 8, 10396);
    			attr_dev(div1, "class", "sidebar svelte-1r3lg3i");
    			add_location(div1, file$s, 259, 4, 8544);
    			attr_dev(div2, "class", "results svelte-1r3lg3i");
    			add_location(div2, file$s, 332, 4, 10527);
    			attr_dev(div3, "class", "container svelte-1r3lg3i");
    			add_location(div3, file$s, 258, 0, 8515);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, h40);
    			append_dev(div1, t6);
    			append_dev(div1, label0);
    			append_dev(label0, input0);
    			input0.checked = /*includeMatches*/ ctx[12];
    			append_dev(label0, t7);
    			append_dev(label0, t8);
    			append_dev(label0, t9);
    			append_dev(div1, t10);
    			append_dev(div1, label1);
    			append_dev(label1, input1);
    			input1.checked = /*includeDuplicates*/ ctx[13];
    			append_dev(label1, t11);
    			append_dev(label1, t12);
    			append_dev(label1, t13);
    			append_dev(div1, t14);
    			append_dev(div1, label2);
    			append_dev(label2, input2);
    			input2.checked = /*includeMissing*/ ctx[14];
    			append_dev(label2, t15);
    			append_dev(label2, t16);
    			append_dev(label2, t17);
    			append_dev(div1, t18);
    			append_dev(div1, label3);
    			append_dev(label3, input3);
    			input3.checked = /*includeRemixes*/ ctx[9];
    			append_dev(label3, t19);
    			append_dev(div1, t20);
    			append_dev(div1, label4);
    			append_dev(label4, input4);
    			input4.checked = /*includeInstrumentals*/ ctx[10];
    			append_dev(label4, t21);
    			append_dev(div1, t22);
    			append_dev(div1, label5);
    			append_dev(label5, input5);
    			input5.checked = /*includeRadioEdits*/ ctx[11];
    			append_dev(label5, t23);
    			append_dev(div1, t24);
    			append_dev(div1, label6);
    			append_dev(label6, input6);
    			input6.checked = /*includeLive*/ ctx[4];
    			append_dev(label6, t25);
    			append_dev(div1, t26);
    			append_dev(div1, label7);
    			append_dev(label7, input7);
    			input7.checked = /*includeShortSongs*/ ctx[7];
    			append_dev(label7, t27);
    			append_dev(div1, t28);
    			append_dev(div1, label8);
    			append_dev(label8, input8);
    			input8.checked = /*includeDemos*/ ctx[8];
    			append_dev(label8, t29);
    			append_dev(div1, t30);
    			append_dev(div1, label9);
    			append_dev(label9, input9);
    			input9.checked = /*includeInterviews*/ ctx[5];
    			append_dev(label9, t31);
    			append_dev(div1, t32);
    			append_dev(div1, label10);
    			append_dev(label10, input10);
    			input10.checked = /*includeZeroTimes*/ ctx[6];
    			append_dev(label10, t33);
    			append_dev(div1, t34);
    			append_dev(div1, label11);
    			append_dev(label11, input11);
    			input11.checked = /*includeVideos*/ ctx[3];
    			append_dev(label11, t35);
    			append_dev(div1, t36);
    			append_dev(div1, h41);
    			append_dev(div1, t38);
    			append_dev(div1, label12);
    			append_dev(label12, t39);
    			append_dev(label12, input12);
    			set_input_value(input12, /*customRegex*/ ctx[15]);
    			append_dev(div3, t40);
    			append_dev(div3, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t41);
    			if_block1.m(div2, null);
    			append_dev(div2, t42);
    			if (if_block2) if_block2.m(div2, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[24]),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[25]),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[26]),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[27]),
    					listen_dev(input4, "change", /*input4_change_handler*/ ctx[28]),
    					listen_dev(input5, "change", /*input5_change_handler*/ ctx[29]),
    					listen_dev(input6, "change", /*input6_change_handler*/ ctx[30]),
    					listen_dev(input7, "change", /*input7_change_handler*/ ctx[31]),
    					listen_dev(input8, "change", /*input8_change_handler*/ ctx[32]),
    					listen_dev(input9, "change", /*input9_change_handler*/ ctx[33]),
    					listen_dev(input10, "change", /*input10_change_handler*/ ctx[34]),
    					listen_dev(input11, "change", /*input11_change_handler*/ ctx[35]),
    					listen_dev(input12, "input", /*input12_input_handler*/ ctx[36])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredRecordings*/ 4 && t1_value !== (t1_value = /*filteredRecordings*/ ctx[2].length + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*allRecordings*/ 1 && t3_value !== (t3_value = /*allRecordings*/ ctx[0].length + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*includeMatches*/ 4096) {
    				input0.checked = /*includeMatches*/ ctx[12];
    			}

    			if (dirty[0] & /*countMatches*/ 262144) set_data_dev(t8, /*countMatches*/ ctx[18]);

    			if (dirty[0] & /*includeDuplicates*/ 8192) {
    				input1.checked = /*includeDuplicates*/ ctx[13];
    			}

    			if (dirty[0] & /*countDuplicates*/ 524288) set_data_dev(t12, /*countDuplicates*/ ctx[19]);

    			if (dirty[0] & /*includeMissing*/ 16384) {
    				input2.checked = /*includeMissing*/ ctx[14];
    			}

    			if (dirty[0] & /*countMissing*/ 1048576) set_data_dev(t16, /*countMissing*/ ctx[20]);

    			if (dirty[0] & /*includeRemixes*/ 512) {
    				input3.checked = /*includeRemixes*/ ctx[9];
    			}

    			if (dirty[0] & /*includeInstrumentals*/ 1024) {
    				input4.checked = /*includeInstrumentals*/ ctx[10];
    			}

    			if (dirty[0] & /*includeRadioEdits*/ 2048) {
    				input5.checked = /*includeRadioEdits*/ ctx[11];
    			}

    			if (dirty[0] & /*includeLive*/ 16) {
    				input6.checked = /*includeLive*/ ctx[4];
    			}

    			if (dirty[0] & /*includeShortSongs*/ 128) {
    				input7.checked = /*includeShortSongs*/ ctx[7];
    			}

    			if (dirty[0] & /*includeDemos*/ 256) {
    				input8.checked = /*includeDemos*/ ctx[8];
    			}

    			if (dirty[0] & /*includeInterviews*/ 32) {
    				input9.checked = /*includeInterviews*/ ctx[5];
    			}

    			if (dirty[0] & /*includeZeroTimes*/ 64) {
    				input10.checked = /*includeZeroTimes*/ ctx[6];
    			}

    			if (dirty[0] & /*includeVideos*/ 8) {
    				input11.checked = /*includeVideos*/ ctx[3];
    			}

    			if (dirty[0] & /*customRegex*/ 32768 && input12.value !== /*customRegex*/ ctx[15]) {
    				set_input_value(input12, /*customRegex*/ ctx[15]);
    			}

    			if (/*loading*/ ctx[16] && /*additionalQueries*/ ctx[17] > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_9$2(ctx);
    					if_block0.c();
    					if_block0.m(div2, t41);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if_block1.p(ctx, dirty);

    			if (!/*loading*/ ctx[16] & /*loadCount*/ ctx[1] > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*loading, loadCount*/ 65538) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$j(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block2);
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $ampleVersion;
    	validate_store(ampleVersion, "ampleVersion");
    	component_subscribe($$self, ampleVersion, $$value => $$invalidate(40, $ampleVersion = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MusicbrainzScan", slots, []);
    	let { data } = $$props;
    	const musicbrainzRegex = new RegExp("[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}");
    	let hasMusicbrainz = musicbrainzRegex.test(data.mbid) && data.name !== "Various Artists";

    	let headers = new Headers({
    			"Accept": "application/json",
    			"Content-Type": "application/json",
    			"User-Agent": `Ample - Ampache client/${$ampleVersion} ( github.com/mitchray/ample )`
    		});

    	let songs = [];
    	let allRecordings = [];
    	let loadCount = 0;
    	let limit = 100;
    	let reportedRecordings = 0;
    	let loading = false;
    	let filteredRecordings = [];
    	let queryURL;
    	let additionalQueries;

    	// filters
    	let includeVideos = false;

    	let includeLive = false;
    	let includeInterviews = false;
    	let includeZeroTimes = false;
    	let includeShortSongs = false;
    	let includeDemos = false;
    	let includeRemixes = false;
    	let includeInstrumentals = false;
    	let includeRadioEdits = false;
    	let includeMatches = true;
    	let includeDuplicates = true;
    	let includeMissing = true;

    	//counts
    	let countMatches;

    	let countDuplicates;
    	let countMissing;
    	let customRegex = "";

    	const mbQuery = async () => {
    		return await fetch(queryURL, { method: "GET", headers }).then(response => response.json()).then(data => {
    			reportedRecordings = data["recording-count"];
    			$$invalidate(0, allRecordings = [...allRecordings, ...data["recordings"]]);
    			$$invalidate(1, loadCount++, loadCount);
    		}).catch(err => {
    			console.log("Error Reading data " + err);
    			return err;
    		});
    	};

    	const throttledMbQuery = dist.throttle(2 * 1000, mbQuery);

    	async function handleGo() {
    		if (!hasMusicbrainz) {
    			return false;
    		}

    		$$invalidate(16, loading = true);

    		// perform first query
    		await throttledMbQuery(queryURL);

    		$$invalidate(17, additionalQueries = Math.ceil((reportedRecordings - limit) / limit));

    		// perform additional queries until done
    		for (let i = 0; i < additionalQueries; i++) {
    			await throttledMbQuery(queryURL);
    		}

    		// grab our artists songs from library
    		songs = await getSongsFromArtist(data.id);

    		// compare recording mbid with our songs
    		for (let i = 0; i < songs.length; i++) {
    			// find perfect MBID matches
    			let perfectMatch = allRecordings.findIndex(function (item) {
    				return item.id === songs[i].mbid;
    			});

    			if (perfectMatch !== -1) {
    				$$invalidate(0, allRecordings[perfectMatch].result = "exact", allRecordings);
    				let similarChars = /(…|\.|,|'|’|"|!|\?)/gi;

    				// mark songs that aren't exact matches but have same name
    				let nameMatch = allRecordings.reduce(
    					function (a, e, j) {
    						if (e.title.toLowerCase().trim().replace(similarChars, "") === allRecordings[perfectMatch].title.toLowerCase().trim().replace(similarChars, "")) {
    							a.push(j);
    						}

    						return a;
    					},
    					[]
    				);

    				for (let j = 0; j < nameMatch.length; j++) {
    					if (allRecordings[nameMatch[j]].result !== "exact") {
    						$$invalidate(0, allRecordings[nameMatch[j]].result = "name", allRecordings);
    					}
    				}
    			}
    		}

    		$$invalidate(16, loading = false);
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<MusicbrainzScan> was created with unknown prop '${key}'`);
    	});

    	function input0_change_handler() {
    		includeMatches = this.checked;
    		$$invalidate(12, includeMatches);
    	}

    	function input1_change_handler() {
    		includeDuplicates = this.checked;
    		$$invalidate(13, includeDuplicates);
    	}

    	function input2_change_handler() {
    		includeMissing = this.checked;
    		$$invalidate(14, includeMissing);
    	}

    	function input3_change_handler() {
    		includeRemixes = this.checked;
    		$$invalidate(9, includeRemixes);
    	}

    	function input4_change_handler() {
    		includeInstrumentals = this.checked;
    		$$invalidate(10, includeInstrumentals);
    	}

    	function input5_change_handler() {
    		includeRadioEdits = this.checked;
    		$$invalidate(11, includeRadioEdits);
    	}

    	function input6_change_handler() {
    		includeLive = this.checked;
    		$$invalidate(4, includeLive);
    	}

    	function input7_change_handler() {
    		includeShortSongs = this.checked;
    		$$invalidate(7, includeShortSongs);
    	}

    	function input8_change_handler() {
    		includeDemos = this.checked;
    		$$invalidate(8, includeDemos);
    	}

    	function input9_change_handler() {
    		includeInterviews = this.checked;
    		$$invalidate(5, includeInterviews);
    	}

    	function input10_change_handler() {
    		includeZeroTimes = this.checked;
    		$$invalidate(6, includeZeroTimes);
    	}

    	function input11_change_handler() {
    		includeVideos = this.checked;
    		$$invalidate(3, includeVideos);
    	}

    	function input12_input_handler() {
    		customRegex = this.value;
    		$$invalidate(15, customRegex);
    	}

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(23, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		throttle: dist.throttle,
    		ampleVersion,
    		getSongsFromArtist,
    		formatTotalTime,
    		data,
    		musicbrainzRegex,
    		hasMusicbrainz,
    		headers,
    		songs,
    		allRecordings,
    		loadCount,
    		limit,
    		reportedRecordings,
    		loading,
    		filteredRecordings,
    		queryURL,
    		additionalQueries,
    		includeVideos,
    		includeLive,
    		includeInterviews,
    		includeZeroTimes,
    		includeShortSongs,
    		includeDemos,
    		includeRemixes,
    		includeInstrumentals,
    		includeRadioEdits,
    		includeMatches,
    		includeDuplicates,
    		includeMissing,
    		countMatches,
    		countDuplicates,
    		countMissing,
    		customRegex,
    		mbQuery,
    		throttledMbQuery,
    		handleGo,
    		$ampleVersion
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(23, data = $$props.data);
    		if ("hasMusicbrainz" in $$props) $$invalidate(21, hasMusicbrainz = $$props.hasMusicbrainz);
    		if ("headers" in $$props) headers = $$props.headers;
    		if ("songs" in $$props) songs = $$props.songs;
    		if ("allRecordings" in $$props) $$invalidate(0, allRecordings = $$props.allRecordings);
    		if ("loadCount" in $$props) $$invalidate(1, loadCount = $$props.loadCount);
    		if ("limit" in $$props) $$invalidate(43, limit = $$props.limit);
    		if ("reportedRecordings" in $$props) reportedRecordings = $$props.reportedRecordings;
    		if ("loading" in $$props) $$invalidate(16, loading = $$props.loading);
    		if ("filteredRecordings" in $$props) $$invalidate(2, filteredRecordings = $$props.filteredRecordings);
    		if ("queryURL" in $$props) queryURL = $$props.queryURL;
    		if ("additionalQueries" in $$props) $$invalidate(17, additionalQueries = $$props.additionalQueries);
    		if ("includeVideos" in $$props) $$invalidate(3, includeVideos = $$props.includeVideos);
    		if ("includeLive" in $$props) $$invalidate(4, includeLive = $$props.includeLive);
    		if ("includeInterviews" in $$props) $$invalidate(5, includeInterviews = $$props.includeInterviews);
    		if ("includeZeroTimes" in $$props) $$invalidate(6, includeZeroTimes = $$props.includeZeroTimes);
    		if ("includeShortSongs" in $$props) $$invalidate(7, includeShortSongs = $$props.includeShortSongs);
    		if ("includeDemos" in $$props) $$invalidate(8, includeDemos = $$props.includeDemos);
    		if ("includeRemixes" in $$props) $$invalidate(9, includeRemixes = $$props.includeRemixes);
    		if ("includeInstrumentals" in $$props) $$invalidate(10, includeInstrumentals = $$props.includeInstrumentals);
    		if ("includeRadioEdits" in $$props) $$invalidate(11, includeRadioEdits = $$props.includeRadioEdits);
    		if ("includeMatches" in $$props) $$invalidate(12, includeMatches = $$props.includeMatches);
    		if ("includeDuplicates" in $$props) $$invalidate(13, includeDuplicates = $$props.includeDuplicates);
    		if ("includeMissing" in $$props) $$invalidate(14, includeMissing = $$props.includeMissing);
    		if ("countMatches" in $$props) $$invalidate(18, countMatches = $$props.countMatches);
    		if ("countDuplicates" in $$props) $$invalidate(19, countDuplicates = $$props.countDuplicates);
    		if ("countMissing" in $$props) $$invalidate(20, countMissing = $$props.countMissing);
    		if ("customRegex" in $$props) $$invalidate(15, customRegex = $$props.customRegex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, loadCount, allRecordings, includeMatches, filteredRecordings, includeDuplicates, includeMissing, includeVideos, includeRemixes, includeLive, includeInstrumentals, includeDemos, includeInterviews, includeZeroTimes, includeShortSongs, includeRadioEdits, customRegex*/ 8454143) {
    			{
    				queryURL = `https://musicbrainz.org/ws/2/recording/?artist=${data.mbid}&limit=${limit}&offset=${loadCount * limit}`;
    				$$invalidate(2, filteredRecordings = allRecordings);

    				// get counts
    				$$invalidate(18, countMatches = allRecordings.reduce(
    					function (n, single) {
    						return n + (single.result === "exact");
    					},
    					0
    				));

    				$$invalidate(19, countDuplicates = allRecordings.reduce(
    					function (n, single) {
    						return n + (single.result === "name");
    					},
    					0
    				));

    				$$invalidate(20, countMissing = allRecordings.reduce(
    					function (n, single) {
    						return n + (single.result === undefined);
    					},
    					0
    				));

    				// do filtering
    				if (!includeMatches) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return item.result !== "exact";
    					}));
    				}

    				if (!includeDuplicates) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return item.result !== "name";
    					}));
    				}

    				if (!includeMissing) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return item.result !== undefined;
    					}));
    				}

    				if (!includeVideos) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return item.video === false;
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/video/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/\(video(\)|\s)/i);
    					}));
    				}

    				if (!includeRemixes) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/remix/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/(re)?mix(,|\)|\]|\s)/i);
    					}));
    				}

    				if (!includeLive) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/live/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/(\[|\()live(,|\]|\)|\s)/i);
    					}));
    				}

    				if (!includeInstrumentals) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/(instrumentals?|a\s?capellas?)/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/\((instrumentals?|acapellas?)(,|\)|\s)/i);
    					}));
    				}

    				if (!includeDemos) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/demo/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/\(demo(,|\)|\s)/i);
    					}));
    				}

    				if (!includeInterviews) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/(interview|commentary)/i);
    					}));
    				}

    				if (!includeZeroTimes) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item["length"] === false;
    					}));
    				}

    				if (!includeShortSongs) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return item["length"] > 60000;
    					}));
    				}

    				if (!includeRadioEdits) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.disambiguation.match(/\(radio edit\)/i);
    					}));

    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(/\(radio edit\)/i);
    					}));
    				}

    				if (customRegex) {
    					$$invalidate(2, filteredRecordings = filteredRecordings.filter(function (item) {
    						return !item.title.match(new RegExp(customRegex, "gi"));
    					}));
    				}

    				// sort alphabetically
    				$$invalidate(2, filteredRecordings = filteredRecordings.sort(function (obj1, obj2) {
    					return obj1.title.localeCompare(obj2.title);
    				}));
    			}
    		}
    	};

    	return [
    		allRecordings,
    		loadCount,
    		filteredRecordings,
    		includeVideos,
    		includeLive,
    		includeInterviews,
    		includeZeroTimes,
    		includeShortSongs,
    		includeDemos,
    		includeRemixes,
    		includeInstrumentals,
    		includeRadioEdits,
    		includeMatches,
    		includeDuplicates,
    		includeMissing,
    		customRegex,
    		loading,
    		additionalQueries,
    		countMatches,
    		countDuplicates,
    		countMissing,
    		hasMusicbrainz,
    		handleGo,
    		data,
    		input0_change_handler,
    		input1_change_handler,
    		input2_change_handler,
    		input3_change_handler,
    		input4_change_handler,
    		input5_change_handler,
    		input6_change_handler,
    		input7_change_handler,
    		input8_change_handler,
    		input9_change_handler,
    		input10_change_handler,
    		input11_change_handler,
    		input12_input_handler
    	];
    }

    class MusicbrainzScan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { data: 23 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MusicbrainzScan",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[23] === undefined && !("data" in props)) {
    			console_1.warn("<MusicbrainzScan> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<MusicbrainzScan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<MusicbrainzScan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\text.svg generated by Svelte v3.38.3 */

    function create_fragment$y(ctx) {
    	let svg;
    	let g;
    	let rect;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			rect = svg_element("rect");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g = claim_element(svg_nodes, "g", {}, 1);
    			var g_nodes = children(g);
    			rect = claim_element(g_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			path = claim_element(g_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			g_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M14.17,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V9.83c0-0.53-0.21-1.04-0.59-1.41l-4.83-4.83 C15.21,3.21,14.7,3,14.17,3L14.17,3z M8,15h8c0.55,0,1,0.45,1,1v0c0,0.55-0.45,1-1,1H8c-0.55,0-1-0.45-1-1v0C7,15.45,7.45,15,8,15z M8,11h8c0.55,0,1,0.45,1,1v0c0,0.55-0.45,1-1,1H8c-0.55,0-1-0.45-1-1v0C7,11.45,7.45,11,8,11z M8,7h5c0.55,0,1,0.45,1,1v0 c0,0.55-0.45,1-1,1H8C7.45,9,7,8.55,7,8v0C7,7.45,7.45,7,8,7z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g);
    			append(g, rect);
    			append(g, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$y($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Text extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});
    	}
    }

    /* public\images\search.svg generated by Svelte v3.38.3 */

    function create_fragment$x(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$x($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Search extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});
    	}
    }

    /* src\components\thirdPartyServices.svelte generated by Svelte v3.38.3 */
    const file$r = "src\\components\\thirdPartyServices.svelte";

    // (55:4) {#if type === 'artist'}
    function create_if_block_4$5(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "data" && create_if_block_7$3(ctx);
    	let if_block1 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "search" && create_if_block_6$4(ctx);
    	let if_block2 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "provider" && create_if_block_5$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "data") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "search") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "provider") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_5$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(55:4) {#if type === 'artist'}",
    		ctx
    	});

    	return block;
    }

    // (56:8) {#if isVisible && menuType === 'data'}
    function create_if_block_7$3(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[9](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-data"),
    		$$slots: { default: [create_default_slot_5] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(56:8) {#if isVisible && menuType === 'data'}",
    		ctx
    	});

    	return block;
    }

    // (57:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-data')} bind:isVisible={isVisible}>
    function create_default_slot_5(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Discogs");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Last.fm");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("MusicBrainz");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://www.discogs.com/search/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"&type=artist`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 59, 24, 1611);
    			add_location(li0, file$r, 58, 20, 1581);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://www.last.fm/search/artists?q=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 64, 24, 1866);
    			add_location(li1, file$r, 63, 20, 1836);
    			attr_dev(a2, "target", "_blank");

    			attr_dev(a2, "href", a2_href_value = /*hasMusicbrainz*/ ctx[4]
    			? `https://musicbrainz.org/artist/${/*data*/ ctx[0].mbid}`
    			: `https://musicbrainz.org/search?query=${encodeURIComponent(/*data*/ ctx[0].name)}&type=artist&method=indexed`);

    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 69, 24, 2110);
    			add_location(li2, file$r, 68, 20, 2080);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 57, 16, 1537);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://www.discogs.com/search/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"&type=artist`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://www.last.fm/search/artists?q=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = /*hasMusicbrainz*/ ctx[4]
    			? `https://musicbrainz.org/artist/${/*data*/ ctx[0].mbid}`
    			: `https://musicbrainz.org/search?query=${encodeURIComponent(/*data*/ ctx[0].name)}&type=artist&method=indexed`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(57:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-data')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    // (80:8) {#if isVisible && menuType === 'search'}
    function create_if_block_6$4(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_1(value) {
    		/*menu_isVisible_binding_1*/ ctx[10](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-search"),
    		$$slots: { default: [create_default_slot_4] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_1));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(80:8) {#if isVisible && menuType === 'search'}",
    		ctx
    	});

    	return block;
    }

    // (81:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-search')} bind:isVisible={isVisible}>
    function create_default_slot_4(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Duck Duck Go");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Google");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("Wikipedia");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://www.duckduckgo.com/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 83, 24, 2785);
    			add_location(li0, file$r, 82, 20, 2755);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://www.google.com/search?q="${encodeURIComponent(/*data*/ ctx[0].name)}"`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 88, 24, 3029);
    			add_location(li1, file$r, 87, 20, 2999);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", a2_href_value = `https://en.wikipedia.org/wiki/Special:Search?search="${encodeURIComponent(/*data*/ ctx[0].name)}"&go=Go`);
    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 93, 24, 3269);
    			add_location(li2, file$r, 92, 20, 3239);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 81, 16, 2711);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://www.duckduckgo.com/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://www.google.com/search?q="${encodeURIComponent(/*data*/ ctx[0].name)}"`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = `https://en.wikipedia.org/wiki/Special:Search?search="${encodeURIComponent(/*data*/ ctx[0].name)}"&go=Go`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(81:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-search')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    // (102:8) {#if isVisible && menuType === 'provider'}
    function create_if_block_5$4(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_2(value) {
    		/*menu_isVisible_binding_2*/ ctx[11](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-provider"),
    		$$slots: { default: [create_default_slot_3$3] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_2));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(102:8) {#if isVisible && menuType === 'provider'}",
    		ctx
    	});

    	return block;
    }

    // (103:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-provider')} bind:isVisible={isVisible}>
    function create_default_slot_3$3(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;
    	let t5;
    	let li3;
    	let a3;
    	let t6;
    	let a3_href_value;
    	let t7;
    	let li4;
    	let a4;
    	let t8;
    	let a4_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Apple Music");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Bandcamp");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("Deezer");
    			t5 = space();
    			li3 = element("li");
    			a3 = element("a");
    			t6 = text("Spotify");
    			t7 = space();
    			li4 = element("li");
    			a4 = element("a");
    			t8 = text("YouTube Music");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://music.apple.com/search?term=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 105, 24, 3822);
    			add_location(li0, file$r, 104, 20, 3792);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://bandcamp.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 110, 24, 4069);
    			add_location(li1, file$r, 109, 20, 4039);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", a2_href_value = `https://www.deezer.com/search/"${encodeURIComponent(/*data*/ ctx[0].name)}"/artist`);
    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 115, 24, 4307);
    			add_location(li2, file$r, 114, 20, 4277);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", a3_href_value = `https://open.spotify.com/search/artist:"${encodeURIComponent(/*data*/ ctx[0].name)}"`);
    			attr_dev(a3, "class", "svelte-8pwljk");
    			add_location(a3, file$r, 120, 24, 4552);
    			add_location(li3, file$r, 119, 20, 4522);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "href", a4_href_value = `https://music.youtube.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a4, "class", "svelte-8pwljk");
    			add_location(a4, file$r, 125, 24, 4800);
    			add_location(li4, file$r, 124, 20, 4770);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 103, 16, 3748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(a3, t6);
    			append_dev(ul, t7);
    			append_dev(ul, li4);
    			append_dev(li4, a4);
    			append_dev(a4, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://music.apple.com/search?term=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://bandcamp.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = `https://www.deezer.com/search/"${encodeURIComponent(/*data*/ ctx[0].name)}"/artist`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}

    			if (dirty & /*data*/ 1 && a3_href_value !== (a3_href_value = `https://open.spotify.com/search/artist:"${encodeURIComponent(/*data*/ ctx[0].name)}"`)) {
    				attr_dev(a3, "href", a3_href_value);
    			}

    			if (dirty & /*data*/ 1 && a4_href_value !== (a4_href_value = `https://music.youtube.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a4, "href", a4_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(103:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-provider')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    // (135:4) {#if type === 'album'}
    function create_if_block$i(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "data" && create_if_block_3$6(ctx);
    	let if_block1 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "search" && create_if_block_2$c(ctx);
    	let if_block2 = /*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "provider" && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "data") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "search") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$c(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*isVisible*/ ctx[2] && /*menuType*/ ctx[3] === "provider") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isVisible, menuType*/ 12) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$d(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(135:4) {#if type === 'album'}",
    		ctx
    	});

    	return block;
    }

    // (136:8) {#if isVisible && menuType === 'data'}
    function create_if_block_3$6(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_3(value) {
    		/*menu_isVisible_binding_3*/ ctx[12](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-data"),
    		$$slots: { default: [create_default_slot_2$4] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_3));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(136:8) {#if isVisible && menuType === 'data'}",
    		ctx
    	});

    	return block;
    }

    // (137:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-data')} bind:isVisible={isVisible}>
    function create_default_slot_2$4(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Discogs");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Last.fm");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("MusicBrainz");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://www.discogs.com/search/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"+"${encodeURIComponent(/*data*/ ctx[0].artist.name)}"&type=release`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 139, 24, 5363);
    			add_location(li0, file$r, 138, 20, 5333);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://www.last.fm/search/albums?q=${encodeURIComponent(/*data*/ ctx[0].name)}+${encodeURIComponent(/*data*/ ctx[0].artist.name)}`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 144, 24, 5661);
    			add_location(li1, file$r, 143, 20, 5631);
    			attr_dev(a2, "target", "_blank");

    			attr_dev(a2, "href", a2_href_value = /*hasMusicbrainz*/ ctx[4]
    			? `https://musicbrainz.org/release/${/*data*/ ctx[0].mbid}`
    			: `https://musicbrainz.org/search?query=${encodeURIComponent(/*data*/ ctx[0].name)}&type=release&method=indexed`);

    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 149, 24, 5944);
    			add_location(li2, file$r, 148, 20, 5914);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 137, 16, 5289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://www.discogs.com/search/?q="${encodeURIComponent(/*data*/ ctx[0].name)}"+"${encodeURIComponent(/*data*/ ctx[0].artist.name)}"&type=release`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://www.last.fm/search/albums?q=${encodeURIComponent(/*data*/ ctx[0].name)}+${encodeURIComponent(/*data*/ ctx[0].artist.name)}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = /*hasMusicbrainz*/ ctx[4]
    			? `https://musicbrainz.org/release/${/*data*/ ctx[0].mbid}`
    			: `https://musicbrainz.org/search?query=${encodeURIComponent(/*data*/ ctx[0].name)}&type=release&method=indexed`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(137:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-data')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    // (160:8) {#if isVisible && menuType === 'search'}
    function create_if_block_2$c(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_4(value) {
    		/*menu_isVisible_binding_4*/ ctx[13](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-search"),
    		$$slots: { default: [create_default_slot_1$7] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_4));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(160:8) {#if isVisible && menuType === 'search'}",
    		ctx
    	});

    	return block;
    }

    // (161:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-search')} bind:isVisible={isVisible}>
    function create_default_slot_1$7(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Duck Duck Go");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Google");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("Wikipedia");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://www.duckduckgo.com/?q="${encodeURIComponent(/*data*/ ctx[0].artist.name)}"+"${encodeURIComponent(/*data*/ ctx[0].name)}"`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 163, 24, 6621);
    			add_location(li0, file$r, 162, 20, 6591);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://www.google.com/search?q="${encodeURIComponent(/*data*/ ctx[0].artist.name)}"+"${encodeURIComponent(/*data*/ ctx[0].name)}"`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 168, 24, 6907);
    			add_location(li1, file$r, 167, 20, 6877);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", a2_href_value = `https://en.wikipedia.org/wiki/Special:Search?search="${encodeURIComponent(/*data*/ ctx[0].name)}"&go=Go`);
    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 173, 24, 7189);
    			add_location(li2, file$r, 172, 20, 7159);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 161, 16, 6547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://www.duckduckgo.com/?q="${encodeURIComponent(/*data*/ ctx[0].artist.name)}"+"${encodeURIComponent(/*data*/ ctx[0].name)}"`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://www.google.com/search?q="${encodeURIComponent(/*data*/ ctx[0].artist.name)}"+"${encodeURIComponent(/*data*/ ctx[0].name)}"`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = `https://en.wikipedia.org/wiki/Special:Search?search="${encodeURIComponent(/*data*/ ctx[0].name)}"&go=Go`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(161:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-search')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    // (182:8) {#if isVisible && menuType === 'provider'}
    function create_if_block_1$d(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_5(value) {
    		/*menu_isVisible_binding_5*/ ctx[14](value);
    	}

    	let menu_props = {
    		anchor: "bottom-left",
    		toggleElement: document.querySelector("#thirdParty-provider"),
    		$$slots: { default: [create_default_slot$e] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_5));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, data*/ 65537) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(182:8) {#if isVisible && menuType === 'provider'}",
    		ctx
    	});

    	return block;
    }

    // (183:12) <Menu anchor="bottom-left" toggleElement={document.querySelector('#thirdParty-provider')} bind:isVisible={isVisible}>
    function create_default_slot$e(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t0;
    	let a0_href_value;
    	let t1;
    	let li1;
    	let a1;
    	let t2;
    	let a1_href_value;
    	let t3;
    	let li2;
    	let a2;
    	let t4;
    	let a2_href_value;
    	let t5;
    	let li3;
    	let a3;
    	let t6;
    	let a3_href_value;
    	let t7;
    	let li4;
    	let a4;
    	let t8;
    	let a4_href_value;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t0 = text("Apple Music");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t2 = text("Bandcamp");
    			t3 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t4 = text("Deezer");
    			t5 = space();
    			li3 = element("li");
    			a3 = element("a");
    			t6 = text("Spotify");
    			t7 = space();
    			li4 = element("li");
    			a4 = element("a");
    			t8 = text("YouTube Music");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", a0_href_value = `https://music.apple.com/search?term=${encodeURIComponent(/*data*/ ctx[0].name)} ${encodeURIComponent(/*data*/ ctx[0].artist.name)}`);
    			attr_dev(a0, "class", "svelte-8pwljk");
    			add_location(a0, file$r, 185, 24, 7742);
    			add_location(li0, file$r, 184, 20, 7712);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", a1_href_value = `https://bandcamp.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a1, "class", "svelte-8pwljk");
    			add_location(a1, file$r, 190, 24, 8029);
    			add_location(li1, file$r, 189, 20, 7999);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", a2_href_value = `https://www.deezer.com/search/"${encodeURIComponent(/*data*/ ctx[0].name)}" "${encodeURIComponent(/*data*/ ctx[0].artist.name)}"/album`);
    			attr_dev(a2, "class", "svelte-8pwljk");
    			add_location(a2, file$r, 195, 24, 8267);
    			add_location(li2, file$r, 194, 20, 8237);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", a3_href_value = `https://open.spotify.com/search/album:"${encodeURIComponent(/*data*/ ctx[0].name)}" artist:"${encodeURIComponent(/*data*/ ctx[0].artist.name)}"`);
    			attr_dev(a3, "class", "svelte-8pwljk");
    			add_location(a3, file$r, 200, 24, 8553);
    			add_location(li3, file$r, 199, 20, 8523);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "href", a4_href_value = `https://music.youtube.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`);
    			attr_dev(a4, "class", "svelte-8pwljk");
    			add_location(a4, file$r, 205, 24, 8849);
    			add_location(li4, file$r, 204, 20, 8819);
    			attr_dev(ul, "class", "menu-list svelte-8pwljk");
    			add_location(ul, file$r, 183, 16, 7668);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(a3, t6);
    			append_dev(ul, t7);
    			append_dev(ul, li4);
    			append_dev(li4, a4);
    			append_dev(a4, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && a0_href_value !== (a0_href_value = `https://music.apple.com/search?term=${encodeURIComponent(/*data*/ ctx[0].name)} ${encodeURIComponent(/*data*/ ctx[0].artist.name)}`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*data*/ 1 && a1_href_value !== (a1_href_value = `https://bandcamp.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*data*/ 1 && a2_href_value !== (a2_href_value = `https://www.deezer.com/search/"${encodeURIComponent(/*data*/ ctx[0].name)}" "${encodeURIComponent(/*data*/ ctx[0].artist.name)}"/album`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}

    			if (dirty & /*data*/ 1 && a3_href_value !== (a3_href_value = `https://open.spotify.com/search/album:"${encodeURIComponent(/*data*/ ctx[0].name)}" artist:"${encodeURIComponent(/*data*/ ctx[0].artist.name)}"`)) {
    				attr_dev(a3, "href", a3_href_value);
    			}

    			if (dirty & /*data*/ 1 && a4_href_value !== (a4_href_value = `https://music.youtube.com/search?q=${encodeURIComponent(/*data*/ ctx[0].name)}`)) {
    				attr_dev(a4, "href", a4_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(183:12) <Menu anchor=\\\"bottom-left\\\" toggleElement={document.querySelector('#thirdParty-provider')} bind:isVisible={isVisible}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div;
    	let button0;
    	let svgdata;
    	let t0;
    	let button1;
    	let svgsearch;
    	let t1;
    	let button2;
    	let svgmusic;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	svgdata = new Text({
    			props: { style: "padding: 0.15em;" },
    			$$inline: true
    		});

    	svgsearch = new Search({ $$inline: true });
    	svgmusic = new Music_note({ $$inline: true });
    	let if_block0 = /*type*/ ctx[1] === "artist" && create_if_block_4$5(ctx);
    	let if_block1 = /*type*/ ctx[1] === "album" && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			create_component(svgdata.$$.fragment);
    			t0 = space();
    			button1 = element("button");
    			create_component(svgsearch.$$.fragment);
    			t1 = space();
    			button2 = element("button");
    			create_component(svgmusic.$$.fragment);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "id", "thirdParty-data");
    			attr_dev(button0, "class", "just-icon svelte-8pwljk");
    			attr_dev(button0, "title", "Data");
    			add_location(button0, file$r, 24, 4, 653);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "id", "thirdParty-search");
    			attr_dev(button1, "class", "just-icon svelte-8pwljk");
    			attr_dev(button1, "title", "Search");
    			add_location(button1, file$r, 34, 4, 885);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "id", "thirdParty-provider");
    			attr_dev(button2, "class", "just-icon svelte-8pwljk");
    			attr_dev(button2, "title", "Providers");
    			add_location(button2, file$r, 44, 4, 1100);
    			attr_dev(div, "class", "container svelte-8pwljk");
    			add_location(div, file$r, 23, 0, 624);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			mount_component(svgdata, button0, null);
    			append_dev(div, t0);
    			append_dev(div, button1);
    			mount_component(svgsearch, button1, null);
    			append_dev(div, t1);
    			append_dev(div, button2);
    			mount_component(svgmusic, button2, null);
    			append_dev(div, t2);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[7], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*type*/ ctx[1] === "artist") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t3);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$i(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgdata.$$.fragment, local);
    			transition_in(svgsearch.$$.fragment, local);
    			transition_in(svgmusic.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgdata.$$.fragment, local);
    			transition_out(svgsearch.$$.fragment, local);
    			transition_out(svgmusic.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(svgdata);
    			destroy_component(svgsearch);
    			destroy_component(svgmusic);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ThirdPartyServices", slots, []);
    	let { data } = $$props;
    	let { type } = $$props;
    	const musicbrainzRegex = new RegExp("[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}");
    	let hasMusicbrainz = musicbrainzRegex.test(data.mbid);
    	let isVisible = false;
    	let menuType;

    	function toggleMenu(type) {
    		$$invalidate(3, menuType = type);
    		$$invalidate(2, isVisible = !isVisible);
    	}

    	const writable_props = ["data", "type"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ThirdPartyServices> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		toggleMenu("data");
    	};

    	const click_handler_1 = () => {
    		toggleMenu("search");
    	};

    	const click_handler_2 = () => {
    		toggleMenu("provider");
    	};

    	function menu_isVisible_binding(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	function menu_isVisible_binding_1(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	function menu_isVisible_binding_2(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	function menu_isVisible_binding_3(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	function menu_isVisible_binding_4(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	function menu_isVisible_binding_5(value) {
    		isVisible = value;
    		$$invalidate(2, isVisible);
    	}

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    	};

    	$$self.$capture_state = () => ({
    		SVGData: Text,
    		SVGSearch: Search,
    		SVGMusic: Music_note,
    		Menu,
    		data,
    		type,
    		musicbrainzRegex,
    		hasMusicbrainz,
    		isVisible,
    		menuType,
    		toggleMenu
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("hasMusicbrainz" in $$props) $$invalidate(4, hasMusicbrainz = $$props.hasMusicbrainz);
    		if ("isVisible" in $$props) $$invalidate(2, isVisible = $$props.isVisible);
    		if ("menuType" in $$props) $$invalidate(3, menuType = $$props.menuType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		type,
    		isVisible,
    		menuType,
    		hasMusicbrainz,
    		toggleMenu,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		menu_isVisible_binding,
    		menu_isVisible_binding_1,
    		menu_isVisible_binding_2,
    		menu_isVisible_binding_3,
    		menu_isVisible_binding_4,
    		menu_isVisible_binding_5
    	];
    }

    class ThirdPartyServices extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { data: 0, type: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ThirdPartyServices",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<ThirdPartyServices> was created without expected prop 'data'");
    		}

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<ThirdPartyServices> was created without expected prop 'type'");
    		}
    	}

    	get data() {
    		throw new Error("<ThirdPartyServices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ThirdPartyServices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ThirdPartyServices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ThirdPartyServices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* public\images\songs.svg generated by Svelte v3.38.3 */

    function create_fragment$v(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path, "d", "M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-3 5h-2v5.37c0 1.27-.9 2.44-2.16 2.6-1.69.23-3.11-1.25-2.8-2.95.2-1.1 1.18-1.95 2.3-2.02.63-.04 1.2.16 1.66.51V6c0-.55.45-1 1-1h2c.55 0 1 .45 1 1s-.45 1-1 1zM3 6c-.55 0-1 .45-1 1v13c0 1.1.9 2 2 2h13c.55 0 1-.45 1-1s-.45-1-1-1H5c-.55 0-1-.45-1-1V7c0-.55-.45-1-1-1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$v($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Songs extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});
    	}
    }

    /* public\images\people.svg generated by Svelte v3.38.3 */

    function create_fragment$u(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let rect1;
    	let g7;
    	let g1;
    	let g6;
    	let g2;
    	let path0;
    	let g3;
    	let circle;
    	let g4;
    	let path1;
    	let g5;
    	let path2;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			g7 = svg_element("g");
    			g1 = svg_element("g");
    			g6 = svg_element("g");
    			g2 = svg_element("g");
    			path0 = svg_element("path");
    			g3 = svg_element("g");
    			circle = svg_element("circle");
    			g4 = svg_element("g");
    			path1 = svg_element("path");
    			g5 = svg_element("g");
    			path2 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			rect0 = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect0).forEach(detach);
    			rect1 = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect1).forEach(detach);
    			g0_nodes.forEach(detach);
    			g7 = claim_element(svg_nodes, "g", {}, 1);
    			var g7_nodes = children(g7);
    			g1 = claim_element(g7_nodes, "g", {}, 1);
    			children(g1).forEach(detach);
    			g6 = claim_element(g7_nodes, "g", {}, 1);
    			var g6_nodes = children(g6);
    			g2 = claim_element(g6_nodes, "g", {}, 1);
    			var g2_nodes = children(g2);
    			path0 = claim_element(g2_nodes, "path", { d: true, "fill-rule": true }, 1);
    			children(path0).forEach(detach);
    			g2_nodes.forEach(detach);
    			g3 = claim_element(g6_nodes, "g", {}, 1);
    			var g3_nodes = children(g3);

    			circle = claim_element(
    				g3_nodes,
    				"circle",
    				{
    					cx: true,
    					cy: true,
    					"fill-rule": true,
    					r: true
    				},
    				1
    			);

    			children(circle).forEach(detach);
    			g3_nodes.forEach(detach);
    			g4 = claim_element(g6_nodes, "g", {}, 1);
    			var g4_nodes = children(g4);
    			path1 = claim_element(g4_nodes, "path", { d: true, "fill-rule": true }, 1);
    			children(path1).forEach(detach);
    			g4_nodes.forEach(detach);
    			g5 = claim_element(g6_nodes, "g", {}, 1);
    			var g5_nodes = children(g5);
    			path2 = claim_element(g5_nodes, "path", { d: true, "fill-rule": true }, 1);
    			children(path2).forEach(detach);
    			g5_nodes.forEach(detach);
    			g6_nodes.forEach(detach);
    			g7_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect0, "fill", "none");
    			attr(rect0, "height", "24");
    			attr(rect0, "width", "24");
    			attr(rect1, "fill", "none");
    			attr(rect1, "height", "24");
    			attr(rect1, "width", "24");
    			attr(path0, "d", "M16.67,13.13C18.04,14.06,19,15.32,19,17v3h3c0.55,0,1-0.45,1-1v-2 C23,14.82,19.43,13.53,16.67,13.13z");
    			attr(path0, "fill-rule", "evenodd");
    			attr(circle, "cx", "9");
    			attr(circle, "cy", "8");
    			attr(circle, "fill-rule", "evenodd");
    			attr(circle, "r", "4");
    			attr(path1, "d", "M15,12c2.21,0,4-1.79,4-4c0-2.21-1.79-4-4-4c-0.47,0-0.91,0.1-1.33,0.24 C14.5,5.27,15,6.58,15,8s-0.5,2.73-1.33,3.76C14.09,11.9,14.53,12,15,12z");
    			attr(path1, "fill-rule", "evenodd");
    			attr(path2, "d", "M9,13c-2.67,0-8,1.34-8,4v2c0,0.55,0.45,1,1,1h14c0.55,0,1-0.45,1-1v-2 C17,14.34,11.67,13,9,13z");
    			attr(path2, "fill-rule", "evenodd");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, rect0);
    			append(g0, rect1);
    			append(svg, g7);
    			append(g7, g1);
    			append(g7, g6);
    			append(g6, g2);
    			append(g2, path0);
    			append(g6, g3);
    			append(g3, circle);
    			append(g6, g4);
    			append(g4, path1);
    			append(g6, g5);
    			append(g5, path2);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$u($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class People extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});
    	}
    }

    /* public\images\article.svg generated by Svelte v3.38.3 */

    function create_fragment$t(ctx) {
    	let svg;
    	let g;
    	let rect;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			rect = svg_element("rect");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g = claim_element(svg_nodes, "g", {}, 1);
    			var g_nodes = children(g);
    			rect = claim_element(g_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			path = claim_element(g_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			g_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M13,17H8c-0.55,0-1-0.45-1-1 c0-0.55,0.45-1,1-1h5c0.55,0,1,0.45,1,1C14,16.55,13.55,17,13,17z M16,13H8c-0.55,0-1-0.45-1-1c0-0.55,0.45-1,1-1h8 c0.55,0,1,0.45,1,1C17,12.55,16.55,13,16,13z M16,9H8C7.45,9,7,8.55,7,8c0-0.55,0.45-1,1-1h8c0.55,0,1,0.45,1,1 C17,8.55,16.55,9,16,9z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g);
    			append(g, rect);
    			append(g, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$t($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Article extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});
    	}
    }

    /* src\views\artist.svelte generated by Svelte v3.38.3 */
    const file$q = "src\\views\\artist.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (169:0) {:catch error}
    function create_catch_block_2$2(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*error*/ ctx[12].message + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Something went wrong: ");
    			t1 = text(t1_value);
    			add_location(p, file$q, 169, 4, 6964);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && t1_value !== (t1_value = /*error*/ ctx[12].message + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_2$2.name,
    		type: "catch",
    		source: "(169:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {:then artist}
    function create_then_block$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*artist*/ ctx[8].id) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$4.name,
    		type: "then",
    		source: "(53:0) {:then artist}",
    		ctx
    	});

    	return block;
    }

    // (166:4) {:else}
    function create_else_block_4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find artist with that ID";
    			add_location(p, file$q, 166, 8, 6890);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(166:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:4) {#if artist.id}
    function create_if_block$h(ctx) {
    	let t0;
    	let div2;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_intro;
    	let t1;
    	let div1;
    	let h1;
    	let t2_value = /*artist*/ ctx[8].name + "";
    	let t2;
    	let t3;
    	let p;
    	let t4;
    	let t5;
    	let t6_value = /*artist*/ ctx[8].songcount + "";
    	let t6;
    	let t7;
    	let t8_value = (/*artist*/ ctx[8].songcount !== 1 ? "songs" : "song") + "";
    	let t8;
    	let t9;
    	let t10_value = formatTimeToReadable(/*artist*/ ctx[8].time) + "";
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let div0;
    	let rating;
    	let t14;
    	let thirdpartyservices;
    	let t15;
    	let actions;
    	let t16;
    	let tabs;
    	let updating_activeTabValue;
    	let current;
    	let if_block0 = /*artist*/ ctx[8].useBackground && !/*$ThemeIsLight*/ ctx[1] && create_if_block_9$1(ctx);
    	let if_block1 = /*artist*/ ctx[8].albumcount > 0 && create_if_block_8$1(ctx);
    	let if_block2 = /*artist*/ ctx[8].appearanceCount > 0 && create_if_block_7$2(ctx);
    	let if_block3 = /*artist*/ ctx[8].genre.length > 0 && create_if_block_6$3(ctx);

    	rating = new Rating({
    			props: {
    				type: "artist",
    				id: /*artist*/ ctx[8].id,
    				rating: /*artist*/ ctx[8].rating,
    				flag: /*artist*/ ctx[8].flag,
    				averageRating: /*artist*/ ctx[8].averagerating
    			},
    			$$inline: true
    		});

    	thirdpartyservices = new ThirdPartyServices({
    			props: { data: /*artist*/ ctx[8], type: "artist" },
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				type: "artist",
    				mode: "fullButtons",
    				id: /*artist*/ ctx[8].id,
    				count: /*artist*/ ctx[8].songcount
    			},
    			$$inline: true
    		});

    	function tabs_activeTabValue_binding(value) {
    		/*tabs_activeTabValue_binding*/ ctx[6](value);
    	}

    	let tabs_props = {
    		items: /*tabItems*/ ctx[4],
    		$$slots: { default: [create_default_slot$d] },
    		$$scope: { ctx }
    	};

    	if (/*currentTab*/ ctx[2] !== void 0) {
    		tabs_props.activeTabValue = /*currentTab*/ ctx[2];
    	}

    	tabs = new Tabs({ props: tabs_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabs, "activeTabValue", tabs_activeTabValue_binding));

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div2 = element("div");
    			img = element("img");
    			t1 = space();
    			div1 = element("div");
    			h1 = element("h1");
    			t2 = text(t2_value);
    			t3 = space();
    			p = element("p");
    			if (if_block1) if_block1.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = text(" •\r\n                    ");
    			t10 = text(t10_value);
    			t11 = text(" total");
    			t12 = space();
    			if (if_block3) if_block3.c();
    			t13 = space();
    			div0 = element("div");
    			create_component(rating.$$.fragment);
    			t14 = space();
    			create_component(thirdpartyservices.$$.fragment);
    			t15 = space();
    			create_component(actions.$$.fragment);
    			t16 = space();
    			create_component(tabs.$$.fragment);
    			attr_dev(img, "class", "art svelte-d9sz19");
    			if (img.src !== (img_src_value = "" + (/*artist*/ ctx[8].art + "&thumb=32"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*artist*/ ctx[8].name);
    			attr_dev(img, "width", "210");
    			attr_dev(img, "height", "210");
    			add_location(img, file$q, 59, 12, 2425);
    			attr_dev(h1, "class", "title svelte-d9sz19");
    			add_location(h1, file$q, 61, 16, 2586);
    			add_location(p, file$q, 62, 16, 2640);
    			attr_dev(div0, "class", "inline svelte-d9sz19");
    			add_location(div0, file$q, 83, 16, 3619);
    			attr_dev(div1, "class", "details svelte-d9sz19");
    			add_location(div1, file$q, 60, 12, 2547);
    			attr_dev(div2, "class", "container svelte-d9sz19");
    			add_location(div2, file$q, 58, 8, 2388);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, img);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, h1);
    			append_dev(h1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, p);
    			if (if_block1) if_block1.m(p, null);
    			append_dev(p, t4);
    			if (if_block2) if_block2.m(p, null);
    			append_dev(p, t5);
    			append_dev(p, t6);
    			append_dev(p, t7);
    			append_dev(p, t8);
    			append_dev(p, t9);
    			append_dev(p, t10);
    			append_dev(p, t11);
    			append_dev(div1, t12);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t13);
    			append_dev(div1, div0);
    			mount_component(rating, div0, null);
    			append_dev(div0, t14);
    			mount_component(thirdpartyservices, div0, null);
    			append_dev(div1, t15);
    			mount_component(actions, div1, null);
    			insert_dev(target, t16, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*artist*/ ctx[8].useBackground && !/*$ThemeIsLight*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*id, $ThemeIsLight*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_9$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*id*/ 1 && img.src !== (img_src_value = "" + (/*artist*/ ctx[8].art + "&thumb=32"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*id*/ 1 && img_alt_value !== (img_alt_value = "Image of " + /*artist*/ ctx[8].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if ((!current || dirty & /*id*/ 1) && t2_value !== (t2_value = /*artist*/ ctx[8].name + "")) set_data_dev(t2, t2_value);

    			if (/*artist*/ ctx[8].albumcount > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*id*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_8$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(p, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*artist*/ ctx[8].appearanceCount > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*id*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_7$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(p, t5);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*id*/ 1) && t6_value !== (t6_value = /*artist*/ ctx[8].songcount + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*id*/ 1) && t8_value !== (t8_value = (/*artist*/ ctx[8].songcount !== 1 ? "songs" : "song") + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*id*/ 1) && t10_value !== (t10_value = formatTimeToReadable(/*artist*/ ctx[8].time) + "")) set_data_dev(t10, t10_value);

    			if (/*artist*/ ctx[8].genre.length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*id*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_6$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t13);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			const rating_changes = {};
    			if (dirty & /*id*/ 1) rating_changes.id = /*artist*/ ctx[8].id;
    			if (dirty & /*id*/ 1) rating_changes.rating = /*artist*/ ctx[8].rating;
    			if (dirty & /*id*/ 1) rating_changes.flag = /*artist*/ ctx[8].flag;
    			if (dirty & /*id*/ 1) rating_changes.averageRating = /*artist*/ ctx[8].averagerating;
    			rating.$set(rating_changes);
    			const thirdpartyservices_changes = {};
    			if (dirty & /*id*/ 1) thirdpartyservices_changes.data = /*artist*/ ctx[8];
    			thirdpartyservices.$set(thirdpartyservices_changes);
    			const actions_changes = {};
    			if (dirty & /*id*/ 1) actions_changes.id = /*artist*/ ctx[8].id;
    			if (dirty & /*id*/ 1) actions_changes.count = /*artist*/ ctx[8].songcount;
    			actions.$set(actions_changes);
    			const tabs_changes = {};

    			if (dirty & /*$$scope, currentTab, id, $ShowExpandedAlbums*/ 131085) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeTabValue && dirty & /*currentTab*/ 4) {
    				updating_activeTabValue = true;
    				tabs_changes.activeTabValue = /*currentTab*/ ctx[2];
    				add_flush_callback(() => updating_activeTabValue = false);
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);

    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, fade, {});
    					img_intro.start();
    				});
    			}

    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(rating.$$.fragment, local);
    			transition_in(thirdpartyservices.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(rating.$$.fragment, local);
    			transition_out(thirdpartyservices.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(rating);
    			destroy_component(thirdpartyservices);
    			destroy_component(actions);
    			if (detaching) detach_dev(t16);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(54:4) {#if artist.id}",
    		ctx
    	});

    	return block;
    }

    // (55:8) {#if artist.useBackground && !$ThemeIsLight}
    function create_if_block_9$1(ctx) {
    	let img;
    	let img_src_value;
    	let img_intro;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "art-background");
    			if (img.src !== (img_src_value = "" + (/*artist*/ ctx[8].art + "&thumb=10"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "loading", "lazy");
    			add_location(img, file$q, 55, 12, 2274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && img.src !== (img_src_value = "" + (/*artist*/ ctx[8].art + "&thumb=10"))) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		i: function intro(local) {
    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, fade, {});
    					img_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(55:8) {#if artist.useBackground && !$ThemeIsLight}",
    		ctx
    	});

    	return block;
    }

    // (64:20) {#if artist.albumcount > 0}
    function create_if_block_8$1(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*artist*/ ctx[8].albumcount + "";
    	let t1;
    	let t2;

    	let t3_value = (/*artist*/ ctx[8].albumcount !== 1
    	? "releases"
    	: "release") + "";

    	let t3;
    	let t4;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(" •");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*artist*/ ctx[8].albumcount + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty & /*id*/ 1) && t3_value !== (t3_value = (/*artist*/ ctx[8].albumcount !== 1
    			? "releases"
    			: "release") + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(64:20) {#if artist.albumcount > 0}",
    		ctx
    	});

    	return block;
    }

    // (68:20) {#if artist.appearanceCount > 0}
    function create_if_block_7$2(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*artist*/ ctx[8].appearanceCount + "";
    	let t1;
    	let t2;

    	let t3_value = (/*artist*/ ctx[8].appearanceCount !== 1
    	? "appearances"
    	: "appearance") + "";

    	let t3;
    	let t4;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(" •");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*artist*/ ctx[8].appearanceCount + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty & /*id*/ 1) && t3_value !== (t3_value = (/*artist*/ ctx[8].appearanceCount !== 1
    			? "appearances"
    			: "appearance") + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(68:20) {#if artist.appearanceCount > 0}",
    		ctx
    	});

    	return block;
    }

    // (76:16) {#if artist.genre.length > 0}
    function create_if_block_6$3(ctx) {
    	let ul;
    	let current;
    	let each_value_1 = /*artist*/ ctx[8].genre;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "genres svelte-d9sz19");
    			add_location(ul, file$q, 76, 20, 3327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getArtist, id*/ 1) {
    				each_value_1 = /*artist*/ ctx[8].genre;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(76:16) {#if artist.genre.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (79:32) <Link to="genres/{genre.id}">
    function create_default_slot_1$6(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[14].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*genre*/ ctx[14].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(79:32) <Link to=\\\"genres/{genre.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each artist.genre as genre}
    function create_each_block_1$2(ctx) {
    	let li;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "genres/" + /*genre*/ ctx[14].id,
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			add_location(li, file$q, 78, 28, 3431);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*id*/ 1) link_changes.to = "genres/" + /*genre*/ ctx[14].id;

    			if (dirty & /*$$scope, id*/ 131073) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(78:24) {#each artist.genre as genre}",
    		ctx
    	});

    	return block;
    }

    // (119:16) {:catch error}
    function create_catch_block_1$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$q, 119, 20, 5106);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1$2.name,
    		type: "catch",
    		source: "(119:16) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (113:16) {:then songs}
    function create_then_block_2$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_5$3, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*songs*/ ctx[13].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_2$2.name,
    		type: "then",
    		source: "(113:16) {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (116:20) {:else}
    function create_else_block_3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No songs found";
    			add_location(p, file$q, 116, 24, 5004);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(116:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (114:20) {#if songs.length > 0}
    function create_if_block_5$3(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: {
    				data: /*songs*/ ctx[13],
    				type: "song",
    				showIndex: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};
    			if (dirty & /*id*/ 1) lister_changes.data = /*songs*/ ctx[13];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(114:20) {#if songs.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (111:50)                       Loading popular songs                  {:then songs}
    function create_pending_block_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading popular songs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_2$2.name,
    		type: "pending",
    		source: "(111:50)                       Loading popular songs                  {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (139:16) {:catch error}
    function create_catch_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$q, 139, 20, 5924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$4.name,
    		type: "catch",
    		source: "(139:16) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (127:16) {:then artists}
    function create_then_block_1$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_3$5, create_else_block_2$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*artists*/ ctx[9].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1$2.name,
    		type: "then",
    		source: "(127:16) {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (136:20) {:else}
    function create_else_block_2$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No similar artists";
    			add_location(p, file$q, 136, 24, 5818);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(136:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:20) {#if artists.length > 0}
    function create_if_block_3$5(ctx) {
    	let div;
    	let current;
    	let each_value = /*artists*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "artist-grid");
    			add_location(div, file$q, 128, 24, 5456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*similarArtists, id*/ 1) {
    				each_value = /*artists*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(128:20) {#if artists.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (131:32) {#if artist.name}
    function create_if_block_4$4(ctx) {
    	let artistcard;
    	let current;

    	artistcard = new ArtistCard({
    			props: { data: /*artist*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(artistcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(artistcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const artistcard_changes = {};
    			if (dirty & /*id*/ 1) artistcard_changes.data = /*artist*/ ctx[8];
    			artistcard.$set(artistcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artistcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artistcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artistcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(131:32) {#if artist.name}",
    		ctx
    	});

    	return block;
    }

    // (130:28) {#each artists as artist}
    function create_each_block$6(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*artist*/ ctx[8].name && create_if_block_4$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*artist*/ ctx[8].name) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*id*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(130:28) {#each artists as artist}",
    		ctx
    	});

    	return block;
    }

    // (125:43)                       Loading similar artists                  {:then artists}
    function create_pending_block_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading similar artists");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1$2.name,
    		type: "pending",
    		source: "(125:43)                       Loading similar artists                  {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (147:16) {:else}
    function create_else_block_1$5(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No songs found";
    			add_location(p, file$q, 147, 20, 6224);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(147:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (145:16) {#if artist.songcount > 0}
    function create_if_block_2$b(ctx) {
    	let artistsongs;
    	let current;

    	artistsongs = new ArtistSongs({
    			props: { artistID: /*artist*/ ctx[8].id },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(artistsongs.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(artistsongs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const artistsongs_changes = {};
    			if (dirty & /*id*/ 1) artistsongs_changes.artistID = /*artist*/ ctx[8].id;
    			artistsongs.$set(artistsongs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artistsongs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artistsongs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artistsongs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(145:16) {#if artist.songcount > 0}",
    		ctx
    	});

    	return block;
    }

    // (157:16) {:else}
    function create_else_block$e(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No summary found";
    			add_location(p, file$q, 157, 20, 6625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(157:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (153:16) {#if artist.summary && artist.summary.replace(/\s/g, "").length > 0}
    function create_if_block_1$c(ctx) {
    	let div;
    	let p;
    	let t_value = /*artist*/ ctx[8].summary + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$q, 154, 24, 6527);
    			attr_dev(div, "class", "summary svelte-d9sz19");
    			add_location(div, file$q, 153, 20, 6480);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && t_value !== (t_value = /*artist*/ ctx[8].summary + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(153:16) {#if artist.summary && artist.summary.replace(/\\s/g, \\\"\\\").length > 0}",
    		ctx
    	});

    	return block;
    }

    // (99:8) <Tabs bind:activeTabValue={currentTab} items={tabItems}>
    function create_default_slot$d(ctx) {
    	let div0;
    	let button;
    	let t0;

    	let t1_value = (/*$ShowExpandedAlbums*/ ctx[3]
    	? "condensed"
    	: "expanded") + "";

    	let t1;
    	let t2;
    	let artistreleases;
    	let t3;
    	let div1;
    	let promise;
    	let t4;
    	let div2;
    	let promise_1;
    	let t5;
    	let div3;
    	let current_block_type_index;
    	let if_block0;
    	let t6;
    	let div4;
    	let show_if;
    	let t7;
    	let div5;
    	let musicbrainzscan;
    	let current;
    	let mounted;
    	let dispose;

    	artistreleases = new ArtistReleases({
    			props: { artistID: /*artist*/ ctx[8].id },
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_2$2,
    		then: create_then_block_2$2,
    		catch: create_catch_block_1$2,
    		value: 13,
    		error: 12,
    		blocks: [,,,]
    	};

    	handle_promise(promise = getTopSongsFromArtist(/*id*/ ctx[0]), info);

    	let info_1 = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_1$2,
    		then: create_then_block_1$2,
    		catch: create_catch_block$4,
    		value: 9,
    		error: 12,
    		blocks: [,,,]
    	};

    	handle_promise(promise_1 = similarArtists(/*id*/ ctx[0]), info_1);
    	const if_block_creators = [create_if_block_2$b, create_else_block_1$5];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*artist*/ ctx[8].songcount > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (show_if == null || dirty & /*id*/ 1) show_if = !!(/*artist*/ ctx[8].summary && /*artist*/ ctx[8].summary.replace(/\s/g, "").length > 0);
    		if (show_if) return create_if_block_1$c;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type_4(ctx, -1);
    	let if_block1 = current_block_type(ctx);

    	musicbrainzscan = new MusicbrainzScan({
    			props: { data: /*artist*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button = element("button");
    			t0 = text("View ");
    			t1 = text(t1_value);
    			t2 = space();
    			create_component(artistreleases.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			info.block.c();
    			t4 = space();
    			div2 = element("div");
    			info_1.block.c();
    			t5 = space();
    			div3 = element("div");
    			if_block0.c();
    			t6 = space();
    			div4 = element("div");
    			if_block1.c();
    			t7 = space();
    			div5 = element("div");
    			create_component(musicbrainzscan.$$.fragment);
    			attr_dev(button, "class", "album-view-toggle svelte-d9sz19");
    			add_location(button, file$q, 100, 16, 4320);
    			attr_dev(div0, "class", "discography svelte-d9sz19");

    			set_style(div0, "display", /*currentTab*/ ctx[2] === "discography"
    			? "block"
    			: "none");

    			add_location(div0, file$q, 99, 12, 4210);
    			set_style(div1, "display", /*currentTab*/ ctx[2] === "popular" ? "block" : "none");
    			add_location(div1, file$q, 109, 12, 4631);
    			set_style(div2, "display", /*currentTab*/ ctx[2] === "similar" ? "block" : "none");
    			add_location(div2, file$q, 123, 12, 5193);
    			set_style(div3, "display", /*currentTab*/ ctx[2] === "all" ? "block" : "none");
    			add_location(div3, file$q, 143, 12, 6011);
    			set_style(div4, "display", /*currentTab*/ ctx[2] === "summary" ? "block" : "none");
    			add_location(div4, file$q, 151, 12, 6304);

    			set_style(div5, "display", /*currentTab*/ ctx[2] === "musicbrainz"
    			? "block"
    			: "none");

    			add_location(div5, file$q, 161, 12, 6707);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(div0, t2);
    			mount_component(artistreleases, div0, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			info.block.m(div1, info.anchor = null);
    			info.mount = () => div1;
    			info.anchor = null;
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div2, anchor);
    			info_1.block.m(div2, info_1.anchor = null);
    			info_1.mount = () => div2;
    			info_1.anchor = null;
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);
    			if_blocks[current_block_type_index].m(div3, null);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div4, anchor);
    			if_block1.m(div4, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(musicbrainzscan, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleShowExpanded*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if ((!current || dirty & /*$ShowExpandedAlbums*/ 8) && t1_value !== (t1_value = (/*$ShowExpandedAlbums*/ ctx[3]
    			? "condensed"
    			: "expanded") + "")) set_data_dev(t1, t1_value);

    			const artistreleases_changes = {};
    			if (dirty & /*id*/ 1) artistreleases_changes.artistID = /*artist*/ ctx[8].id;
    			artistreleases.$set(artistreleases_changes);

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div0, "display", /*currentTab*/ ctx[2] === "discography"
    				? "block"
    				: "none");
    			}

    			info.ctx = ctx;

    			if (dirty & /*id*/ 1 && promise !== (promise = getTopSongsFromArtist(/*id*/ ctx[0])) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div1, "display", /*currentTab*/ ctx[2] === "popular" ? "block" : "none");
    			}

    			info_1.ctx = ctx;

    			if (dirty & /*id*/ 1 && promise_1 !== (promise_1 = similarArtists(/*id*/ ctx[0])) && handle_promise(promise_1, info_1)) ; else {
    				update_await_block_branch(info_1, ctx, dirty);
    			}

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div2, "display", /*currentTab*/ ctx[2] === "similar" ? "block" : "none");
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div3, null);
    			}

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div3, "display", /*currentTab*/ ctx[2] === "all" ? "block" : "none");
    			}

    			if (current_block_type === (current_block_type = select_block_type_4(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div4, null);
    				}
    			}

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div4, "display", /*currentTab*/ ctx[2] === "summary" ? "block" : "none");
    			}

    			const musicbrainzscan_changes = {};
    			if (dirty & /*id*/ 1) musicbrainzscan_changes.data = /*artist*/ ctx[8];
    			musicbrainzscan.$set(musicbrainzscan_changes);

    			if (!current || dirty & /*currentTab*/ 4) {
    				set_style(div5, "display", /*currentTab*/ ctx[2] === "musicbrainz"
    				? "block"
    				: "none");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artistreleases.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(info_1.block);
    			transition_in(if_block0);
    			transition_in(musicbrainzscan.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artistreleases.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_1.blocks[i];
    				transition_out(block);
    			}

    			transition_out(if_block0);
    			transition_out(musicbrainzscan.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(artistreleases);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div2);
    			info_1.block.d();
    			info_1.token = null;
    			info_1 = null;
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div4);
    			if_block1.d();
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div5);
    			destroy_component(musicbrainzscan);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(99:8) <Tabs bind:activeTabValue={currentTab} items={tabItems}>",
    		ctx
    	});

    	return block;
    }

    // (51:22)       <p>Loading artist</p>  {:then artist}
    function create_pending_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading artist";
    			add_location(p, file$q, 51, 4, 2148);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$4.name,
    		type: "pending",
    		source: "(51:22)       <p>Loading artist</p>  {:then artist}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$4,
    		then: create_then_block$4,
    		catch: create_catch_block_2$2,
    		value: 8,
    		error: 12,
    		blocks: [,,,]
    	};

    	handle_promise(promise = getArtist(/*id*/ ctx[0]), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*id*/ 1 && promise !== (promise = getArtist(/*id*/ ctx[0])) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $ThemeIsLight;
    	let $ShowExpandedAlbums;
    	validate_store(ThemeIsLight, "ThemeIsLight");
    	component_subscribe($$self, ThemeIsLight, $$value => $$invalidate(1, $ThemeIsLight = $$value));
    	validate_store(ShowExpandedAlbums, "ShowExpandedAlbums");
    	component_subscribe($$self, ShowExpandedAlbums, $$value => $$invalidate(3, $ShowExpandedAlbums = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Artist", slots, []);
    	let { id } = $$props;
    	let theme;

    	// List of tab items with labels and values.
    	let tabItems = [
    		{
    			label: "Discography",
    			value: "discography",
    			icon: Album$1
    		},
    		{
    			label: "Popular songs",
    			value: "popular",
    			icon: Trending_up
    		},
    		{
    			label: "All songs",
    			value: "all",
    			icon: Songs
    		},
    		{
    			label: "Similar artists",
    			value: "similar",
    			icon: People
    		},
    		{
    			label: "Summary",
    			value: "summary",
    			icon: Article
    		},
    		{
    			label: "MusicBrainz compare",
    			value: "musicbrainz"
    		}
    	];

    	// Current active tab
    	let currentTab;

    	function toggleShowExpanded() {
    		ShowExpandedAlbums.set(!$ShowExpandedAlbums);
    	}

    	const writable_props = ["id"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Artist> was created with unknown prop '${key}'`);
    	});

    	function tabs_activeTabValue_binding(value) {
    		currentTab = value;
    		$$invalidate(2, currentTab);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Link,
    		ShowExpandedAlbums,
    		ThemeIsLight,
    		getArtist,
    		similarArtists,
    		getTopSongsFromArtist,
    		formatTimeToReadable,
    		Tabs,
    		ArtistCard,
    		ArtistReleases,
    		ArtistSongs,
    		Rating,
    		Lister,
    		MusicbrainzScan,
    		ThirdPartyServices,
    		Actions,
    		SVGAlbum: Album$1,
    		SVGPopular: Trending_up,
    		SVGSongs: Songs,
    		SVGSimilar: People,
    		SVGArticle: Article,
    		SVGGenre: Label,
    		id,
    		theme,
    		tabItems,
    		currentTab,
    		toggleShowExpanded,
    		$ThemeIsLight,
    		$ShowExpandedAlbums
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("theme" in $$props) theme = $$props.theme;
    		if ("tabItems" in $$props) $$invalidate(4, tabItems = $$props.tabItems);
    		if ("currentTab" in $$props) $$invalidate(2, currentTab = $$props.currentTab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ThemeIsLight*/ 2) {
    			theme = $ThemeIsLight ? "light" : "dark";
    		}
    	};

    	return [
    		id,
    		$ThemeIsLight,
    		currentTab,
    		$ShowExpandedAlbums,
    		tabItems,
    		toggleShowExpanded,
    		tabs_activeTabValue_binding
    	];
    }

    class Artist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Artist",
    			options,
    			id: create_fragment$s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<Artist> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<Artist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Artist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\albums.svelte generated by Svelte v3.38.3 */
    const file$p = "src\\views\\albums.svelte";

    // (11:4) <LinkCard url="albums/all">
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("All Albums");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(11:4) <LinkCard url=\\\"albums/all\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:4) <LinkCard url="albums/year">
    function create_default_slot$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("By Year");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(12:4) <LinkCard url=\\\"albums/year\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let h1;
    	let t1;
    	let section;
    	let linkcard0;
    	let t2;
    	let linkcard1;
    	let t3;
    	let cardlist0;
    	let t4;
    	let cardlist1;
    	let current;

    	linkcard0 = new LinkCard({
    			props: {
    				url: "albums/all",
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	linkcard1 = new LinkCard({
    			props: {
    				url: "albums/year",
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cardlist0 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "newestAlbums",
    				limit: "6",
    				heading: "Newest"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "randomAlbums",
    				limit: "6",
    				refresh: "true",
    				heading: "Random"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Albums";
    			t1 = space();
    			section = element("section");
    			create_component(linkcard0.$$.fragment);
    			t2 = space();
    			create_component(linkcard1.$$.fragment);
    			t3 = space();
    			create_component(cardlist0.$$.fragment);
    			t4 = space();
    			create_component(cardlist1.$$.fragment);
    			add_location(h1, file$p, 7, 0, 209);
    			attr_dev(section, "class", "link-grid");
    			add_location(section, file$p, 9, 0, 228);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section, anchor);
    			mount_component(linkcard0, section, null);
    			append_dev(section, t2);
    			mount_component(linkcard1, section, null);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(cardlist1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const linkcard0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				linkcard0_changes.$$scope = { dirty, ctx };
    			}

    			linkcard0.$set(linkcard0_changes);
    			const linkcard1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				linkcard1_changes.$$scope = { dirty, ctx };
    			}

    			linkcard1.$set(linkcard1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkcard0.$$.fragment, local);
    			transition_in(linkcard1.$$.fragment, local);
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkcard0.$$.fragment, local);
    			transition_out(linkcard1.$$.fragment, local);
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section);
    			destroy_component(linkcard0);
    			destroy_component(linkcard1);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(cardlist1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Albums", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Albums> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LinkCard,
    		CardList,
    		newestAlbums,
    		randomAlbums
    	});

    	return [];
    }

    class Albums extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Albums",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\views\albumsAll.svelte generated by Svelte v3.38.3 */
    const file$o = "src\\views\\albumsAll.svelte";

    // (33:0) {#if $allAlbums.loaded}
    function create_if_block$g(ctx) {
    	let previous_key = /*selectedChar*/ ctx[0];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$3(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedChar*/ 1 && safe_not_equal(previous_key, previous_key = /*selectedChar*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$3(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(33:0) {#if $allAlbums.loaded}",
    		ctx
    	});

    	return block;
    }

    // (34:4) {#key selectedChar}
    function create_key_block$3(ctx) {
    	let actions;
    	let t;
    	let lister;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "albumAlpha",
    				mode: "fullButtons",
    				data: { char: /*selectedChar*/ ctx[0] },
    				count: "3"
    			},
    			$$inline: true
    		});

    	lister = new Lister({
    			props: {
    				data: /*dataDisplay*/ ctx[2],
    				type: "album"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*selectedChar*/ 1) actions_changes.data = { char: /*selectedChar*/ ctx[0] };
    			actions.$set(actions_changes);
    			const lister_changes = {};
    			if (dirty & /*dataDisplay*/ 4) lister_changes.data = /*dataDisplay*/ ctx[2];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$3.name,
    		type: "key",
    		source: "(34:4) {#key selectedChar}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let h1;
    	let t1;
    	let alphanumericpagination;
    	let updating_selectedChar;
    	let t2;
    	let if_block_anchor;
    	let current;

    	function alphanumericpagination_selectedChar_binding(value) {
    		/*alphanumericpagination_selectedChar_binding*/ ctx[4](value);
    	}

    	let alphanumericpagination_props = { type: "albums" };

    	if (/*selectedChar*/ ctx[0] !== void 0) {
    		alphanumericpagination_props.selectedChar = /*selectedChar*/ ctx[0];
    	}

    	alphanumericpagination = new AlphanumericPagination({
    			props: alphanumericpagination_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(alphanumericpagination, "selectedChar", alphanumericpagination_selectedChar_binding));
    	let if_block = /*$allAlbums*/ ctx[1].loaded && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Albums by name";
    			t1 = space();
    			create_component(alphanumericpagination.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$o, 28, 0, 858);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(alphanumericpagination, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const alphanumericpagination_changes = {};

    			if (!updating_selectedChar && dirty & /*selectedChar*/ 1) {
    				updating_selectedChar = true;
    				alphanumericpagination_changes.selectedChar = /*selectedChar*/ ctx[0];
    				add_flush_callback(() => updating_selectedChar = false);
    			}

    			alphanumericpagination.$set(alphanumericpagination_changes);

    			if (/*$allAlbums*/ ctx[1].loaded) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$allAlbums*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alphanumericpagination.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alphanumericpagination.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(alphanumericpagination, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $allAlbums;
    	validate_store(allAlbums, "allAlbums");
    	component_subscribe($$self, allAlbums, $$value => $$invalidate(1, $allAlbums = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlbumsAll", slots, []);
    	let selectedChar = ""; // bound from alphanumericPagination
    	let filterChars = "";
    	let dataDisplay = [];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlbumsAll> was created with unknown prop '${key}'`);
    	});

    	function alphanumericpagination_selectedChar_binding(value) {
    		selectedChar = value;
    		$$invalidate(0, selectedChar);
    	}

    	$$self.$capture_state = () => ({
    		allAlbums,
    		AlphanumericPagination,
    		Actions,
    		Lister,
    		selectedChar,
    		filterChars,
    		dataDisplay,
    		$allAlbums
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedChar" in $$props) $$invalidate(0, selectedChar = $$props.selectedChar);
    		if ("filterChars" in $$props) $$invalidate(3, filterChars = $$props.filterChars);
    		if ("dataDisplay" in $$props) $$invalidate(2, dataDisplay = $$props.dataDisplay);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$allAlbums, selectedChar, filterChars*/ 11) {
    			{
    				if ($allAlbums.loaded) {
    					$$invalidate(3, filterChars = selectedChar.replaceAll("#", "(\\d|\\W)"));

    					if (selectedChar) {
    						$$invalidate(2, dataDisplay = $allAlbums.data.filter(function (a) {
    							let regex = new RegExp("^" + filterChars, "i");
    							return regex.test(a.name);
    						}));
    					} else {
    						$$invalidate(2, dataDisplay = $allAlbums.data);
    					}
    				}
    			}
    		}
    	};

    	return [
    		selectedChar,
    		$allAlbums,
    		dataDisplay,
    		filterChars,
    		alphanumericpagination_selectedChar_binding
    	];
    }

    class AlbumsAll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumsAll",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* public\images\plus.svg generated by Svelte v3.38.3 */

    function create_fragment$p(ctx) {
    	let svg;
    	let g0;
    	let rect;
    	let g2;
    	let g1;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ "enable-background": "new 0 0 24 24" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect = svg_element("rect");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			path = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					"enable-background": true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			g0 = claim_element(svg_nodes, "g", {}, 1);
    			var g0_nodes = children(g0);
    			rect = claim_element(g0_nodes, "rect", { fill: true, height: true, width: true }, 1);
    			children(rect).forEach(detach);
    			g0_nodes.forEach(detach);
    			g2 = claim_element(svg_nodes, "g", {}, 1);
    			var g2_nodes = children(g2);
    			g1 = claim_element(g2_nodes, "g", {}, 1);
    			var g1_nodes = children(g1);
    			path = claim_element(g1_nodes, "path", { d: true }, 1);
    			children(path).forEach(detach);
    			g1_nodes.forEach(detach);
    			g2_nodes.forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(rect, "fill", "none");
    			attr(rect, "height", "24");
    			attr(rect, "width", "24");
    			attr(path, "d", "M18,13h-5v5c0,0.55-0.45,1-1,1l0,0c-0.55,0-1-0.45-1-1v-5H6c-0.55,0-1-0.45-1-1l0,0c0-0.55,0.45-1,1-1h5V6 c0-0.55,0.45-1,1-1l0,0c0.55,0,1,0.45,1,1v5h5c0.55,0,1,0.45,1,1l0,0C19,12.55,18.55,13,18,13z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g0);
    			append(g0, rect);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, path);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ "enable-background": "new 0 0 24 24" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$p($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Plus extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});
    	}
    }

    /* public\images\minus.svg generated by Svelte v3.38.3 */

    function create_fragment$o(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ height: "24px" },
    		{ viewBox: "0 0 24 24" },
    		{ width: "24px" },
    		{ fill: "#000000" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	return {
    		c() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			this.h();
    		},
    		l(nodes) {
    			svg = claim_element(
    				nodes,
    				"svg",
    				{
    					xmlns: true,
    					height: true,
    					viewBox: true,
    					width: true,
    					fill: true
    				},
    				1
    			);

    			var svg_nodes = children(svg);
    			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
    			children(path0).forEach(detach);
    			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
    			children(path1).forEach(detach);
    			svg_nodes.forEach(detach);
    			this.h();
    		},
    		h() {
    			attr(path0, "d", "M0 0h24v24H0V0z");
    			attr(path0, "fill", "none");
    			attr(path1, "d", "M18 13H6c-.55 0-1-.45-1-1s.45-1 1-1h12c.55 0 1 .45 1 1s-.45 1-1 1z");
    			set_svg_attributes(svg, svg_data);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path0);
    			append(svg, path1);
    		},
    		p(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ height: "24px" },
    				{ viewBox: "0 0 24 24" },
    				{ width: "24px" },
    				{ fill: "#000000" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$o($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Minus extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});
    	}
    }

    /* src\components\yearPagination.svelte generated by Svelte v3.38.3 */
    const file$n = "src\\components\\yearPagination.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[39] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	return child_ctx;
    }

    // (182:16) {#each lastYears as chunk}
    function create_each_block_3$1(ctx) {
    	let li;
    	let button;
    	let t0;
    	let span;
    	let t1_value = /*chunk*/ ctx[45] + "";
    	let t1;
    	let t2;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text("Last ");
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = text(" years");
    			t3 = space();
    			attr_dev(span, "class", "emphasis svelte-w7ux4a");
    			add_location(span, file$n, 188, 33, 5758);
    			attr_dev(button, "data-from", /*yearRangeAdjustment*/ ctx[12](/*currentYear*/ ctx[6] - /*chunk*/ ctx[45]));
    			attr_dev(button, "data-to", /*currentYear*/ ctx[6]);
    			attr_dev(button, "class", "svelte-w7ux4a");
    			add_location(button, file$n, 183, 24, 5495);
    			add_location(li, file$n, 182, 20, 5465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(button, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(li, t3);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleRangeSelection*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(182:16) {#each lastYears as chunk}",
    		ctx
    	});

    	return block;
    }

    // (199:16) {#each centuries as century}
    function create_each_block_2$1(ctx) {
    	let li;
    	let button;
    	let t0_value = /*century*/ ctx[42] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "data-from", /*century*/ ctx[42]);
    			attr_dev(button, "data-to", /*maxValueCheck*/ ctx[11](/*century*/ ctx[42] + 99));
    			attr_dev(button, "data-century", /*century*/ ctx[42]);
    			attr_dev(button, "class", "svelte-w7ux4a");
    			toggle_class(button, "active", /*century*/ ctx[42].toString() === /*centuryFinal*/ ctx[0].toString());
    			add_location(button, file$n, 200, 24, 6136);
    			attr_dev(li, "class", "svelte-w7ux4a");
    			add_location(li, file$n, 199, 20, 6106);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleDateSelection*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*centuries, centuryFinal*/ 129) {
    				toggle_class(button, "active", /*century*/ ctx[42].toString() === /*centuryFinal*/ ctx[0].toString());
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(199:16) {#each centuries as century}",
    		ctx
    	});

    	return block;
    }

    // (218:16) {#each decades as decade}
    function create_each_block_1$1(ctx) {
    	let li;
    	let button;
    	let t0_value = /*decade*/ ctx[39] + "";
    	let t0;
    	let button_data_from_value;
    	let button_data_to_value;
    	let button_data_decade_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "data-from", button_data_from_value = /*decade*/ ctx[39]);
    			attr_dev(button, "data-to", button_data_to_value = /*maxValueCheck*/ ctx[11](/*decade*/ ctx[39] + 9));
    			attr_dev(button, "data-century", /*centuryFinal*/ ctx[0]);
    			attr_dev(button, "data-decade", button_data_decade_value = /*decade*/ ctx[39]);
    			attr_dev(button, "class", "svelte-w7ux4a");
    			toggle_class(button, "active", /*decade*/ ctx[39].toString() === /*decadeFinal*/ ctx[1].toString());
    			add_location(button, file$n, 219, 24, 6856);
    			attr_dev(li, "class", "svelte-w7ux4a");
    			add_location(li, file$n, 218, 20, 6826);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleDateSelection*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*decades*/ 4 && t0_value !== (t0_value = /*decade*/ ctx[39] + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*decades*/ 4 && button_data_from_value !== (button_data_from_value = /*decade*/ ctx[39])) {
    				attr_dev(button, "data-from", button_data_from_value);
    			}

    			if (dirty[0] & /*decades*/ 4 && button_data_to_value !== (button_data_to_value = /*maxValueCheck*/ ctx[11](/*decade*/ ctx[39] + 9))) {
    				attr_dev(button, "data-to", button_data_to_value);
    			}

    			if (dirty[0] & /*centuryFinal*/ 1) {
    				attr_dev(button, "data-century", /*centuryFinal*/ ctx[0]);
    			}

    			if (dirty[0] & /*decades*/ 4 && button_data_decade_value !== (button_data_decade_value = /*decade*/ ctx[39])) {
    				attr_dev(button, "data-decade", button_data_decade_value);
    			}

    			if (dirty[0] & /*decades, decadeFinal*/ 6) {
    				toggle_class(button, "active", /*decade*/ ctx[39].toString() === /*decadeFinal*/ ctx[1].toString());
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(218:16) {#each decades as decade}",
    		ctx
    	});

    	return block;
    }

    // (238:16) {#each years as year}
    function create_each_block$5(ctx) {
    	let li;
    	let button;
    	let t0_value = /*year*/ ctx[36] + "";
    	let t0;
    	let button_data_from_value;
    	let button_data_to_value;
    	let button_data_year_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "data-from", button_data_from_value = /*year*/ ctx[36]);
    			attr_dev(button, "data-to", button_data_to_value = /*year*/ ctx[36]);
    			attr_dev(button, "data-century", /*centuryFinal*/ ctx[0]);
    			attr_dev(button, "data-decade", /*decadeFinal*/ ctx[1]);
    			attr_dev(button, "data-year", button_data_year_value = /*year*/ ctx[36]);
    			attr_dev(button, "class", "svelte-w7ux4a");
    			add_location(button, file$n, 239, 24, 7617);
    			attr_dev(li, "class", "svelte-w7ux4a");
    			add_location(li, file$n, 238, 20, 7587);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleDateSelection*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*years*/ 8 && t0_value !== (t0_value = /*year*/ ctx[36] + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*years*/ 8 && button_data_from_value !== (button_data_from_value = /*year*/ ctx[36])) {
    				attr_dev(button, "data-from", button_data_from_value);
    			}

    			if (dirty[0] & /*years*/ 8 && button_data_to_value !== (button_data_to_value = /*year*/ ctx[36])) {
    				attr_dev(button, "data-to", button_data_to_value);
    			}

    			if (dirty[0] & /*centuryFinal*/ 1) {
    				attr_dev(button, "data-century", /*centuryFinal*/ ctx[0]);
    			}

    			if (dirty[0] & /*decadeFinal*/ 2) {
    				attr_dev(button, "data-decade", /*decadeFinal*/ ctx[1]);
    			}

    			if (dirty[0] & /*years*/ 8 && button_data_year_value !== (button_data_year_value = /*year*/ ctx[36])) {
    				attr_dev(button, "data-year", button_data_year_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(238:16) {#each years as year}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div12;
    	let div2;
    	let div0;
    	let label0;
    	let t0;
    	let input0;
    	let t1;
    	let button0;
    	let svgminus0;
    	let t2;
    	let button1;
    	let svgplus0;
    	let t3;
    	let div1;
    	let label1;
    	let t4;
    	let input1;
    	let t5;
    	let button2;
    	let svgminus1;
    	let t6;
    	let button3;
    	let svgplus1;
    	let t7;
    	let button4;
    	let t9;
    	let div11;
    	let div4;
    	let div3;
    	let t11;
    	let ul0;
    	let t12;
    	let div6;
    	let div5;
    	let t14;
    	let ul1;
    	let t15;
    	let div8;
    	let div7;
    	let t17;
    	let ul2;
    	let t18;
    	let div10;
    	let div9;
    	let t20;
    	let ul3;
    	let current;
    	let mounted;
    	let dispose;
    	svgminus0 = new Minus({ props: { class: "icon" }, $$inline: true });
    	svgplus0 = new Plus({ props: { class: "icon" }, $$inline: true });
    	svgminus1 = new Minus({ props: { class: "icon" }, $$inline: true });
    	svgplus1 = new Plus({ props: { class: "icon" }, $$inline: true });
    	let each_value_3 = /*lastYears*/ ctx[8];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*centuries*/ ctx[7];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*decades*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let each_value = /*years*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div12 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			t0 = text("From\r\n                ");
    			input0 = element("input");
    			t1 = space();
    			button0 = element("button");
    			create_component(svgminus0.$$.fragment);
    			t2 = space();
    			button1 = element("button");
    			create_component(svgplus0.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			label1 = element("label");
    			t4 = text("To\r\n                ");
    			input1 = element("input");
    			t5 = space();
    			button2 = element("button");
    			create_component(svgminus1.$$.fragment);
    			t6 = space();
    			button3 = element("button");
    			create_component(svgplus1.$$.fragment);
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "Search";
    			t9 = space();
    			div11 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div3.textContent = "Ranges";
    			t11 = space();
    			ul0 = element("ul");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t12 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div5.textContent = "Centuries";
    			t14 = space();
    			ul1 = element("ul");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t15 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div7.textContent = "Decades";
    			t17 = space();
    			ul2 = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t18 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div9.textContent = "Years";
    			t20 = space();
    			ul3 = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "size", "4");
    			attr_dev(input0, "maxlength", "4");
    			attr_dev(input0, "class", "svelte-w7ux4a");
    			add_location(input0, file$n, 159, 16, 4387);
    			attr_dev(label0, "class", "svelte-w7ux4a");
    			add_location(label0, file$n, 157, 12, 4340);
    			attr_dev(button0, "class", "minus svelte-w7ux4a");
    			add_location(button0, file$n, 161, 12, 4513);
    			attr_dev(button1, "class", "plus svelte-w7ux4a");
    			add_location(button1, file$n, 162, 12, 4627);
    			attr_dev(div0, "class", "input-group svelte-w7ux4a");
    			add_location(div0, file$n, 156, 8, 4301);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "size", "4");
    			attr_dev(input1, "maxlength", "4");
    			attr_dev(input1, "class", "svelte-w7ux4a");
    			add_location(input1, file$n, 168, 16, 4837);
    			attr_dev(label1, "class", "svelte-w7ux4a");
    			add_location(label1, file$n, 166, 12, 4792);
    			attr_dev(button2, "class", "minus svelte-w7ux4a");
    			add_location(button2, file$n, 170, 12, 4959);
    			attr_dev(button3, "class", "plus svelte-w7ux4a");
    			add_location(button3, file$n, 171, 12, 5069);
    			attr_dev(div1, "class", "input-group svelte-w7ux4a");
    			add_location(div1, file$n, 165, 8, 4753);
    			attr_dev(button4, "class", "submit primary svelte-w7ux4a");
    			add_location(button4, file$n, 174, 8, 5191);
    			attr_dev(div2, "class", "inputs svelte-w7ux4a");
    			add_location(div2, file$n, 155, 4, 4271);
    			attr_dev(div3, "class", "label svelte-w7ux4a");
    			add_location(div3, file$n, 179, 12, 5350);
    			attr_dev(ul0, "class", "svelte-w7ux4a");
    			add_location(ul0, file$n, 180, 12, 5395);
    			attr_dev(div4, "class", "row ranges svelte-w7ux4a");
    			add_location(div4, file$n, 178, 8, 5312);
    			attr_dev(div5, "class", "label svelte-w7ux4a");
    			add_location(div5, file$n, 196, 12, 5986);
    			attr_dev(ul1, "class", "svelte-w7ux4a");
    			add_location(ul1, file$n, 197, 12, 6034);
    			attr_dev(div6, "class", "row timeframe centuries svelte-w7ux4a");
    			add_location(div6, file$n, 195, 8, 5935);
    			attr_dev(div7, "class", "label svelte-w7ux4a");
    			add_location(div7, file$n, 215, 12, 6711);
    			attr_dev(ul2, "class", "svelte-w7ux4a");
    			add_location(ul2, file$n, 216, 12, 6757);
    			attr_dev(div8, "class", "row timeframe decades svelte-w7ux4a");
    			add_location(div8, file$n, 214, 8, 6662);
    			attr_dev(div9, "class", "label svelte-w7ux4a");
    			add_location(div9, file$n, 235, 12, 7478);
    			attr_dev(ul3, "class", "svelte-w7ux4a");
    			add_location(ul3, file$n, 236, 12, 7522);
    			attr_dev(div10, "class", "row timeframe years svelte-w7ux4a");
    			add_location(div10, file$n, 234, 8, 7431);
    			attr_dev(div11, "class", "presets svelte-w7ux4a");
    			add_location(div11, file$n, 177, 4, 5281);
    			attr_dev(div12, "class", "container svelte-w7ux4a");
    			add_location(div12, file$n, 154, 0, 4242);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div2);
    			append_dev(div2, div0);
    			append_dev(div0, label0);
    			append_dev(label0, t0);
    			append_dev(label0, input0);
    			set_input_value(input0, /*fromFinal*/ ctx[4]);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			mount_component(svgminus0, button0, null);
    			append_dev(div0, t2);
    			append_dev(div0, button1);
    			mount_component(svgplus0, button1, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, label1);
    			append_dev(label1, t4);
    			append_dev(label1, input1);
    			set_input_value(input1, /*toFinal*/ ctx[5]);
    			append_dev(div1, t5);
    			append_dev(div1, button2);
    			mount_component(svgminus1, button2, null);
    			append_dev(div1, t6);
    			append_dev(div1, button3);
    			mount_component(svgplus1, button3, null);
    			append_dev(div2, t7);
    			append_dev(div2, button4);
    			append_dev(div12, t9);
    			append_dev(div12, div11);
    			append_dev(div11, div4);
    			append_dev(div4, div3);
    			append_dev(div4, t11);
    			append_dev(div4, ul0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(ul0, null);
    			}

    			append_dev(div11, t12);
    			append_dev(div11, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t14);
    			append_dev(div6, ul1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(ul1, null);
    			}

    			append_dev(div11, t15);
    			append_dev(div11, div8);
    			append_dev(div8, div7);
    			append_dev(div8, t17);
    			append_dev(div8, ul2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul2, null);
    			}

    			append_dev(div11, t18);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div10, t20);
    			append_dev(div10, ul3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[19]),
    					listen_dev(input0, "change", /*handleFrom*/ ctx[14], false, false, false),
    					listen_dev(button0, "click", /*click_handler*/ ctx[20], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[21], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[22]),
    					listen_dev(input1, "change", /*handleTo*/ ctx[13], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[23], false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[24], false, false, false),
    					listen_dev(button4, "click", /*handleSearch*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*fromFinal*/ 16 && to_number(input0.value) !== /*fromFinal*/ ctx[4]) {
    				set_input_value(input0, /*fromFinal*/ ctx[4]);
    			}

    			if (dirty[0] & /*toFinal*/ 32 && to_number(input1.value) !== /*toFinal*/ ctx[5]) {
    				set_input_value(input1, /*toFinal*/ ctx[5]);
    			}

    			if (dirty[0] & /*yearRangeAdjustment, currentYear, lastYears, handleRangeSelection*/ 5440) {
    				each_value_3 = /*lastYears*/ ctx[8];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$1(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(ul0, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*centuries, maxValueCheck, centuryFinal, handleDateSelection*/ 2689) {
    				each_value_2 = /*centuries*/ ctx[7];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(ul1, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*decades, maxValueCheck, centuryFinal, decadeFinal, handleDateSelection*/ 2567) {
    				each_value_1 = /*decades*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(ul2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*years, centuryFinal, decadeFinal, handleDateSelection*/ 523) {
    				each_value = /*years*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgminus0.$$.fragment, local);
    			transition_in(svgplus0.$$.fragment, local);
    			transition_in(svgminus1.$$.fragment, local);
    			transition_in(svgplus1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgminus0.$$.fragment, local);
    			transition_out(svgplus0.$$.fragment, local);
    			transition_out(svgminus1.$$.fragment, local);
    			transition_out(svgplus1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div12);
    			destroy_component(svgminus0);
    			destroy_component(svgplus0);
    			destroy_component(svgminus1);
    			destroy_component(svgplus1);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("YearPagination", slots, []);
    	const currentMonth = new Date().getMonth();
    	const currentYear = new Date().getFullYear();
    	const currentDecade = Math.floor(currentYear / 10) * 10;
    	const currentCentury = Math.floor(currentYear / 100) * 100;
    	let { fromYear = currentYear } = $$props;
    	let { toYear = currentYear } = $$props;
    	let { showYear } = $$props;
    	let loadCount = 0;
    	let centuries = [];
    	let decades;
    	let years;
    	let lastYears = [2, 5, 10, 15, 20, 30, 40, 50];
    	let centuryFinal = currentCentury;
    	let decadeFinal = currentDecade;
    	let yearFinal = currentYear;

    	// Begin component
    	let params = new URL(document.location).searchParams;

    	// Load from URL otherwise set defaults
    	let fromFinal = params.get("from") || showYear || currentYear;

    	let toFinal = params.get("to") || showYear || currentYear;
    	generateCenturies();

    	function generateCenturies() {
    		// generate centuries
    		for (let i = currentCentury; i > 1400; i = i - 100) {
    			centuries.push(i);
    		}

    		centuries.reverse();
    	}

    	function generateDecades(val) {
    		let tempDecades = [];

    		for (let i = parseInt(val); i < parseInt(val) + 100; i = i + 10) {
    			if (i <= currentDecade) {
    				tempDecades.push(i);
    			}
    		}

    		return tempDecades;
    	}

    	function generateYears(val) {
    		let tempYears = [];

    		for (let i = parseInt(val); i < parseInt(val) + 10; i = i + 1) {
    			if (i <= currentYear) {
    				tempYears.push(i);
    			}
    		}

    		return tempYears;
    	}

    	const handleDateSelection = e => {
    		let fromSelected = e.target.dataset.from;
    		let toSelected = e.target.dataset.to;
    		let centurySelected = e.target.dataset.century;
    		let decadeSelected = e.target.dataset.decade;
    		let yearSelected = e.target.dataset.year;
    		$$invalidate(4, fromFinal = fromSelected || fromFinal);
    		$$invalidate(5, toFinal = toSelected || toFinal);
    		$$invalidate(0, centuryFinal = centurySelected || "");
    		$$invalidate(1, decadeFinal = decadeSelected || "");
    		yearFinal = yearSelected || "";
    		updateURL();
    	};

    	const handleRangeSelection = e => {
    		let fromSelected = e.target.dataset.from;
    		let toSelected = e.target.dataset.to;
    		$$invalidate(4, fromFinal = fromSelected || fromFinal);
    		$$invalidate(5, toFinal = toSelected || toFinal);
    		updateURL();
    	};

    	// Cap values at currentYear
    	function maxValueCheck(val) {
    		return val > currentYear ? currentYear : val;
    	}

    	// Include more time in range if current year is still newish
    	function yearRangeAdjustment(year) {
    		return currentMonth >= 5 ? year + 1 : year;
    	}

    	function updateURL() {
    		let url = new URL(window.location);
    		url.searchParams.set("from", fromFinal);
    		url.searchParams.set("to", toFinal);
    		window.history.replaceState({}, "", url);
    	}

    	const handleValues = e => {
    		// Ensure values are never higher than current year
    		$$invalidate(5, toFinal = maxValueCheck(toFinal));

    		$$invalidate(4, fromFinal = maxValueCheck(fromFinal));
    		updateURL();
    	};

    	const handleTo = e => {
    		if (toFinal < fromFinal) {
    			$$invalidate(4, fromFinal = toFinal);
    		}

    		handleValues();
    	};

    	const handleFrom = e => {
    		if (fromFinal > toFinal) {
    			$$invalidate(5, toFinal = fromFinal);
    		}

    		handleValues();
    	};

    	const handleSearch = e => {
    		$$invalidate(16, fromYear = fromFinal);
    		$$invalidate(17, toYear = toFinal);

    		if (loadCount > 0) {
    			// reset to first page when searching
    			let url = new URL(window.location);

    			url.searchParams.set("page", "1");
    			window.history.replaceState({}, "", url);
    		}
    	};

    	onMount(() => {
    		handleSearch();
    		loadCount++;
    	});

    	const writable_props = ["fromYear", "toYear", "showYear"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<YearPagination> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		fromFinal = to_number(this.value);
    		$$invalidate(4, fromFinal);
    	}

    	const click_handler = () => {
    		$$invalidate(4, --fromFinal);
    		handleFrom();
    	};

    	const click_handler_1 = () => {
    		$$invalidate(4, ++fromFinal);
    		handleFrom();
    	};

    	function input1_input_handler() {
    		toFinal = to_number(this.value);
    		$$invalidate(5, toFinal);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(5, --toFinal);
    		handleTo();
    	};

    	const click_handler_3 = () => {
    		$$invalidate(5, ++toFinal);
    		handleTo();
    	};

    	$$self.$$set = $$props => {
    		if ("fromYear" in $$props) $$invalidate(16, fromYear = $$props.fromYear);
    		if ("toYear" in $$props) $$invalidate(17, toYear = $$props.toYear);
    		if ("showYear" in $$props) $$invalidate(18, showYear = $$props.showYear);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		SVGPlus: Plus,
    		SVGMinus: Minus,
    		currentMonth,
    		currentYear,
    		currentDecade,
    		currentCentury,
    		fromYear,
    		toYear,
    		showYear,
    		loadCount,
    		centuries,
    		decades,
    		years,
    		lastYears,
    		centuryFinal,
    		decadeFinal,
    		yearFinal,
    		params,
    		fromFinal,
    		toFinal,
    		generateCenturies,
    		generateDecades,
    		generateYears,
    		handleDateSelection,
    		handleRangeSelection,
    		maxValueCheck,
    		yearRangeAdjustment,
    		updateURL,
    		handleValues,
    		handleTo,
    		handleFrom,
    		handleSearch
    	});

    	$$self.$inject_state = $$props => {
    		if ("fromYear" in $$props) $$invalidate(16, fromYear = $$props.fromYear);
    		if ("toYear" in $$props) $$invalidate(17, toYear = $$props.toYear);
    		if ("showYear" in $$props) $$invalidate(18, showYear = $$props.showYear);
    		if ("loadCount" in $$props) loadCount = $$props.loadCount;
    		if ("centuries" in $$props) $$invalidate(7, centuries = $$props.centuries);
    		if ("decades" in $$props) $$invalidate(2, decades = $$props.decades);
    		if ("years" in $$props) $$invalidate(3, years = $$props.years);
    		if ("lastYears" in $$props) $$invalidate(8, lastYears = $$props.lastYears);
    		if ("centuryFinal" in $$props) $$invalidate(0, centuryFinal = $$props.centuryFinal);
    		if ("decadeFinal" in $$props) $$invalidate(1, decadeFinal = $$props.decadeFinal);
    		if ("yearFinal" in $$props) yearFinal = $$props.yearFinal;
    		if ("params" in $$props) params = $$props.params;
    		if ("fromFinal" in $$props) $$invalidate(4, fromFinal = $$props.fromFinal);
    		if ("toFinal" in $$props) $$invalidate(5, toFinal = $$props.toFinal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*centuryFinal*/ 1) {
    			$$invalidate(2, decades = generateDecades(centuryFinal));
    		}

    		if ($$self.$$.dirty[0] & /*decadeFinal*/ 2) {
    			$$invalidate(3, years = generateYears(decadeFinal));
    		}
    	};

    	return [
    		centuryFinal,
    		decadeFinal,
    		decades,
    		years,
    		fromFinal,
    		toFinal,
    		currentYear,
    		centuries,
    		lastYears,
    		handleDateSelection,
    		handleRangeSelection,
    		maxValueCheck,
    		yearRangeAdjustment,
    		handleTo,
    		handleFrom,
    		handleSearch,
    		fromYear,
    		toYear,
    		showYear,
    		input0_input_handler,
    		click_handler,
    		click_handler_1,
    		input1_input_handler,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class YearPagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { fromYear: 16, toYear: 17, showYear: 18 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "YearPagination",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*showYear*/ ctx[18] === undefined && !("showYear" in props)) {
    			console.warn("<YearPagination> was created without expected prop 'showYear'");
    		}
    	}

    	get fromYear() {
    		throw new Error("<YearPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fromYear(value) {
    		throw new Error("<YearPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toYear() {
    		throw new Error("<YearPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toYear(value) {
    		throw new Error("<YearPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showYear() {
    		throw new Error("<YearPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showYear(value) {
    		throw new Error("<YearPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\albumsByYear.svelte generated by Svelte v3.38.3 */
    const file$m = "src\\views\\albumsByYear.svelte";

    // (37:0) {#if fromYear && toYear}
    function create_if_block$f(ctx) {
    	let previous_key = /*fromYear*/ ctx[1] + /*toYear*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$2(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fromYear, toYear*/ 6 && safe_not_equal(previous_key, previous_key = /*fromYear*/ ctx[1] + /*toYear*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$2(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(37:0) {#if fromYear && toYear}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {:else}
    function create_else_block$d(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No albums found within requested range";
    			add_location(p, file$m, 51, 16, 1228);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(51:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (49:12) {#if data.length > 0}
    function create_if_block_2$a(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: { data: /*data*/ ctx[3], type: "album" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};
    			if (dirty & /*data*/ 8) lister_changes.data = /*data*/ ctx[3];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(49:12) {#if data.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (46:8) {#if loading}
    function create_if_block_1$b(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading albums";
    			add_location(p, file$m, 46, 12, 1063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(46:8) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#key fromYear+toYear}
    function create_key_block$2(ctx) {
    	let actions;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "year",
    				mode: "fullButtons",
    				data: {
    					from: /*fromYear*/ ctx[1],
    					to: /*toYear*/ ctx[2]
    				},
    				count: "3"
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1$b, create_if_block_2$a, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[4]) return 0;
    		if (/*data*/ ctx[3].length > 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};

    			if (dirty & /*fromYear, toYear*/ 6) actions_changes.data = {
    				from: /*fromYear*/ ctx[1],
    				to: /*toYear*/ ctx[2]
    			};

    			actions.$set(actions_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$2.name,
    		type: "key",
    		source: "(38:4) {#key fromYear+toYear}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let h1;
    	let t1;
    	let yearpagination;
    	let updating_fromYear;
    	let updating_toYear;
    	let t2;
    	let if_block_anchor;
    	let current;

    	function yearpagination_fromYear_binding(value) {
    		/*yearpagination_fromYear_binding*/ ctx[5](value);
    	}

    	function yearpagination_toYear_binding(value) {
    		/*yearpagination_toYear_binding*/ ctx[6](value);
    	}

    	let yearpagination_props = { showYear: /*year*/ ctx[0] };

    	if (/*fromYear*/ ctx[1] !== void 0) {
    		yearpagination_props.fromYear = /*fromYear*/ ctx[1];
    	}

    	if (/*toYear*/ ctx[2] !== void 0) {
    		yearpagination_props.toYear = /*toYear*/ ctx[2];
    	}

    	yearpagination = new YearPagination({
    			props: yearpagination_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(yearpagination, "fromYear", yearpagination_fromYear_binding));
    	binding_callbacks.push(() => bind(yearpagination, "toYear", yearpagination_toYear_binding));
    	let if_block = /*fromYear*/ ctx[1] && /*toYear*/ ctx[2] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Albums by year";
    			t1 = space();
    			create_component(yearpagination.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$m, 32, 0, 722);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(yearpagination, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const yearpagination_changes = {};
    			if (dirty & /*year*/ 1) yearpagination_changes.showYear = /*year*/ ctx[0];

    			if (!updating_fromYear && dirty & /*fromYear*/ 2) {
    				updating_fromYear = true;
    				yearpagination_changes.fromYear = /*fromYear*/ ctx[1];
    				add_flush_callback(() => updating_fromYear = false);
    			}

    			if (!updating_toYear && dirty & /*toYear*/ 4) {
    				updating_toYear = true;
    				yearpagination_changes.toYear = /*toYear*/ ctx[2];
    				add_flush_callback(() => updating_toYear = false);
    			}

    			yearpagination.$set(yearpagination_changes);

    			if (/*fromYear*/ ctx[1] && /*toYear*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*fromYear, toYear*/ 6) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(yearpagination.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(yearpagination.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(yearpagination, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AlbumsByYear", slots, []);
    	let { year = null } = $$props;
    	let albumList = [];
    	let data = [];
    	let fromYear;
    	let toYear;
    	let loading = true;

    	async function getData(fromYear, toYear) {
    		$$invalidate(4, loading = true);
    		$$invalidate(3, data = await getAlbumsByYear(fromYear, toYear));
    		$$invalidate(4, loading = false);
    	}

    	onMount(() => {
    		getData();
    	});

    	const writable_props = ["year"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlbumsByYear> was created with unknown prop '${key}'`);
    	});

    	function yearpagination_fromYear_binding(value) {
    		fromYear = value;
    		$$invalidate(1, fromYear);
    	}

    	function yearpagination_toYear_binding(value) {
    		toYear = value;
    		$$invalidate(2, toYear);
    	}

    	$$self.$$set = $$props => {
    		if ("year" in $$props) $$invalidate(0, year = $$props.year);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		getAlbumsByYear,
    		YearPagination,
    		Actions,
    		Lister,
    		year,
    		albumList,
    		data,
    		fromYear,
    		toYear,
    		loading,
    		getData
    	});

    	$$self.$inject_state = $$props => {
    		if ("year" in $$props) $$invalidate(0, year = $$props.year);
    		if ("albumList" in $$props) albumList = $$props.albumList;
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("fromYear" in $$props) $$invalidate(1, fromYear = $$props.fromYear);
    		if ("toYear" in $$props) $$invalidate(2, toYear = $$props.toYear);
    		if ("loading" in $$props) $$invalidate(4, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fromYear, toYear*/ 6) {
    			{
    				$$invalidate(3, data = getData(fromYear, toYear));
    			}
    		}
    	};

    	return [
    		year,
    		fromYear,
    		toYear,
    		data,
    		loading,
    		yearpagination_fromYear_binding,
    		yearpagination_toYear_binding
    	];
    }

    class AlbumsByYear extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { year: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumsByYear",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get year() {
    		throw new Error("<AlbumsByYear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<AlbumsByYear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\album.svelte generated by Svelte v3.38.3 */
    const file$l = "src\\views\\album.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (84:0) {:catch error}
    function create_catch_block$3(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*error*/ ctx[7].message + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Something went wrong: ");
    			t1 = text(t1_value);
    			add_location(p, file$l, 84, 4, 3378);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && t1_value !== (t1_value = /*error*/ ctx[7].message + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$3.name,
    		type: "catch",
    		source: "(84:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (27:0) {:then album}
    function create_then_block$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*album*/ ctx[3].id) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$3.name,
    		type: "then",
    		source: "(27:0) {:then album}",
    		ctx
    	});

    	return block;
    }

    // (81:4) {:else}
    function create_else_block$c(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find album with that ID";
    			add_location(p, file$l, 81, 8, 3305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(81:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if album.id}
    function create_if_block$e(ctx) {
    	let t0;
    	let div7;
    	let div5;
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_intro;
    	let t1;
    	let div3;
    	let h1;
    	let t2_value = /*album*/ ctx[3].name + "";
    	let t2;
    	let t3;
    	let div1;
    	let span;
    	let link0;
    	let t4;
    	let link1;
    	let t5;
    	let p;
    	let t6_value = formatTotalTime(/*album*/ ctx[3].time) + "";
    	let t6;
    	let t7;
    	let t8_value = /*album*/ ctx[3].songcount + "";
    	let t8;
    	let t9;

    	let t10_value = (parseInt(/*album*/ ctx[3].songcount) === 1
    	? "song"
    	: "songs") + "";

    	let t10;
    	let t11;
    	let t12;
    	let div2;
    	let rating;
    	let t13;
    	let thirdpartyservices;
    	let t14;
    	let actions;
    	let t15;
    	let div6;
    	let albumsongs;
    	let current;
    	let if_block0 = /*album*/ ctx[3].useBackground && !/*$ThemeIsLight*/ ctx[1] && create_if_block_2$9(ctx);

    	link0 = new Link({
    			props: {
    				to: "albums/year/" + /*album*/ ctx[3].year,
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "artists/" + /*album*/ ctx[3].artist.id,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*album*/ ctx[3].genre.length > 0 && create_if_block_1$a(ctx);

    	rating = new Rating({
    			props: {
    				type: "album",
    				id: /*album*/ ctx[3].id,
    				rating: /*album*/ ctx[3].rating,
    				flag: /*album*/ ctx[3].flag,
    				averageRating: /*album*/ ctx[3].averagerating
    			},
    			$$inline: true
    		});

    	thirdpartyservices = new ThirdPartyServices({
    			props: { data: /*album*/ ctx[3], type: "album" },
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				type: "album",
    				mode: "fullButtons",
    				id: /*album*/ ctx[3].id,
    				count: /*album*/ ctx[3].songcount,
    				artistID: /*album*/ ctx[3].artist.id
    			},
    			$$inline: true
    		});

    	albumsongs = new AlbumSongs({
    			props: { id: /*album*/ ctx[3].id },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div7 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t1 = space();
    			div3 = element("div");
    			h1 = element("h1");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(link0.$$.fragment);
    			t4 = space();
    			create_component(link1.$$.fragment);
    			t5 = space();
    			p = element("p");
    			t6 = text(t6_value);
    			t7 = text("\r\n                            •\r\n                            ");
    			t8 = text(t8_value);
    			t9 = space();
    			t10 = text(t10_value);
    			t11 = space();
    			if (if_block1) if_block1.c();
    			t12 = space();
    			div2 = element("div");
    			create_component(rating.$$.fragment);
    			t13 = space();
    			create_component(thirdpartyservices.$$.fragment);
    			t14 = space();
    			create_component(actions.$$.fragment);
    			t15 = space();
    			div6 = element("div");
    			create_component(albumsongs.$$.fragment);
    			attr_dev(img, "class", "cover svelte-1wxh02i");
    			if (img.src !== (img_src_value = "" + (/*album*/ ctx[3].art + "&thumb=32"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*album*/ ctx[3].name);
    			attr_dev(img, "width", "384");
    			attr_dev(img, "height", "384");
    			add_location(img, file$l, 36, 24, 1247);
    			attr_dev(div0, "class", "cover-container svelte-1wxh02i");
    			add_location(div0, file$l, 35, 20, 1192);
    			attr_dev(h1, "class", "title svelte-1wxh02i");
    			add_location(h1, file$l, 40, 24, 1451);
    			attr_dev(span, "class", "date svelte-1wxh02i");
    			add_location(span, file$l, 42, 28, 1560);
    			attr_dev(div1, "class", "meta svelte-1wxh02i");
    			add_location(div1, file$l, 41, 24, 1512);
    			add_location(p, file$l, 45, 24, 1846);
    			attr_dev(div2, "class", "inline svelte-1wxh02i");
    			add_location(div2, file$l, 59, 24, 2499);
    			attr_dev(div3, "class", "info");
    			add_location(div3, file$l, 39, 20, 1407);
    			attr_dev(div4, "class", "details svelte-1wxh02i");
    			add_location(div4, file$l, 34, 16, 1149);
    			attr_dev(div5, "class", "details-container svelte-1wxh02i");
    			add_location(div5, file$l, 33, 12, 1100);
    			attr_dev(div6, "class", "songs svelte-1wxh02i");
    			add_location(div6, file$l, 76, 12, 3182);
    			attr_dev(div7, "class", "container svelte-1wxh02i");
    			add_location(div7, file$l, 32, 8, 1063);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, h1);
    			append_dev(h1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, span);
    			mount_component(link0, span, null);
    			append_dev(div1, t4);
    			mount_component(link1, div1, null);
    			append_dev(div3, t5);
    			append_dev(div3, p);
    			append_dev(p, t6);
    			append_dev(p, t7);
    			append_dev(p, t8);
    			append_dev(p, t9);
    			append_dev(p, t10);
    			append_dev(div3, t11);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t12);
    			append_dev(div3, div2);
    			mount_component(rating, div2, null);
    			append_dev(div2, t13);
    			mount_component(thirdpartyservices, div2, null);
    			append_dev(div3, t14);
    			mount_component(actions, div3, null);
    			append_dev(div7, t15);
    			append_dev(div7, div6);
    			mount_component(albumsongs, div6, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*album*/ ctx[3].useBackground && !/*$ThemeIsLight*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*id, $ThemeIsLight*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*id*/ 1 && img.src !== (img_src_value = "" + (/*album*/ ctx[3].art + "&thumb=32"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*id*/ 1 && img_alt_value !== (img_alt_value = "Image of " + /*album*/ ctx[3].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if ((!current || dirty & /*id*/ 1) && t2_value !== (t2_value = /*album*/ ctx[3].name + "")) set_data_dev(t2, t2_value);
    			const link0_changes = {};
    			if (dirty & /*id*/ 1) link0_changes.to = "albums/year/" + /*album*/ ctx[3].year;

    			if (dirty & /*$$scope, id*/ 257) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty & /*id*/ 1) link1_changes.to = "artists/" + /*album*/ ctx[3].artist.id;

    			if (dirty & /*$$scope, id*/ 257) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			if ((!current || dirty & /*id*/ 1) && t6_value !== (t6_value = formatTotalTime(/*album*/ ctx[3].time) + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*id*/ 1) && t8_value !== (t8_value = /*album*/ ctx[3].songcount + "")) set_data_dev(t8, t8_value);

    			if ((!current || dirty & /*id*/ 1) && t10_value !== (t10_value = (parseInt(/*album*/ ctx[3].songcount) === 1
    			? "song"
    			: "songs") + "")) set_data_dev(t10, t10_value);

    			if (/*album*/ ctx[3].genre.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*id*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$a(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t12);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const rating_changes = {};
    			if (dirty & /*id*/ 1) rating_changes.id = /*album*/ ctx[3].id;
    			if (dirty & /*id*/ 1) rating_changes.rating = /*album*/ ctx[3].rating;
    			if (dirty & /*id*/ 1) rating_changes.flag = /*album*/ ctx[3].flag;
    			if (dirty & /*id*/ 1) rating_changes.averageRating = /*album*/ ctx[3].averagerating;
    			rating.$set(rating_changes);
    			const thirdpartyservices_changes = {};
    			if (dirty & /*id*/ 1) thirdpartyservices_changes.data = /*album*/ ctx[3];
    			thirdpartyservices.$set(thirdpartyservices_changes);
    			const actions_changes = {};
    			if (dirty & /*id*/ 1) actions_changes.id = /*album*/ ctx[3].id;
    			if (dirty & /*id*/ 1) actions_changes.count = /*album*/ ctx[3].songcount;
    			if (dirty & /*id*/ 1) actions_changes.artistID = /*album*/ ctx[3].artist.id;
    			actions.$set(actions_changes);
    			const albumsongs_changes = {};
    			if (dirty & /*id*/ 1) albumsongs_changes.id = /*album*/ ctx[3].id;
    			albumsongs.$set(albumsongs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);

    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, fade, {});
    					img_intro.start();
    				});
    			}

    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(rating.$$.fragment, local);
    			transition_in(thirdpartyservices.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			transition_in(albumsongs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(rating.$$.fragment, local);
    			transition_out(thirdpartyservices.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			transition_out(albumsongs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div7);
    			destroy_component(link0);
    			destroy_component(link1);
    			if (if_block1) if_block1.d();
    			destroy_component(rating);
    			destroy_component(thirdpartyservices);
    			destroy_component(actions);
    			destroy_component(albumsongs);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(28:4) {#if album.id}",
    		ctx
    	});

    	return block;
    }

    // (29:8) {#if album.useBackground && !$ThemeIsLight}
    function create_if_block_2$9(ctx) {
    	let img;
    	let img_src_value;
    	let img_intro;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "art-background");
    			if (img.src !== (img_src_value = "" + (/*album*/ ctx[3].art + "&thumb=10"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "loading", "lazy");
    			add_location(img, file$l, 29, 12, 950);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 1 && img.src !== (img_src_value = "" + (/*album*/ ctx[3].art + "&thumb=10"))) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		i: function intro(local) {
    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, fade, {});
    					img_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(29:8) {#if album.useBackground && !$ThemeIsLight}",
    		ctx
    	});

    	return block;
    }

    // (43:47) <Link to="albums/year/{album.year}">
    function create_default_slot_2$3(ctx) {
    	let svgyear;
    	let t0;
    	let t1_value = /*album*/ ctx[3].year + "";
    	let t1;
    	let current;

    	svgyear = new Year({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgyear.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgyear, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*album*/ ctx[3].year + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgyear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgyear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgyear, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(43:47) <Link to=\\\"albums/year/{album.year}\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:28) <Link to="artists/{album.artist.id}">
    function create_default_slot_1$4(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*album*/ ctx[3].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*album*/ ctx[3].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(44:28) <Link to=\\\"artists/{album.artist.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (52:24) {#if album.genre.length > 0}
    function create_if_block_1$a(ctx) {
    	let ul;
    	let current;
    	let each_value = /*album*/ ctx[3].genre;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "genres svelte-1wxh02i");
    			add_location(ul, file$l, 52, 28, 2160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getAlbum, id*/ 1) {
    				each_value = /*album*/ ctx[3].genre;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(52:24) {#if album.genre.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (55:40) <Link to="genres/{genre.id}">
    function create_default_slot$b(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[4].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*id*/ 1) && t1_value !== (t1_value = /*genre*/ ctx[4].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(55:40) <Link to=\\\"genres/{genre.id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:32) {#each album.genre as genre}
    function create_each_block$4(ctx) {
    	let li;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "genres/" + /*genre*/ ctx[4].id,
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			add_location(li, file$l, 54, 36, 2279);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*id*/ 1) link_changes.to = "genres/" + /*genre*/ ctx[4].id;

    			if (dirty & /*$$scope, id*/ 257) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(54:32) {#each album.genre as genre}",
    		ctx
    	});

    	return block;
    }

    // (25:21)       <p>Loading album</p>  {:then album}
    function create_pending_block$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading album";
    			add_location(p, file$l, 25, 4, 828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$3.name,
    		type: "pending",
    		source: "(25:21)       <p>Loading album</p>  {:then album}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$3,
    		then: create_then_block$3,
    		catch: create_catch_block$3,
    		value: 3,
    		error: 7,
    		blocks: [,,,]
    	};

    	handle_promise(promise = getAlbum(/*id*/ ctx[0]), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*id*/ 1 && promise !== (promise = getAlbum(/*id*/ ctx[0])) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $ThemeIsLight;
    	validate_store(ThemeIsLight, "ThemeIsLight");
    	component_subscribe($$self, ThemeIsLight, $$value => $$invalidate(1, $ThemeIsLight = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Album", slots, []);
    	let { id } = $$props;
    	let theme;
    	const writable_props = ["id"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Album> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Link,
    		ThemeIsLight,
    		getAlbum,
    		formatTotalTime,
    		AlbumSongs,
    		Rating,
    		ThirdPartyServices,
    		Actions,
    		SVGArtist: Artist$1,
    		SVGYear: Year,
    		SVGGenre: Label,
    		id,
    		theme,
    		$ThemeIsLight
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("theme" in $$props) theme = $$props.theme;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ThemeIsLight*/ 2) {
    			theme = $ThemeIsLight ? "light" : "dark";
    		}
    	};

    	return [id, $ThemeIsLight];
    }

    class Album extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Album",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<Album> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<Album>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Album>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\playlists\playlist_delete.svelte generated by Svelte v3.38.3 */
    const file$k = "src\\components\\playlists\\playlist_delete.svelte";

    function create_fragment$k(ctx) {
    	let div1;
    	let h4;
    	let t1;
    	let p;
    	let em;
    	let t2_value = /*playlist*/ ctx[0].name + "";
    	let t2;
    	let t3;
    	let t4;
    	let div0;
    	let button0;
    	let t6;
    	let button1;
    	let svgbin;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	svgbin = new Delete({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Confirm playlist removal";
    			t1 = space();
    			p = element("p");
    			em = element("em");
    			t2 = text(t2_value);
    			t3 = text(" will be deleted");
    			t4 = space();
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t6 = space();
    			button1 = element("button");
    			create_component(svgbin.$$.fragment);
    			t7 = text(" Delete");
    			attr_dev(h4, "class", "svelte-1tom5yz");
    			add_location(h4, file$k, 21, 4, 477);
    			add_location(em, file$k, 23, 7, 521);
    			attr_dev(p, "class", "svelte-1tom5yz");
    			add_location(p, file$k, 23, 4, 518);
    			attr_dev(button0, "class", "");
    			add_location(button0, file$k, 26, 8, 604);
    			attr_dev(button1, "class", "with-icon danger");
    			add_location(button1, file$k, 27, 8, 670);
    			attr_dev(div0, "class", "actions svelte-1tom5yz");
    			add_location(div0, file$k, 25, 4, 573);
    			attr_dev(div1, "class", "container svelte-1tom5yz");
    			add_location(div1, file$k, 20, 0, 448);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			append_dev(div1, t1);
    			append_dev(div1, p);
    			append_dev(p, em);
    			append_dev(em, t2);
    			append_dev(p, t3);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t6);
    			append_dev(div0, button1);
    			mount_component(svgbin, button1, null);
    			append_dev(button1, t7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleCancel*/ ctx[2], false, false, false),
    					listen_dev(button1, "click", /*handleDelete*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*playlist*/ 1) && t2_value !== (t2_value = /*playlist*/ ctx[0].name + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgbin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgbin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(svgbin);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlist_delete", slots, []);
    	let { playlist = null } = $$props;
    	let { isVisible } = $$props;

    	function handleDelete() {
    		deletePlaylist(playlist.id);
    		$$invalidate(0, playlist.isDeleted = true, playlist);
    		$$invalidate(0, playlist);
    		$$invalidate(3, isVisible = false);
    	}

    	function handleCancel() {
    		$$invalidate(3, isVisible = false);
    	}

    	const writable_props = ["playlist", "isVisible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlist_delete> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("playlist" in $$props) $$invalidate(0, playlist = $$props.playlist);
    		if ("isVisible" in $$props) $$invalidate(3, isVisible = $$props.isVisible);
    	};

    	$$self.$capture_state = () => ({
    		deletePlaylist,
    		SVGBin: Delete,
    		playlist,
    		isVisible,
    		handleDelete,
    		handleCancel
    	});

    	$$self.$inject_state = $$props => {
    		if ("playlist" in $$props) $$invalidate(0, playlist = $$props.playlist);
    		if ("isVisible" in $$props) $$invalidate(3, isVisible = $$props.isVisible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [playlist, handleDelete, handleCancel, isVisible];
    }

    class Playlist_delete extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { playlist: 0, isVisible: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlist_delete",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isVisible*/ ctx[3] === undefined && !("isVisible" in props)) {
    			console.warn("<Playlist_delete> was created without expected prop 'isVisible'");
    		}
    	}

    	get playlist() {
    		throw new Error("<Playlist_delete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playlist(value) {
    		throw new Error("<Playlist_delete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVisible() {
    		throw new Error("<Playlist_delete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVisible(value) {
    		throw new Error("<Playlist_delete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\playlistCard.svelte generated by Svelte v3.38.3 */
    const file$j = "src\\components\\playlistCard.svelte";

    // (86:4) {:else}
    function create_else_block$b(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let br0;
    	let t2;
    	let div2;
    	let br1;
    	let t3;
    	let rating;
    	let t4;
    	let div3;
    	let actions;
    	let current;
    	rating = new Rating({ $$inline: true });

    	actions = new Actions({
    			props: { type: "playlist", mode: "miniButtons" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Loading";
    			t1 = space();
    			div1 = element("div");
    			br0 = element("br");
    			t2 = space();
    			div2 = element("div");
    			br1 = element("br");
    			t3 = space();
    			create_component(rating.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(div0, "class", "title svelte-z86tij");
    			add_location(div0, file$j, 86, 8, 3223);
    			add_location(br0, file$j, 91, 12, 3324);
    			attr_dev(div1, "class", "owner svelte-z86tij");
    			add_location(div1, file$j, 90, 8, 3291);
    			add_location(br1, file$j, 95, 12, 3389);
    			attr_dev(div2, "class", "count svelte-z86tij");
    			add_location(div2, file$j, 94, 8, 3356);
    			attr_dev(div3, "class", "actions svelte-z86tij");
    			add_location(div3, file$j, 100, 8, 3443);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, br0);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, br1);
    			insert_dev(target, t3, anchor);
    			mount_component(rating, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(actions, div3, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t3);
    			destroy_component(rating, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div3);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(86:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:4) {#if playlist}
    function create_if_block$d(ctx) {
    	let div0;
    	let link;
    	let t0;
    	let div1;
    	let t1;
    	let t2_value = /*playlist*/ ctx[0].owner + "";
    	let t2;
    	let t3;
    	let div2;
    	let t4_value = /*playlist*/ ctx[0].items + "";
    	let t4;
    	let t5;

    	let t6_value = (parseInt(/*playlist*/ ctx[0].items) === 1
    	? "song"
    	: "songs") + "";

    	let t6;
    	let t7;
    	let t8_value = /*playlist*/ ctx[0].type[0].toUpperCase() + /*playlist*/ ctx[0].type.substring(1) + "";
    	let t8;
    	let t9;
    	let rating;
    	let t10;
    	let div3;
    	let actions;
    	let t11;
    	let button;
    	let svgmore;
    	let button_id_value;
    	let t12;
    	let t13;
    	let t14;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	link = new Link({
    			props: {
    				to: "playlists/" + /*playlist*/ ctx[0].id,
    				title: /*playlist*/ ctx[0].name,
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	rating = new Rating({
    			props: {
    				type: "playlist",
    				id: /*playlist*/ ctx[0].id,
    				rating: /*playlist*/ ctx[0].rating,
    				flag: /*playlist*/ ctx[0].flag,
    				averageRating: /*playlist*/ ctx[0].averagerating
    			},
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				type: "playlist",
    				mode: "miniButtons",
    				id: /*playlist*/ ctx[0].id,
    				count: /*playlist*/ ctx[0].items
    			},
    			$$inline: true
    		});

    	svgmore = new MoreHori({ $$inline: true });
    	let if_block0 = /*showPlaylistMore*/ ctx[2] && create_if_block_3$4(ctx);
    	let if_block1 = /*showPlaylistEdit*/ ctx[1] && create_if_block_2$8(ctx);
    	let if_block2 = /*showPlaylistDelete*/ ctx[3] && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(link.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text("by ");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = text(" • ");
    			t8 = text(t8_value);
    			t9 = space();
    			create_component(rating.$$.fragment);
    			t10 = space();
    			div3 = element("div");
    			create_component(actions.$$.fragment);
    			t11 = space();
    			button = element("button");
    			create_component(svgmore.$$.fragment);
    			t12 = space();
    			if (if_block0) if_block0.c();
    			t13 = space();
    			if (if_block1) if_block1.c();
    			t14 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(div0, "class", "title svelte-z86tij");
    			add_location(div0, file$j, 36, 8, 977);
    			attr_dev(div1, "class", "owner svelte-z86tij");
    			add_location(div1, file$j, 40, 8, 1119);
    			attr_dev(div2, "class", "count svelte-z86tij");
    			add_location(div2, file$j, 44, 8, 1199);
    			attr_dev(div3, "class", "actions svelte-z86tij");
    			add_location(div3, file$j, 50, 8, 1545);
    			attr_dev(button, "id", button_id_value = "playlistMoreToggle-" + /*playlist*/ ctx[0].id);
    			attr_dev(button, "class", "icon more svelte-z86tij");
    			add_location(button, file$j, 59, 8, 1779);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(link, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t1);
    			append_dev(div1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, t4);
    			append_dev(div2, t5);
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div2, t8);
    			insert_dev(target, t9, anchor);
    			mount_component(rating, target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(actions, div3, null);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, button, anchor);
    			mount_component(svgmore, button, null);
    			insert_dev(target, t12, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t13, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t14, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*handleMenu*/ ctx[4]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*playlist*/ 1) link_changes.to = "playlists/" + /*playlist*/ ctx[0].id;
    			if (dirty & /*playlist*/ 1) link_changes.title = /*playlist*/ ctx[0].name;

    			if (dirty & /*$$scope, playlist*/ 16385) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    			if ((!current || dirty & /*playlist*/ 1) && t2_value !== (t2_value = /*playlist*/ ctx[0].owner + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*playlist*/ 1) && t4_value !== (t4_value = /*playlist*/ ctx[0].items + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*playlist*/ 1) && t6_value !== (t6_value = (parseInt(/*playlist*/ ctx[0].items) === 1
    			? "song"
    			: "songs") + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty & /*playlist*/ 1) && t8_value !== (t8_value = /*playlist*/ ctx[0].type[0].toUpperCase() + /*playlist*/ ctx[0].type.substring(1) + "")) set_data_dev(t8, t8_value);
    			const rating_changes = {};
    			if (dirty & /*playlist*/ 1) rating_changes.id = /*playlist*/ ctx[0].id;
    			if (dirty & /*playlist*/ 1) rating_changes.rating = /*playlist*/ ctx[0].rating;
    			if (dirty & /*playlist*/ 1) rating_changes.flag = /*playlist*/ ctx[0].flag;
    			if (dirty & /*playlist*/ 1) rating_changes.averageRating = /*playlist*/ ctx[0].averagerating;
    			rating.$set(rating_changes);
    			const actions_changes = {};
    			if (dirty & /*playlist*/ 1) actions_changes.id = /*playlist*/ ctx[0].id;
    			if (dirty & /*playlist*/ 1) actions_changes.count = /*playlist*/ ctx[0].items;
    			actions.$set(actions_changes);

    			if (!current || dirty & /*playlist*/ 1 && button_id_value !== (button_id_value = "playlistMoreToggle-" + /*playlist*/ ctx[0].id)) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (/*showPlaylistMore*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showPlaylistMore*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t13.parentNode, t13);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showPlaylistEdit*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showPlaylistEdit*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t14.parentNode, t14);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showPlaylistDelete*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*showPlaylistDelete*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(rating.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			transition_in(svgmore.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(rating.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			transition_out(svgmore.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t9);
    			destroy_component(rating, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div3);
    			destroy_component(actions);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(button);
    			destroy_component(svgmore);
    			if (detaching) detach_dev(t12);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t13);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t14);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(36:4) {#if playlist}",
    		ctx
    	});

    	return block;
    }

    // (38:12) <Link to="playlists/{playlist.id}" title="{playlist.name}">
    function create_default_slot_3$2(ctx) {
    	let t_value = /*playlist*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*playlist*/ 1 && t_value !== (t_value = /*playlist*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(38:12) <Link to=\\\"playlists/{playlist.id}\\\" title=\\\"{playlist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:8) {#if showPlaylistMore}
    function create_if_block_3$4(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[7](value);
    	}

    	let menu_props = {
    		anchor: "bottom-right",
    		toggleElement: document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id),
    		$$slots: { default: [create_default_slot_2$2] },
    		$$scope: { ctx }
    	};

    	if (/*showPlaylistMore*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*showPlaylistMore*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*playlist*/ 1) menu_changes.toggleElement = document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id);

    			if (dirty & /*$$scope, playlist*/ 16385) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistMore*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*showPlaylistMore*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(62:8) {#if showPlaylistMore}",
    		ctx
    	});

    	return block;
    }

    // (63:12) <Menu anchor="bottom-right" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistMore} >
    function create_default_slot_2$2(ctx) {
    	let ul;
    	let li0;
    	let button0;
    	let t0;
    	let button0_id_value;
    	let t1;
    	let li1;
    	let button1;
    	let t2;
    	let button1_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			button0 = element("button");
    			t0 = text("Edit");
    			t1 = space();
    			li1 = element("li");
    			button1 = element("button");
    			t2 = text("Delete");
    			attr_dev(button0, "class", "visuallyLink");
    			attr_dev(button0, "id", button0_id_value = "playlistEditToggle-" + /*playlist*/ ctx[0].id);
    			add_location(button0, file$j, 65, 24, 2181);
    			add_location(li0, file$j, 64, 20, 2151);
    			attr_dev(button1, "class", "visuallyLink");
    			attr_dev(button1, "id", button1_id_value = "playlistDeleteToggle-" + /*playlist*/ ctx[0].id);
    			add_location(button1, file$j, 68, 24, 2362);
    			add_location(li1, file$j, 67, 20, 2332);
    			attr_dev(ul, "class", "menu-list");
    			add_location(ul, file$j, 63, 16, 2107);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, button0);
    			append_dev(button0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, button1);
    			append_dev(button1, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleEdit*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*handleDelete*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*playlist*/ 1 && button0_id_value !== (button0_id_value = "playlistEditToggle-" + /*playlist*/ ctx[0].id)) {
    				attr_dev(button0, "id", button0_id_value);
    			}

    			if (dirty & /*playlist*/ 1 && button1_id_value !== (button1_id_value = "playlistDeleteToggle-" + /*playlist*/ ctx[0].id)) {
    				attr_dev(button1, "id", button1_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(63:12) <Menu anchor=\\\"bottom-right\\\" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistMore} >",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#if showPlaylistEdit}
    function create_if_block_2$8(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_1(value) {
    		/*menu_isVisible_binding_1*/ ctx[10](value);
    	}

    	let menu_props = {
    		anchor: "bottom-center",
    		toggleElement: document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id),
    		$$slots: { default: [create_default_slot_1$3] },
    		$$scope: { ctx }
    	};

    	if (/*showPlaylistEdit*/ ctx[1] !== void 0) {
    		menu_props.isVisible = /*showPlaylistEdit*/ ctx[1];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_1));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*playlist*/ 1) menu_changes.toggleElement = document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id);

    			if (dirty & /*$$scope, playlist, showPlaylistEdit*/ 16387) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistEdit*/ 2) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*showPlaylistEdit*/ ctx[1];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(75:8) {#if showPlaylistEdit}",
    		ctx
    	});

    	return block;
    }

    // (76:12) <Menu anchor="bottom-center" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistEdit} >
    function create_default_slot_1$3(ctx) {
    	let playlistedit;
    	let updating_playlist;
    	let updating_isVisible;
    	let current;

    	function playlistedit_playlist_binding(value) {
    		/*playlistedit_playlist_binding*/ ctx[8](value);
    	}

    	function playlistedit_isVisible_binding(value) {
    		/*playlistedit_isVisible_binding*/ ctx[9](value);
    	}

    	let playlistedit_props = {};

    	if (/*playlist*/ ctx[0] !== void 0) {
    		playlistedit_props.playlist = /*playlist*/ ctx[0];
    	}

    	if (/*showPlaylistEdit*/ ctx[1] !== void 0) {
    		playlistedit_props.isVisible = /*showPlaylistEdit*/ ctx[1];
    	}

    	playlistedit = new Playlist_edit({
    			props: playlistedit_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistedit, "playlist", playlistedit_playlist_binding));
    	binding_callbacks.push(() => bind(playlistedit, "isVisible", playlistedit_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(playlistedit.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistedit, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistedit_changes = {};

    			if (!updating_playlist && dirty & /*playlist*/ 1) {
    				updating_playlist = true;
    				playlistedit_changes.playlist = /*playlist*/ ctx[0];
    				add_flush_callback(() => updating_playlist = false);
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistEdit*/ 2) {
    				updating_isVisible = true;
    				playlistedit_changes.isVisible = /*showPlaylistEdit*/ ctx[1];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			playlistedit.$set(playlistedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(76:12) <Menu anchor=\\\"bottom-center\\\" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistEdit} >",
    		ctx
    	});

    	return block;
    }

    // (81:8) {#if showPlaylistDelete}
    function create_if_block_1$9(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding_2(value) {
    		/*menu_isVisible_binding_2*/ ctx[13](value);
    	}

    	let menu_props = {
    		anchor: "bottom-center",
    		toggleElement: document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id),
    		$$slots: { default: [create_default_slot$a] },
    		$$scope: { ctx }
    	};

    	if (/*showPlaylistDelete*/ ctx[3] !== void 0) {
    		menu_props.isVisible = /*showPlaylistDelete*/ ctx[3];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding_2));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*playlist*/ 1) menu_changes.toggleElement = document.querySelector("#playlistMoreToggle-" + /*playlist*/ ctx[0].id);

    			if (dirty & /*$$scope, playlist, showPlaylistDelete*/ 16393) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistDelete*/ 8) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*showPlaylistDelete*/ ctx[3];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(81:8) {#if showPlaylistDelete}",
    		ctx
    	});

    	return block;
    }

    // (82:12) <Menu anchor="bottom-center" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistDelete} >
    function create_default_slot$a(ctx) {
    	let playlistdelete;
    	let updating_playlist;
    	let updating_isVisible;
    	let current;

    	function playlistdelete_playlist_binding(value) {
    		/*playlistdelete_playlist_binding*/ ctx[11](value);
    	}

    	function playlistdelete_isVisible_binding(value) {
    		/*playlistdelete_isVisible_binding*/ ctx[12](value);
    	}

    	let playlistdelete_props = {};

    	if (/*playlist*/ ctx[0] !== void 0) {
    		playlistdelete_props.playlist = /*playlist*/ ctx[0];
    	}

    	if (/*showPlaylistDelete*/ ctx[3] !== void 0) {
    		playlistdelete_props.isVisible = /*showPlaylistDelete*/ ctx[3];
    	}

    	playlistdelete = new Playlist_delete({
    			props: playlistdelete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistdelete, "playlist", playlistdelete_playlist_binding));
    	binding_callbacks.push(() => bind(playlistdelete, "isVisible", playlistdelete_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(playlistdelete.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistdelete, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistdelete_changes = {};

    			if (!updating_playlist && dirty & /*playlist*/ 1) {
    				updating_playlist = true;
    				playlistdelete_changes.playlist = /*playlist*/ ctx[0];
    				add_flush_callback(() => updating_playlist = false);
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistDelete*/ 8) {
    				updating_isVisible = true;
    				playlistdelete_changes.isVisible = /*showPlaylistDelete*/ ctx[3];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			playlistdelete.$set(playlistdelete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistdelete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistdelete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistdelete, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(82:12) <Menu anchor=\\\"bottom-center\\\" toggleElement={document.querySelector('#playlistMoreToggle-' + playlist.id)} bind:isVisible={showPlaylistDelete} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$d, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*playlist*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "playlist-card svelte-z86tij");
    			add_location(div, file$j, 34, 0, 920);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PlaylistCard", slots, []);
    	let { playlist = null } = $$props;
    	let showPlaylistEdit = false;
    	let showPlaylistMore = false;
    	let showPlaylistDelete = false;

    	function handleMenu() {
    		$$invalidate(2, showPlaylistMore = !showPlaylistMore);
    	}

    	function handleEdit() {
    		$$invalidate(1, showPlaylistEdit = !showPlaylistEdit);
    		handleMenu();
    	}

    	async function handleDelete() {
    		$$invalidate(3, showPlaylistDelete = !showPlaylistDelete);
    		handleMenu();
    	}

    	const writable_props = ["playlist"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PlaylistCard> was created with unknown prop '${key}'`);
    	});

    	function menu_isVisible_binding(value) {
    		showPlaylistMore = value;
    		$$invalidate(2, showPlaylistMore);
    	}

    	function playlistedit_playlist_binding(value) {
    		playlist = value;
    		$$invalidate(0, playlist);
    	}

    	function playlistedit_isVisible_binding(value) {
    		showPlaylistEdit = value;
    		$$invalidate(1, showPlaylistEdit);
    	}

    	function menu_isVisible_binding_1(value) {
    		showPlaylistEdit = value;
    		$$invalidate(1, showPlaylistEdit);
    	}

    	function playlistdelete_playlist_binding(value) {
    		playlist = value;
    		$$invalidate(0, playlist);
    	}

    	function playlistdelete_isVisible_binding(value) {
    		showPlaylistDelete = value;
    		$$invalidate(3, showPlaylistDelete);
    	}

    	function menu_isVisible_binding_2(value) {
    		showPlaylistDelete = value;
    		$$invalidate(3, showPlaylistDelete);
    	}

    	$$self.$$set = $$props => {
    		if ("playlist" in $$props) $$invalidate(0, playlist = $$props.playlist);
    	};

    	$$self.$capture_state = () => ({
    		Link,
    		Rating,
    		Actions,
    		Menu,
    		PlaylistEdit: Playlist_edit,
    		PlaylistDelete: Playlist_delete,
    		SVGMore: MoreHori,
    		playlist,
    		showPlaylistEdit,
    		showPlaylistMore,
    		showPlaylistDelete,
    		handleMenu,
    		handleEdit,
    		handleDelete
    	});

    	$$self.$inject_state = $$props => {
    		if ("playlist" in $$props) $$invalidate(0, playlist = $$props.playlist);
    		if ("showPlaylistEdit" in $$props) $$invalidate(1, showPlaylistEdit = $$props.showPlaylistEdit);
    		if ("showPlaylistMore" in $$props) $$invalidate(2, showPlaylistMore = $$props.showPlaylistMore);
    		if ("showPlaylistDelete" in $$props) $$invalidate(3, showPlaylistDelete = $$props.showPlaylistDelete);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*playlist*/ 1) {
    			$$invalidate(0, playlist);
    		}
    	};

    	return [
    		playlist,
    		showPlaylistEdit,
    		showPlaylistMore,
    		showPlaylistDelete,
    		handleMenu,
    		handleEdit,
    		handleDelete,
    		menu_isVisible_binding,
    		playlistedit_playlist_binding,
    		playlistedit_isVisible_binding,
    		menu_isVisible_binding_1,
    		playlistdelete_playlist_binding,
    		playlistdelete_isVisible_binding,
    		menu_isVisible_binding_2
    	];
    }

    class PlaylistCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { playlist: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlaylistCard",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get playlist() {
    		throw new Error("<PlaylistCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playlist(value) {
    		throw new Error("<PlaylistCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var playlistCard = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': PlaylistCard
    });

    /* src\views\playlists.svelte generated by Svelte v3.38.3 */
    const file$i = "src\\views\\playlists.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[12] = list;
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (48:0) {#if showPlaylistCreation}
    function create_if_block_2$7(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[9](value);
    	}

    	let menu_props = {
    		anchor: "right-top",
    		toggleElement: /*playlistsNewToggle*/ ctx[4],
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	if (/*showPlaylistCreation*/ ctx[2] !== void 0) {
    		menu_props.isVisible = /*showPlaylistCreation*/ ctx[2];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*playlistsNewToggle*/ 16) menu_changes.toggleElement = /*playlistsNewToggle*/ ctx[4];

    			if (dirty & /*$$scope, newPlaylist, showPlaylistCreation*/ 16389) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistCreation*/ 4) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*showPlaylistCreation*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(48:0) {#if showPlaylistCreation}",
    		ctx
    	});

    	return block;
    }

    // (49:4) <Menu anchor="right-top" toggleElement={playlistsNewToggle} bind:isVisible={showPlaylistCreation} >
    function create_default_slot$9(ctx) {
    	let playlistedit;
    	let updating_playlist;
    	let updating_isVisible;
    	let current;

    	function playlistedit_playlist_binding(value) {
    		/*playlistedit_playlist_binding*/ ctx[7](value);
    	}

    	function playlistedit_isVisible_binding(value) {
    		/*playlistedit_isVisible_binding*/ ctx[8](value);
    	}

    	let playlistedit_props = { isNew: true };

    	if (/*newPlaylist*/ ctx[0] !== void 0) {
    		playlistedit_props.playlist = /*newPlaylist*/ ctx[0];
    	}

    	if (/*showPlaylistCreation*/ ctx[2] !== void 0) {
    		playlistedit_props.isVisible = /*showPlaylistCreation*/ ctx[2];
    	}

    	playlistedit = new Playlist_edit({
    			props: playlistedit_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistedit, "playlist", playlistedit_playlist_binding));
    	binding_callbacks.push(() => bind(playlistedit, "isVisible", playlistedit_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(playlistedit.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistedit, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistedit_changes = {};

    			if (!updating_playlist && dirty & /*newPlaylist*/ 1) {
    				updating_playlist = true;
    				playlistedit_changes.playlist = /*newPlaylist*/ ctx[0];
    				add_flush_callback(() => updating_playlist = false);
    			}

    			if (!updating_isVisible && dirty & /*showPlaylistCreation*/ 4) {
    				updating_isVisible = true;
    				playlistedit_changes.isVisible = /*showPlaylistCreation*/ ctx[2];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			playlistedit.$set(playlistedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(49:4) <Menu anchor=\\\"right-top\\\" toggleElement={playlistsNewToggle} bind:isVisible={showPlaylistCreation} >",
    		ctx
    	});

    	return block;
    }

    // (65:4) {:else}
    function create_else_block$a(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No playlists found";
    			add_location(p, file$i, 65, 8, 1907);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(65:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (57:4) {#if playlists && playlists.length > 0}
    function create_if_block_1$8(ctx) {
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let ul_intro;
    	let current;
    	let each_value = /*playlists*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*playlist*/ ctx[11].id;
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "playlist-grid");
    			add_location(ul, file$i, 57, 8, 1583);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*playlists*/ 2) {
    				each_value = /*playlists*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			if (!ul_intro) {
    				add_render_callback(() => {
    					ul_intro = create_in_transition(ul, fade, {});
    					ul_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(57:4) {#if playlists && playlists.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (54:0) {#if loading}
    function create_if_block$c(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading playlists";
    			add_location(p, file$i, 54, 4, 1495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(54:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (59:12) {#each playlists as playlist (playlist.id)}
    function create_each_block$3(key_1, ctx) {
    	let li;
    	let playlistcard;
    	let updating_playlist;
    	let t;
    	let current;

    	function playlistcard_playlist_binding(value) {
    		/*playlistcard_playlist_binding*/ ctx[10](value, /*playlist*/ ctx[11], /*each_value*/ ctx[12], /*playlist_index*/ ctx[13]);
    	}

    	let playlistcard_props = {};

    	if (/*playlist*/ ctx[11] !== void 0) {
    		playlistcard_props.playlist = /*playlist*/ ctx[11];
    	}

    	playlistcard = new PlaylistCard({
    			props: playlistcard_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(playlistcard, "playlist", playlistcard_playlist_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			create_component(playlistcard.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-knicoi");
    			toggle_class(li, "highlight", /*playlist*/ ctx[11].isNew);
    			toggle_class(li, "hide", /*playlist*/ ctx[11].isDeleted);
    			add_location(li, file$i, 59, 16, 1692);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(playlistcard, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const playlistcard_changes = {};

    			if (!updating_playlist && dirty & /*playlists*/ 2) {
    				updating_playlist = true;
    				playlistcard_changes.playlist = /*playlist*/ ctx[11];
    				add_flush_callback(() => updating_playlist = false);
    			}

    			playlistcard.$set(playlistcard_changes);

    			if (dirty & /*playlists*/ 2) {
    				toggle_class(li, "highlight", /*playlist*/ ctx[11].isNew);
    			}

    			if (dirty & /*playlists*/ 2) {
    				toggle_class(li, "hide", /*playlist*/ ctx[11].isDeleted);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(playlistcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(59:12) {#each playlists as playlist (playlist.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let h1;
    	let t1;
    	let button;
    	let t3;
    	let t4;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*showPlaylistCreation*/ ctx[2] && create_if_block_2$7(ctx);
    	const if_block_creators = [create_if_block$c, create_if_block_1$8, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[3]) return 0;
    		if (/*playlists*/ ctx[1] && /*playlists*/ ctx[1].length > 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Playlists";
    			t1 = space();
    			button = element("button");
    			button.textContent = "New playlist";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			add_location(h1, file$i, 43, 0, 1056);
    			attr_dev(button, "id", "js-playlistsNew");
    			attr_dev(button, "class", "primary");
    			add_location(button, file$i, 45, 0, 1078);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);
    			/*button_binding*/ ctx[6](button);
    			insert_dev(target, t3, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShowPlaylistCreator*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showPlaylistCreation*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showPlaylistCreation*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t4.parentNode, t4);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[6](null);
    			if (detaching) detach_dev(t3);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t4);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlists", slots, []);
    	let newPlaylist;
    	let playlists = [];
    	let showPlaylistCreation = false;
    	let loading = true;
    	let playlistsNewToggle;

    	function handleShowPlaylistCreator() {
    		$$invalidate(2, showPlaylistCreation = !showPlaylistCreation);
    	}

    	onMount(async () => {
    		$$invalidate(1, playlists = await getPlaylists());
    		$$invalidate(3, loading = false);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlists> was created with unknown prop '${key}'`);
    	});

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			playlistsNewToggle = $$value;
    			$$invalidate(4, playlistsNewToggle);
    		});
    	}

    	function playlistedit_playlist_binding(value) {
    		newPlaylist = value;
    		($$invalidate(0, newPlaylist), $$invalidate(1, playlists));
    	}

    	function playlistedit_isVisible_binding(value) {
    		showPlaylistCreation = value;
    		(($$invalidate(2, showPlaylistCreation), $$invalidate(0, newPlaylist)), $$invalidate(1, playlists));
    	}

    	function menu_isVisible_binding(value) {
    		showPlaylistCreation = value;
    		(($$invalidate(2, showPlaylistCreation), $$invalidate(0, newPlaylist)), $$invalidate(1, playlists));
    	}

    	function playlistcard_playlist_binding(value, playlist, each_value, playlist_index) {
    		each_value[playlist_index] = value;
    		($$invalidate(1, playlists), $$invalidate(0, newPlaylist));
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		getPlaylists,
    		PlaylistEdit: Playlist_edit,
    		PlaylistCard,
    		Menu,
    		newPlaylist,
    		playlists,
    		showPlaylistCreation,
    		loading,
    		playlistsNewToggle,
    		handleShowPlaylistCreator
    	});

    	$$self.$inject_state = $$props => {
    		if ("newPlaylist" in $$props) $$invalidate(0, newPlaylist = $$props.newPlaylist);
    		if ("playlists" in $$props) $$invalidate(1, playlists = $$props.playlists);
    		if ("showPlaylistCreation" in $$props) $$invalidate(2, showPlaylistCreation = $$props.showPlaylistCreation);
    		if ("loading" in $$props) $$invalidate(3, loading = $$props.loading);
    		if ("playlistsNewToggle" in $$props) $$invalidate(4, playlistsNewToggle = $$props.playlistsNewToggle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*newPlaylist, playlists*/ 3) {
    			{
    				if (newPlaylist) {
    					$$invalidate(0, newPlaylist.isNew = true, newPlaylist);
    					$$invalidate(1, playlists = [newPlaylist, ...playlists]);

    					// reset
    					$$invalidate(0, newPlaylist = null);

    					$$invalidate(2, showPlaylistCreation = false);
    				}

    				($$invalidate(1, playlists), $$invalidate(0, newPlaylist));
    			}
    		}
    	};

    	return [
    		newPlaylist,
    		playlists,
    		showPlaylistCreation,
    		loading,
    		playlistsNewToggle,
    		handleShowPlaylistCreator,
    		button_binding,
    		playlistedit_playlist_binding,
    		playlistedit_isVisible_binding,
    		menu_isVisible_binding,
    		playlistcard_playlist_binding
    	];
    }

    class Playlists extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlists",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src\views\playlist.svelte generated by Svelte v3.38.3 */
    const file$h = "src\\views\\playlist.svelte";

    // (97:4) {:else}
    function create_else_block_1$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find playlist with that ID";
    			add_location(p, file$h, 97, 8, 3320);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(97:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if playlist.id}
    function create_if_block_1$7(ctx) {
    	let div6;
    	let div4;
    	let div3;
    	let div0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_intro;
    	let t0;
    	let div2;
    	let h1;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let t2_value = /*playlist*/ ctx[1].name + "";
    	let t2;
    	let t3;
    	let t4;
    	let p;
    	let t5;
    	let t6;
    	let t7_value = (parseInt(/*songCount*/ ctx[3]) === 1 ? "song" : "songs") + "";
    	let t7;
    	let t8;
    	let t9;
    	let div1;
    	let actions;
    	let t10;
    	let div5;
    	let previous_key = /*loadedTime*/ ctx[5];
    	let current;
    	const if_block_creators = [create_if_block_4$3, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isSmartlist*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*isSmartlist*/ ctx[4] && create_if_block_3$3(ctx);
    	let if_block2 = !/*isSmartlist*/ ctx[4] && create_if_block_2$6(ctx);

    	actions = new Actions({
    			props: {
    				type: "playlist",
    				mode: "fullButtons",
    				count: /*playlist*/ ctx[1].items,
    				direct: /*songs*/ ctx[0]
    			},
    			$$inline: true
    		});

    	let key_block = create_key_block$1(ctx);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div2 = element("div");
    			h1 = element("h1");
    			if_block0.c();
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			p = element("p");
    			t5 = text(/*songCount*/ ctx[3]);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = space();
    			if (if_block2) if_block2.c();
    			t9 = space();
    			div1 = element("div");
    			create_component(actions.$$.fragment);
    			t10 = space();
    			div5 = element("div");
    			key_block.c();
    			attr_dev(img, "class", "cover svelte-1dl0qxr");
    			if (img.src !== (img_src_value = "" + (/*playlist*/ ctx[1].art + "&thumb=32"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*playlist*/ ctx[1].name);
    			attr_dev(img, "width", "384");
    			attr_dev(img, "height", "384");
    			add_location(img, file$h, 52, 24, 1467);
    			attr_dev(div0, "class", "cover-container svelte-1dl0qxr");
    			add_location(div0, file$h, 51, 20, 1412);
    			attr_dev(h1, "class", "title svelte-1dl0qxr");
    			add_location(h1, file$h, 56, 24, 1677);
    			add_location(p, file$h, 70, 24, 2256);
    			attr_dev(div1, "class", "actions");
    			add_location(div1, file$h, 78, 24, 2648);
    			attr_dev(div2, "class", "info");
    			add_location(div2, file$h, 55, 20, 1633);
    			attr_dev(div3, "class", "details svelte-1dl0qxr");
    			add_location(div3, file$h, 50, 16, 1369);
    			attr_dev(div4, "class", "details-container svelte-1dl0qxr");
    			add_location(div4, file$h, 49, 12, 1320);
    			attr_dev(div5, "class", "songs svelte-1dl0qxr");
    			add_location(div5, file$h, 90, 12, 3066);
    			attr_dev(div6, "class", "container svelte-1dl0qxr");
    			add_location(div6, file$h, 48, 8, 1283);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, img);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, h1);
    			if_blocks[current_block_type_index].m(h1, null);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			append_dev(h1, t3);
    			if (if_block1) if_block1.m(h1, null);
    			append_dev(div2, t4);
    			append_dev(div2, p);
    			append_dev(p, t5);
    			append_dev(p, t6);
    			append_dev(p, t7);
    			append_dev(div2, t8);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			mount_component(actions, div1, null);
    			append_dev(div6, t10);
    			append_dev(div6, div5);
    			key_block.m(div5, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*playlist*/ 2 && img.src !== (img_src_value = "" + (/*playlist*/ ctx[1].art + "&thumb=32"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*playlist*/ 2 && img_alt_value !== (img_alt_value = "Image of " + /*playlist*/ ctx[1].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(h1, t1);
    			}

    			if ((!current || dirty & /*playlist*/ 2) && t2_value !== (t2_value = /*playlist*/ ctx[1].name + "")) set_data_dev(t2, t2_value);

    			if (/*isSmartlist*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isSmartlist*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(h1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*songCount*/ 8) set_data_dev(t5, /*songCount*/ ctx[3]);
    			if ((!current || dirty & /*songCount*/ 8) && t7_value !== (t7_value = (parseInt(/*songCount*/ ctx[3]) === 1 ? "song" : "songs") + "")) set_data_dev(t7, t7_value);

    			if (!/*isSmartlist*/ ctx[4]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isSmartlist*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t9);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const actions_changes = {};
    			if (dirty & /*playlist*/ 2) actions_changes.count = /*playlist*/ ctx[1].items;
    			if (dirty & /*songs*/ 1) actions_changes.direct = /*songs*/ ctx[0];
    			actions.$set(actions_changes);

    			if (dirty & /*loadedTime*/ 32 && safe_not_equal(previous_key, previous_key = /*loadedTime*/ ctx[5])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div5, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, fade, {});
    					img_intro.start();
    				});
    			}

    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(actions.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(actions.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_component(actions);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(48:4) {#if playlist.id}",
    		ctx
    	});

    	return block;
    }

    // (45:0) {#if loading}
    function create_if_block$b(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading playlist";
    			add_location(p, file$h, 45, 4, 1218);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(45:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (60:28) {:else}
    function create_else_block$9(ctx) {
    	let svgplaylist;
    	let current;

    	svgplaylist = new Queue_music({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgplaylist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgplaylist, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgplaylist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(60:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:28) {#if isSmartlist}
    function create_if_block_4$3(ctx) {
    	let svgsmartlist;
    	let current;

    	svgsmartlist = new Smartlist({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgsmartlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgsmartlist, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgsmartlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgsmartlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgsmartlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(58:28) {#if isSmartlist}",
    		ctx
    	});

    	return block;
    }

    // (66:28) {#if isSmartlist}
    function create_if_block_3$3(ctx) {
    	let button;
    	let svgrefresh;
    	let current;
    	let mounted;
    	let dispose;
    	svgrefresh = new Refresh({ $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(svgrefresh.$$.fragment);
    			attr_dev(button, "class", "with-icon refresh-button");
    			add_location(button, file$h, 66, 32, 2073);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(svgrefresh, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleSongLoad*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgrefresh.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgrefresh.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(svgrefresh);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(66:28) {#if isSmartlist}",
    		ctx
    	});

    	return block;
    }

    // (75:24) {#if !isSmartlist}
    function create_if_block_2$6(ctx) {
    	let rating;
    	let current;

    	rating = new Rating({
    			props: {
    				type: "playlist",
    				id: /*playlist*/ ctx[1].id,
    				rating: /*playlist*/ ctx[1].rating,
    				flag: /*playlist*/ ctx[1].flag,
    				averageRating: /*playlist*/ ctx[1].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rating.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rating, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rating_changes = {};
    			if (dirty & /*playlist*/ 2) rating_changes.id = /*playlist*/ ctx[1].id;
    			if (dirty & /*playlist*/ 2) rating_changes.rating = /*playlist*/ ctx[1].rating;
    			if (dirty & /*playlist*/ 2) rating_changes.flag = /*playlist*/ ctx[1].flag;
    			if (dirty & /*playlist*/ 2) rating_changes.averageRating = /*playlist*/ ctx[1].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rating, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(75:24) {#if !isSmartlist}",
    		ctx
    	});

    	return block;
    }

    // (92:16) {#key loadedTime}
    function create_key_block$1(ctx) {
    	let lister;
    	let updating_data;
    	let current;

    	function lister_data_binding(value) {
    		/*lister_data_binding*/ ctx[8](value);
    	}

    	let lister_props = {
    		type: /*isSmartlist*/ ctx[4] ? "smartlist" : "playlist",
    		id: /*playlist*/ ctx[1].id
    	};

    	if (/*songs*/ ctx[0] !== void 0) {
    		lister_props.data = /*songs*/ ctx[0];
    	}

    	lister = new Lister({ props: lister_props, $$inline: true });
    	binding_callbacks.push(() => bind(lister, "data", lister_data_binding));

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};
    			if (dirty & /*isSmartlist*/ 16) lister_changes.type = /*isSmartlist*/ ctx[4] ? "smartlist" : "playlist";
    			if (dirty & /*playlist*/ 2) lister_changes.id = /*playlist*/ ctx[1].id;

    			if (!updating_data && dirty & /*songs*/ 1) {
    				updating_data = true;
    				lister_changes.data = /*songs*/ ctx[0];
    				add_flush_callback(() => updating_data = false);
    			}

    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(92:16) {#key loadedTime}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_if_block_1$7, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[2]) return 0;
    		if (/*playlist*/ ctx[1].id) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Playlist", slots, []);
    	let { id } = $$props;
    	let playlist;
    	let songs = [];
    	let loading = true;
    	let songCount;
    	let isSmartlist = false;
    	let loadedTime;

    	onMount(async () => {
    		$$invalidate(1, playlist = await getPlaylist(id));

    		if (playlist && playlist.id) {
    			await handleSongLoad();
    			$$invalidate(4, isSmartlist = playlist.id.match(/^smart_/));
    		}

    		$$invalidate(2, loading = false);
    	});

    	async function handleSongLoad() {
    		$$invalidate(0, songs = await getSongsFromPlaylist(id));
    		$$invalidate(5, loadedTime = new Date());
    	}

    	const writable_props = ["id"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlist> was created with unknown prop '${key}'`);
    	});

    	function lister_data_binding(value) {
    		songs = value;
    		$$invalidate(0, songs);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		getSongsFromPlaylist,
    		getPlaylist,
    		Rating,
    		Actions,
    		Lister,
    		SVGPlaylist: Queue_music,
    		SVGSmartlist: Smartlist,
    		SVGRefresh: Refresh,
    		id,
    		playlist,
    		songs,
    		loading,
    		songCount,
    		isSmartlist,
    		loadedTime,
    		handleSongLoad
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("playlist" in $$props) $$invalidate(1, playlist = $$props.playlist);
    		if ("songs" in $$props) $$invalidate(0, songs = $$props.songs);
    		if ("loading" in $$props) $$invalidate(2, loading = $$props.loading);
    		if ("songCount" in $$props) $$invalidate(3, songCount = $$props.songCount);
    		if ("isSmartlist" in $$props) $$invalidate(4, isSmartlist = $$props.isSmartlist);
    		if ("loadedTime" in $$props) $$invalidate(5, loadedTime = $$props.loadedTime);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*songs*/ 1) {
    			$$invalidate(0, songs);
    		}

    		if ($$self.$$.dirty & /*songs*/ 1) {
    			$$invalidate(3, songCount = songs.length);
    		}
    	};

    	return [
    		songs,
    		playlist,
    		loading,
    		songCount,
    		isSmartlist,
    		loadedTime,
    		handleSongLoad,
    		id,
    		lister_data_binding
    	];
    }

    class Playlist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { id: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Playlist",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[7] === undefined && !("id" in props)) {
    			console.warn("<Playlist> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<Playlist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Playlist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\smartlistCard.svelte generated by Svelte v3.38.3 */
    const file$g = "src\\components\\smartlistCard.svelte";

    // (33:4) {:else}
    function create_else_block_1$3(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let br;
    	let t2;
    	let div2;
    	let actions;
    	let current;

    	actions = new Actions({
    			props: { type: "playlist", mode: "miniButtons" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Loading";
    			t1 = space();
    			div1 = element("div");
    			br = element("br");
    			t2 = space();
    			div2 = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(div0, "class", "title svelte-1f5enwr");
    			add_location(div0, file$g, 33, 8, 890);
    			add_location(br, file$g, 38, 12, 991);
    			attr_dev(div1, "class", "count");
    			add_location(div1, file$g, 37, 8, 958);
    			attr_dev(div2, "class", "actions svelte-1f5enwr");
    			add_location(div2, file$g, 41, 8, 1023);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, br);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(actions, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(33:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#if smartlist}
    function create_if_block$a(ctx) {
    	let div0;
    	let link;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let actions;
    	let current;

    	link = new Link({
    			props: {
    				to: "smartlists/" + /*smartlist*/ ctx[0].id,
    				title: /*smartlist*/ ctx[0].name,
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function select_block_type_1(ctx, dirty) {
    		if (typeof /*smartlist*/ ctx[0].items === "number") return create_if_block_1$6;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	actions = new Actions({
    			props: {
    				type: "playlist",
    				mode: "miniButtons",
    				id: /*smartlist*/ ctx[0].id
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(link.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			if_block.c();
    			t1 = space();
    			div2 = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(div0, "class", "title svelte-1f5enwr");
    			add_location(div0, file$g, 13, 8, 263);
    			attr_dev(div1, "class", "count");
    			add_location(div1, file$g, 17, 8, 409);
    			attr_dev(div2, "class", "actions svelte-1f5enwr");
    			add_location(div2, file$g, 25, 8, 686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(link, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			if_block.m(div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(actions, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*smartlist*/ 1) link_changes.to = "smartlists/" + /*smartlist*/ ctx[0].id;
    			if (dirty & /*smartlist*/ 1) link_changes.title = /*smartlist*/ ctx[0].name;

    			if (dirty & /*$$scope, smartlist*/ 5) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}

    			const actions_changes = {};
    			if (dirty & /*smartlist*/ 1) actions_changes.id = /*smartlist*/ ctx[0].id;
    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(13:4) {#if smartlist}",
    		ctx
    	});

    	return block;
    }

    // (15:12) <Link to="smartlists/{smartlist.id}" title="{smartlist.name}">
    function create_default_slot$8(ctx) {
    	let t_value = /*smartlist*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*smartlist*/ 1 && t_value !== (t_value = /*smartlist*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(15:12) <Link to=\\\"smartlists/{smartlist.id}\\\" title=\\\"{smartlist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:12) {:else}
    function create_else_block$8(ctx) {
    	let t0_value = /*smartlist*/ ctx[0].items + "";
    	let t0;
    	let t1;

    	let t2_value = (parseInt(/*smartlist*/ ctx[0].items) === 1
    	? "song"
    	: "songs") + "";

    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*smartlist*/ 1 && t0_value !== (t0_value = /*smartlist*/ ctx[0].items + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*smartlist*/ 1 && t2_value !== (t2_value = (parseInt(/*smartlist*/ ctx[0].items) === 1
    			? "song"
    			: "songs") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(21:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:12) {#if typeof smartlist.items === "number"}
    function create_if_block_1$6(ctx) {
    	let t0;
    	let t1_value = /*smartlist*/ ctx[0].items + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("Up to ");
    			t1 = text(t1_value);
    			t2 = text(" songs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*smartlist*/ 1 && t1_value !== (t1_value = /*smartlist*/ ctx[0].items + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(19:12) {#if typeof smartlist.items === \\\"number\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*smartlist*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "playlist-card");
    			add_location(div, file$g, 11, 0, 205);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SmartlistCard", slots, []);
    	let { data = null } = $$props;
    	let smartlist;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SmartlistCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ Link, Actions, data, smartlist });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("smartlist" in $$props) $$invalidate(0, smartlist = $$props.smartlist);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, smartlist = data);
    		}
    	};

    	return [smartlist, data];
    }

    class SmartlistCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SmartlistCard",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get data() {
    		throw new Error("<SmartlistCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SmartlistCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var smartlistCard = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': SmartlistCard
    });

    /* src\views\smartlists.svelte generated by Svelte v3.38.3 */
    const file$f = "src\\views\\smartlists.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (25:0) {:catch error}
    function create_catch_block$2(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*error*/ ctx[4].message + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Something went wrong: ");
    			t1 = text(t1_value);
    			add_location(p, file$f, 25, 4, 649);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(25:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {:then smartlists}
    function create_then_block$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*smartlists*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(13:0) {:then smartlists}",
    		ctx
    	});

    	return block;
    }

    // (22:4) {:else}
    function create_else_block$7(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Unable to find any smartlists";
    			add_location(p, file$f, 22, 8, 580);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(22:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#if smartlists.length > 0}
    function create_if_block$9(ctx) {
    	let ul;
    	let ul_intro;
    	let current;
    	let each_value = /*smartlists*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "playlist-grid");
    			add_location(ul, file$f, 14, 8, 340);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getSmartlists*/ 0) {
    				each_value = /*smartlists*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			if (!ul_intro) {
    				add_render_callback(() => {
    					ul_intro = create_in_transition(ul, fade, {});
    					ul_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(14:4) {#if smartlists.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (16:12) {#each smartlists as smartlist}
    function create_each_block$2(ctx) {
    	let li;
    	let smartlistcard;
    	let t;
    	let current;

    	smartlistcard = new SmartlistCard({
    			props: { data: /*smartlist*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(smartlistcard.$$.fragment);
    			t = space();
    			add_location(li, file$f, 16, 16, 437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(smartlistcard, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(smartlistcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(smartlistcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(smartlistcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(16:12) {#each smartlists as smartlist}",
    		ctx
    	});

    	return block;
    }

    // (11:24)       <p>Loading smartlists</p>  {:then smartlists}
    function create_pending_block$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading smartlists";
    			add_location(p, file$f, 11, 4, 252);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(11:24)       <p>Loading smartlists</p>  {:then smartlists}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let h1;
    	let t1;
    	let await_block_anchor;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 0,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(getSmartlists(), info);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Smartlists";
    			t1 = space();
    			await_block_anchor = empty();
    			info.block.c();
    			add_location(h1, file$f, 8, 0, 199);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Smartlists", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Smartlists> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ fade, getSmartlists, SmartlistCard });
    	return [];
    }

    class Smartlists extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Smartlists",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    let serverURL_value = get_store_value(serverURL);

    /**
     * Make API request for genre data
     * @param {string} url
     * @returns {Promise<*>}
     */
    const fetchGenreData = async (url) => {
        return await fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    return (data.genre) ? data.genre : data;
                } else {
                    return [];
                }
            })
            .catch(err => {
                console.log("Error Reading data " + err);
                return err;
            });
    };


    /**
     * Get all genres
     * @returns {Promise<*>}
     */
    const getGenres = () => {
        let queryURL = serverURL_value + "/server/json.server.php?action=genres";
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getGenres");
        return fetchGenreData(queryURL);
    };

    /**
     * Get genre by ID
     * @param {number} id
     * @returns {Promise<*>}
     */
    const getGenre = (id) => {
        let queryURL = serverURL_value + "/server/json.server.php?action=genre&filter=" + id;
        queryURL += "&auth=" + get_store_value(userToken) + "&version=" + get_store_value(APIVersion);
        debugHelper(queryURL, "getGenre");

        return fetchGenreData(queryURL);
    };

    /**
     * Sort genres alphabetically
     * @param {array} genres
     * @returns {*}
     */
    const sortGenresByName = (genres) => {
        return genres.sort(function(obj1, obj2) { return obj1.name.localeCompare(obj2.name) })
    };

    /* src\views\genres.svelte generated by Svelte v3.38.3 */
    const file$e = "src\\views\\genres.svelte";

    // (29:0) {:else}
    function create_else_block$6(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading genres";
    			add_location(p, file$e, 29, 4, 630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(29:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (27:0) {#if !loading && genres && genres.length > 0}
    function create_if_block$8(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: { data: /*genres*/ ctx[0], type: "genre" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};
    			if (dirty & /*genres*/ 1) lister_changes.data = /*genres*/ ctx[0];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(27:0) {#if !loading && genres && genres.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*loading*/ ctx[1] && /*genres*/ ctx[0] && /*genres*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Genres";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$e, 24, 0, 508);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Genres", slots, []);
    	let genres = [];
    	let loading = false;

    	function handleSortByName() {
    		$$invalidate(1, loading = true);
    		$$invalidate(0, genres = sortGenresByName(genres));
    		$$invalidate(1, loading = false);
    	}

    	onMount(async () => {
    		$$invalidate(0, genres = await getGenres());
    		handleSortByName();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Genres> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		getGenres,
    		sortGenresByName,
    		Lister,
    		genres,
    		loading,
    		handleSortByName
    	});

    	$$self.$inject_state = $$props => {
    		if ("genres" in $$props) $$invalidate(0, genres = $$props.genres);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*genres*/ 1) {
    			$$invalidate(0, genres);
    		}
    	};

    	return [genres, loading];
    }

    class Genres extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Genres",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\views\genre.svelte generated by Svelte v3.38.3 */
    const file$d = "src\\views\\genre.svelte";

    // (83:0) {:else}
    function create_else_block_2$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading";
    			add_location(p, file$d, 83, 4, 2682);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(83:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:0) {#if !loading}
    function create_if_block$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$5, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*genre*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(46:0) {#if !loading}",
    		ctx
    	});

    	return block;
    }

    // (80:4) {:else}
    function create_else_block_1$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No results";
    			add_location(p, file$d, 80, 8, 2639);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(80:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:4) {#if genre}
    function create_if_block_1$5(ctx) {
    	let h1;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	const if_block_creators = [create_if_block_7$1, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*type*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = !/*type*/ ctx[1] && create_if_block_6$2(ctx);
    	let if_block2 = /*data*/ ctx[3].length > 0 && create_if_block_2$5(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			add_location(h1, file$d, 47, 8, 1351);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			if_blocks[current_block_type_index].m(h1, null);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(h1, null);
    			}

    			if (!/*type*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*data*/ ctx[3].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*data*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(47:4) {#if genre}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {:else }
    function create_else_block$5(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[2].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*genre*/ 4) && t1_value !== (t1_value = /*genre*/ ctx[2].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(51:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (49:12) {#if type}
    function create_if_block_7$1(ctx) {
    	let t0;
    	let t1;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "genres/" + /*id*/ ctx[0],
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = text(/*type*/ ctx[1]);
    			t1 = text(" with: ");
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*type*/ 2) set_data_dev(t0, /*type*/ ctx[1]);
    			const link_changes = {};
    			if (dirty & /*id*/ 1) link_changes.to = "genres/" + /*id*/ ctx[0];

    			if (dirty & /*$$scope, genre*/ 36) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(49:12) {#if type}",
    		ctx
    	});

    	return block;
    }

    // (50:29) <Link to="genres/{id}">
    function create_default_slot_3$1(ctx) {
    	let svggenre;
    	let t0;
    	let t1_value = /*genre*/ ctx[2].name + "";
    	let t1;
    	let current;

    	svggenre = new Label({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svggenre.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svggenre, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*genre*/ 4) && t1_value !== (t1_value = /*genre*/ ctx[2].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svggenre.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svggenre.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svggenre, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(50:29) <Link to=\\\"genres/{id}\\\">",
    		ctx
    	});

    	return block;
    }

    // (56:8) {#if !type}
    function create_if_block_6$2(ctx) {
    	let section;
    	let linkcard0;
    	let t0;
    	let linkcard1;
    	let t1;
    	let linkcard2;
    	let current;

    	linkcard0 = new LinkCard({
    			props: {
    				url: "genres/" + /*genre*/ ctx[2].id + "/artists",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	linkcard1 = new LinkCard({
    			props: {
    				url: "genres/" + /*genre*/ ctx[2].id + "/albums",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	linkcard2 = new LinkCard({
    			props: {
    				url: "genres/" + /*genre*/ ctx[2].id + "/songs",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(linkcard0.$$.fragment);
    			t0 = space();
    			create_component(linkcard1.$$.fragment);
    			t1 = space();
    			create_component(linkcard2.$$.fragment);
    			attr_dev(section, "class", "link-grid");
    			add_location(section, file$d, 56, 12, 1631);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(linkcard0, section, null);
    			append_dev(section, t0);
    			mount_component(linkcard1, section, null);
    			append_dev(section, t1);
    			mount_component(linkcard2, section, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linkcard0_changes = {};
    			if (dirty & /*genre*/ 4) linkcard0_changes.url = "genres/" + /*genre*/ ctx[2].id + "/artists";

    			if (dirty & /*$$scope*/ 32) {
    				linkcard0_changes.$$scope = { dirty, ctx };
    			}

    			linkcard0.$set(linkcard0_changes);
    			const linkcard1_changes = {};
    			if (dirty & /*genre*/ 4) linkcard1_changes.url = "genres/" + /*genre*/ ctx[2].id + "/albums";

    			if (dirty & /*$$scope*/ 32) {
    				linkcard1_changes.$$scope = { dirty, ctx };
    			}

    			linkcard1.$set(linkcard1_changes);
    			const linkcard2_changes = {};
    			if (dirty & /*genre*/ 4) linkcard2_changes.url = "genres/" + /*genre*/ ctx[2].id + "/songs";

    			if (dirty & /*$$scope*/ 32) {
    				linkcard2_changes.$$scope = { dirty, ctx };
    			}

    			linkcard2.$set(linkcard2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkcard0.$$.fragment, local);
    			transition_in(linkcard1.$$.fragment, local);
    			transition_in(linkcard2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkcard0.$$.fragment, local);
    			transition_out(linkcard1.$$.fragment, local);
    			transition_out(linkcard2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(linkcard0);
    			destroy_component(linkcard1);
    			destroy_component(linkcard2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(56:8) {#if !type}",
    		ctx
    	});

    	return block;
    }

    // (58:16) <LinkCard url="genres/{genre.id}/artists">
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Artists");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(58:16) <LinkCard url=\\\"genres/{genre.id}/artists\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:16) <LinkCard url="genres/{genre.id}/albums">
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Albums");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(59:16) <LinkCard url=\\\"genres/{genre.id}/albums\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:16) <LinkCard url="genres/{genre.id}/songs">
    function create_default_slot$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Songs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(60:16) <LinkCard url=\\\"genres/{genre.id}/songs\\\">",
    		ctx
    	});

    	return block;
    }

    // (64:8) {#if data.length > 0}
    function create_if_block_2$5(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*type*/ ctx[1] === "artists" && create_if_block_5$2(ctx);
    	let if_block1 = /*type*/ ctx[1] === "albums" && create_if_block_4$2(ctx);
    	let if_block2 = /*type*/ ctx[1] === "songs" && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*type*/ ctx[1] === "artists") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "albums") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "songs") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(64:8) {#if data.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (65:12) {#if type === 'artists'}
    function create_if_block_5$2(ctx) {
    	let actions;
    	let t;
    	let lister;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "artistGenre",
    				mode: "fullButtons",
    				data: /*genre*/ ctx[2].name
    			},
    			$$inline: true
    		});

    	lister = new Lister({
    			props: {
    				data: /*data*/ ctx[3],
    				type: "artist",
    				activeSort: "title"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*genre*/ 4) actions_changes.data = /*genre*/ ctx[2].name;
    			actions.$set(actions_changes);
    			const lister_changes = {};
    			if (dirty & /*data*/ 8) lister_changes.data = /*data*/ ctx[3];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(65:12) {#if type === 'artists'}",
    		ctx
    	});

    	return block;
    }

    // (70:12) {#if type === 'albums'}
    function create_if_block_4$2(ctx) {
    	let actions;
    	let t;
    	let lister;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "albumGenre",
    				mode: "fullButtons",
    				data: /*genre*/ ctx[2].name
    			},
    			$$inline: true
    		});

    	lister = new Lister({
    			props: {
    				data: /*data*/ ctx[3],
    				type: "album",
    				activeSort: "title"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*genre*/ 4) actions_changes.data = /*genre*/ ctx[2].name;
    			actions.$set(actions_changes);
    			const lister_changes = {};
    			if (dirty & /*data*/ 8) lister_changes.data = /*data*/ ctx[3];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(70:12) {#if type === 'albums'}",
    		ctx
    	});

    	return block;
    }

    // (75:12) {#if type === 'songs'}
    function create_if_block_3$2(ctx) {
    	let actions;
    	let t;
    	let lister;
    	let current;

    	actions = new Actions({
    			props: {
    				type: "songGenre",
    				mode: "fullButtons",
    				data: /*genre*/ ctx[2].name
    			},
    			$$inline: true
    		});

    	lister = new Lister({
    			props: {
    				data: /*data*/ ctx[3],
    				type: "song",
    				activeSort: "title"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(actions.$$.fragment);
    			t = space();
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actions_changes = {};
    			if (dirty & /*genre*/ 4) actions_changes.data = /*genre*/ ctx[2].name;
    			actions.$set(actions_changes);
    			const lister_changes = {};
    			if (dirty & /*data*/ 8) lister_changes.data = /*data*/ ctx[3];
    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actions.$$.fragment, local);
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actions.$$.fragment, local);
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(75:12) {#if type === 'songs'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block_2$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*loading*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Genre", slots, []);
    	let { id } = $$props;
    	let { type } = $$props;
    	let genre;
    	let data = [];
    	let loading = true;

    	onMount(async () => {
    		$$invalidate(2, genre = await getGenre(id));

    		if (id && genre.id) {
    			switch (type) {
    				case "artists":
    					$$invalidate(3, data = await getArtistsByGenre({ query: id, limit: 0 }));
    					break;
    				case "albums":
    					$$invalidate(3, data = await getAlbumsByGenre({ query: id, limit: 0 }));
    					break;
    				case "songs":
    					$$invalidate(3, data = await getGenreSongs({ query: id, limit: 0 }));
    					break;
    			}
    		}

    		$$invalidate(4, loading = false);
    	});

    	const writable_props = ["id", "type"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Genre> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Link,
    		getGenre,
    		getGenreSongs,
    		getArtistsByGenre,
    		getAlbumsByGenre,
    		Actions,
    		LinkCard,
    		Lister,
    		SVGGenre: Label,
    		id,
    		type,
    		genre,
    		data,
    		loading
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("genre" in $$props) $$invalidate(2, genre = $$props.genre);
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("loading" in $$props) $$invalidate(4, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, type, genre, data, loading];
    }

    class Genre extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { id: 0, type: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Genre",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<Genre> was created without expected prop 'id'");
    		}

    		if (/*type*/ ctx[1] === undefined && !("type" in props)) {
    			console.warn("<Genre> was created without expected prop 'type'");
    		}
    	}

    	get id() {
    		throw new Error("<Genre>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Genre>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Genre>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Genre>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\views\newest.svelte generated by Svelte v3.38.3 */
    const file$c = "src\\views\\newest.svelte";

    function create_fragment$c(ctx) {
    	let h1;
    	let t1;
    	let cardlist;
    	let current;

    	cardlist = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "newestAlbums",
    				limit: "18",
    				heading: "Recently added"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Newest";
    			t1 = space();
    			create_component(cardlist.$$.fragment);
    			add_location(h1, file$c, 4, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Newest", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Newest> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardList });
    	return [];
    }

    class Newest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newest",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\views\recent.svelte generated by Svelte v3.38.3 */
    const file$b = "src\\views\\recent.svelte";

    function create_fragment$b(ctx) {
    	let h1;
    	let t1;
    	let cardlist;
    	let current;

    	cardlist = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "recentSongs",
    				limit: "20",
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Recently Played";
    			t1 = space();
    			create_component(cardlist.$$.fragment);
    			add_location(h1, file$b, 4, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Recent", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Recent> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardList });
    	return [];
    }

    class Recent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Recent",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\views\favorites.svelte generated by Svelte v3.38.3 */
    const file$a = "src\\views\\favorites.svelte";

    // (35:8) {:catch error}
    function create_catch_block_2$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$a, 35, 12, 1249);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_2$1.name,
    		type: "catch",
    		source: "(35:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (29:8) {:then artists}
    function create_then_block_2$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$4, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*artists*/ ctx[6].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_2$1.name,
    		type: "then",
    		source: "(29:8) {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (32:12) {:else}
    function create_else_block_2$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No artists found";
    			add_location(p, file$a, 32, 16, 1169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(32:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (30:12) {#if artists.length > 0}
    function create_if_block_2$4(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: { data: /*artists*/ ctx[6], type: "artist" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(30:12) {#if artists.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (27:47)               Loading favorite artists          {:then artists}
    function create_pending_block_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading favorite artists");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_2$1.name,
    		type: "pending",
    		source: "(27:47)               Loading favorite artists          {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {:catch error}
    function create_catch_block_1$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$a, 49, 12, 1713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1$1.name,
    		type: "catch",
    		source: "(49:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (43:8) {:then albums}
    function create_then_block_1$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$4, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*albums*/ ctx[5].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1$1.name,
    		type: "then",
    		source: "(43:8) {:then albums}",
    		ctx
    	});

    	return block;
    }

    // (46:12) {:else}
    function create_else_block_1$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No albums found";
    			add_location(p, file$a, 46, 16, 1634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(46:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:12) {#if albums.length > 0}
    function create_if_block_1$4(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: { data: /*albums*/ ctx[5], type: "album" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(44:12) {#if albums.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (41:46)               Loading favorite albums          {:then albums}
    function create_pending_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading favorite albums");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1$1.name,
    		type: "pending",
    		source: "(41:46)               Loading favorite albums          {:then albums}",
    		ctx
    	});

    	return block;
    }

    // (63:8) {:catch error}
    function create_catch_block$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$a, 63, 12, 2168);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(63:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (57:8) {:then songs}
    function create_then_block$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*songs*/ ctx[3].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(57:8) {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (60:12) {:else}
    function create_else_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No songs found";
    			add_location(p, file$a, 60, 16, 2090);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(60:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:12) {#if songs.length > 0}
    function create_if_block$6(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: { data: /*songs*/ ctx[3], type: "song" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(58:12) {#if songs.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (55:45)               Loading favorite songs          {:then songs}
    function create_pending_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading favorite songs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(55:45)               Loading favorite songs          {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (25:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>
    function create_default_slot$6(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_2$1,
    		then: create_then_block_2$1,
    		catch: create_catch_block_2$1,
    		value: 6,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(favoriteArtists({ limit: 2000 }), info);

    	let info_1 = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_1$1,
    		then: create_then_block_1$1,
    		catch: create_catch_block_1$1,
    		value: 5,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(favoriteAlbums({ limit: 2000 }), info_1);

    	let info_2 = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 3,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(favoriteSongs({ limit: 2000 }), info_2);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			info.block.c();
    			t0 = space();
    			div1 = element("div");
    			info_1.block.c();
    			t1 = space();
    			div2 = element("div");
    			info_2.block.c();
    			attr_dev(div0, "class", "artists");
    			set_style(div0, "display", /*currentTab*/ ctx[0] === "artists" ? "block" : "none");
    			add_location(div0, file$a, 25, 4, 839);
    			attr_dev(div1, "class", "albums");
    			set_style(div1, "display", /*currentTab*/ ctx[0] === "albums" ? "block" : "none");
    			add_location(div1, file$a, 39, 4, 1312);
    			attr_dev(div2, "class", "songs");
    			set_style(div2, "display", /*currentTab*/ ctx[0] === "songs" ? "block" : "none");
    			add_location(div2, file$a, 53, 4, 1776);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			info_1.block.m(div1, info_1.anchor = null);
    			info_1.mount = () => div1;
    			info_1.anchor = null;
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			info_2.block.m(div2, info_2.anchor = null);
    			info_2.mount = () => div2;
    			info_2.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div0, "display", /*currentTab*/ ctx[0] === "artists" ? "block" : "none");
    			}

    			update_await_block_branch(info_1, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div1, "display", /*currentTab*/ ctx[0] === "albums" ? "block" : "none");
    			}

    			update_await_block_branch(info_2, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div2, "display", /*currentTab*/ ctx[0] === "songs" ? "block" : "none");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			transition_in(info_1.block);
    			transition_in(info_2.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_1.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_2.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			info_1.block.d();
    			info_1.token = null;
    			info_1 = null;
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			info_2.block.d();
    			info_2.token = null;
    			info_2 = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(25:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let h1;
    	let t1;
    	let tabs;
    	let updating_activeTabValue;
    	let current;

    	function tabs_activeTabValue_binding(value) {
    		/*tabs_activeTabValue_binding*/ ctx[2](value);
    	}

    	let tabs_props = {
    		items: /*tabItems*/ ctx[1],
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	if (/*currentTab*/ ctx[0] !== void 0) {
    		tabs_props.activeTabValue = /*currentTab*/ ctx[0];
    	}

    	tabs = new Tabs({ props: tabs_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabs, "activeTabValue", tabs_activeTabValue_binding));

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Favorites";
    			t1 = space();
    			create_component(tabs.$$.fragment);
    			add_location(h1, file$a, 22, 0, 755);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope, currentTab*/ 129) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeTabValue && dirty & /*currentTab*/ 1) {
    				updating_activeTabValue = true;
    				tabs_changes.activeTabValue = /*currentTab*/ ctx[0];
    				add_flush_callback(() => updating_activeTabValue = false);
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Favorites", slots, []);
    	let currentTab;

    	let tabItems = [
    		{
    			label: "Artists",
    			value: "artists",
    			icon: Artist$1
    		},
    		{
    			label: "Albums",
    			value: "albums",
    			icon: Album$1
    		},
    		{
    			label: "Songs",
    			value: "songs",
    			icon: Music_note
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Favorites> was created with unknown prop '${key}'`);
    	});

    	function tabs_activeTabValue_binding(value) {
    		currentTab = value;
    		$$invalidate(0, currentTab);
    	}

    	$$self.$capture_state = () => ({
    		favoriteArtists,
    		favoriteAlbums,
    		favoriteSongs,
    		Tabs,
    		Lister,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGSong: Music_note,
    		currentTab,
    		tabItems
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentTab" in $$props) $$invalidate(0, currentTab = $$props.currentTab);
    		if ("tabItems" in $$props) $$invalidate(1, tabItems = $$props.tabItems);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentTab, tabItems, tabs_activeTabValue_binding];
    }

    class Favorites extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Favorites",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src\views\trending.svelte generated by Svelte v3.38.3 */
    const file$9 = "src\\views\\trending.svelte";

    function create_fragment$9(ctx) {
    	let h1;
    	let t1;
    	let cardlist0;
    	let t2;
    	let cardlist1;
    	let t3;
    	let cardlist2;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "frequentArtists",
    				limit: "12",
    				containerType: "scroll",
    				heading: "Artists"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "frequentAlbums",
    				limit: "12",
    				containerType: "scroll",
    				heading: "Albums"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "frequentSongs",
    				limit: "9",
    				containerType: "scroll",
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Trending";
    			t1 = space();
    			create_component(cardlist0.$$.fragment);
    			t2 = space();
    			create_component(cardlist1.$$.fragment);
    			t3 = space();
    			create_component(cardlist2.$$.fragment);
    			add_location(h1, file$9, 4, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cardlist1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cardlist1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Trending", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Trending> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardList });
    	return [];
    }

    class Trending extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Trending",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\views\topRated.svelte generated by Svelte v3.38.3 */
    const file$8 = "src\\views\\topRated.svelte";

    // (35:8) {:catch error}
    function create_catch_block_2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$8, 35, 12, 1263);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_2.name,
    		type: "catch",
    		source: "(35:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (29:8) {:then artists}
    function create_then_block_2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$3, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*artists*/ ctx[6].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_2.name,
    		type: "then",
    		source: "(29:8) {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (32:12) {:else}
    function create_else_block_2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No artists found";
    			add_location(p, file$8, 32, 16, 1183);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(32:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (30:12) {#if artists.length > 0}
    function create_if_block_2$3(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: {
    				data: /*artists*/ ctx[6],
    				type: "artist",
    				activeSort: "rating",
    				sortReverse: "true"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(30:12) {#if artists.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (27:42)               Loading top artists          {:then artists}
    function create_pending_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading top artists");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_2.name,
    		type: "pending",
    		source: "(27:42)               Loading top artists          {:then artists}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {:catch error}
    function create_catch_block_1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$8, 49, 12, 1756);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(49:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (43:8) {:then albums}
    function create_then_block_1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$3, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*albums*/ ctx[5].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(43:8) {:then albums}",
    		ctx
    	});

    	return block;
    }

    // (46:12) {:else}
    function create_else_block_1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No albums found";
    			add_location(p, file$8, 46, 16, 1677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(46:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:12) {#if albums.length > 0}
    function create_if_block_1$3(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: {
    				data: /*albums*/ ctx[5],
    				type: "album",
    				activeSort: "rating",
    				sortReverse: "true"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(44:12) {#if albums.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (41:41)               Loading top albums          {:then albums}
    function create_pending_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading top albums");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(41:41)               Loading top albums          {:then albums}",
    		ctx
    	});

    	return block;
    }

    // (63:8) {:catch error}
    function create_catch_block(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "An error occurred.";
    			add_location(p, file$8, 63, 12, 2240);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(63:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (57:8) {:then songs}
    function create_then_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*songs*/ ctx[3].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(57:8) {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (60:12) {:else}
    function create_else_block$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No songs found";
    			add_location(p, file$8, 60, 16, 2162);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(60:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:12) {#if songs.length > 0}
    function create_if_block$5(ctx) {
    	let lister;
    	let current;

    	lister = new Lister({
    			props: {
    				data: /*songs*/ ctx[3],
    				type: "song",
    				activeSort: "rating",
    				sortReverse: "true"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(58:12) {#if songs.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (55:40)               Loading top songs          {:then songs}
    function create_pending_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading top songs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(55:40)               Loading top songs          {:then songs}",
    		ctx
    	});

    	return block;
    }

    // (25:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>
    function create_default_slot$5(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_2,
    		then: create_then_block_2,
    		catch: create_catch_block_2,
    		value: 6,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(topArtists({ limit: 2000 }), info);

    	let info_1 = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block_1,
    		value: 5,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(topAlbums({ limit: 2000 }), info_1);

    	let info_2 = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 3,
    		error: 4,
    		blocks: [,,,]
    	};

    	handle_promise(topSongs({ limit: 2000 }), info_2);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			info.block.c();
    			t0 = space();
    			div1 = element("div");
    			info_1.block.c();
    			t1 = space();
    			div2 = element("div");
    			info_2.block.c();
    			attr_dev(div0, "class", "artists");
    			set_style(div0, "display", /*currentTab*/ ctx[0] === "artists" ? "block" : "none");
    			add_location(div0, file$8, 25, 4, 824);
    			attr_dev(div1, "class", "albums");
    			set_style(div1, "display", /*currentTab*/ ctx[0] === "albums" ? "block" : "none");
    			add_location(div1, file$8, 39, 4, 1326);
    			attr_dev(div2, "class", "songs");
    			set_style(div2, "display", /*currentTab*/ ctx[0] === "songs" ? "block" : "none");
    			add_location(div2, file$8, 53, 4, 1819);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			info_1.block.m(div1, info_1.anchor = null);
    			info_1.mount = () => div1;
    			info_1.anchor = null;
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			info_2.block.m(div2, info_2.anchor = null);
    			info_2.mount = () => div2;
    			info_2.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div0, "display", /*currentTab*/ ctx[0] === "artists" ? "block" : "none");
    			}

    			update_await_block_branch(info_1, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div1, "display", /*currentTab*/ ctx[0] === "albums" ? "block" : "none");
    			}

    			update_await_block_branch(info_2, ctx, dirty);

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div2, "display", /*currentTab*/ ctx[0] === "songs" ? "block" : "none");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			transition_in(info_1.block);
    			transition_in(info_2.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_1.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_2.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			info_1.block.d();
    			info_1.token = null;
    			info_1 = null;
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			info_2.block.d();
    			info_2.token = null;
    			info_2 = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(25:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let h1;
    	let t1;
    	let tabs;
    	let updating_activeTabValue;
    	let current;

    	function tabs_activeTabValue_binding(value) {
    		/*tabs_activeTabValue_binding*/ ctx[2](value);
    	}

    	let tabs_props = {
    		items: /*tabItems*/ ctx[1],
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	if (/*currentTab*/ ctx[0] !== void 0) {
    		tabs_props.activeTabValue = /*currentTab*/ ctx[0];
    	}

    	tabs = new Tabs({ props: tabs_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabs, "activeTabValue", tabs_activeTabValue_binding));

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Top Rated";
    			t1 = space();
    			create_component(tabs.$$.fragment);
    			add_location(h1, file$8, 22, 0, 740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope, currentTab*/ 129) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeTabValue && dirty & /*currentTab*/ 1) {
    				updating_activeTabValue = true;
    				tabs_changes.activeTabValue = /*currentTab*/ ctx[0];
    				add_flush_callback(() => updating_activeTabValue = false);
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TopRated", slots, []);
    	let currentTab;

    	let tabItems = [
    		{
    			label: "Artists",
    			value: "artists",
    			icon: Artist$1
    		},
    		{
    			label: "Albums",
    			value: "albums",
    			icon: Album$1
    		},
    		{
    			label: "Songs",
    			value: "songs",
    			icon: Music_note
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopRated> was created with unknown prop '${key}'`);
    	});

    	function tabs_activeTabValue_binding(value) {
    		currentTab = value;
    		$$invalidate(0, currentTab);
    	}

    	$$self.$capture_state = () => ({
    		topArtists,
    		topAlbums,
    		topSongs,
    		Tabs,
    		Lister,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		SVGSong: Music_note,
    		currentTab,
    		tabItems
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentTab" in $$props) $$invalidate(0, currentTab = $$props.currentTab);
    		if ("tabItems" in $$props) $$invalidate(1, tabItems = $$props.tabItems);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentTab, tabItems, tabs_activeTabValue_binding];
    }

    class TopRated extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TopRated",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\views\forgotten.svelte generated by Svelte v3.38.3 */
    const file$7 = "src\\views\\forgotten.svelte";

    function create_fragment$7(ctx) {
    	let h1;
    	let t1;
    	let cardlist0;
    	let t2;
    	let cardlist1;
    	let t3;
    	let cardlist2;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "forgottenArtists",
    				limit: "12",
    				containerType: "scroll",
    				heading: "Artists"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "forgottenAlbums",
    				limit: "12",
    				containerType: "scroll",
    				heading: "Albums"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "forgottenSongs",
    				limit: "9",
    				containerType: "scroll",
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Forgotten";
    			t1 = space();
    			create_component(cardlist0.$$.fragment);
    			t2 = space();
    			create_component(cardlist1.$$.fragment);
    			t3 = space();
    			create_component(cardlist2.$$.fragment);
    			add_location(h1, file$7, 4, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cardlist1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cardlist1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Forgotten", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Forgotten> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardList });
    	return [];
    }

    class Forgotten extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Forgotten",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\views\random.svelte generated by Svelte v3.38.3 */
    const file$6 = "src\\views\\random.svelte";

    function create_fragment$6(ctx) {
    	let h1;
    	let t1;
    	let cardlist0;
    	let t2;
    	let cardlist1;
    	let t3;
    	let cardlist2;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "randomArtists",
    				limit: "6",
    				refresh: "true",
    				heading: "Artists"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "randomAlbums",
    				limit: "6",
    				refresh: "true",
    				heading: "Albums"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "randomSongs",
    				limit: "9",
    				refresh: "true",
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Random";
    			t1 = space();
    			create_component(cardlist0.$$.fragment);
    			t2 = space();
    			create_component(cardlist1.$$.fragment);
    			t3 = space();
    			create_component(cardlist2.$$.fragment);
    			add_location(h1, file$6, 4, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardlist0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cardlist1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cardlist2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardlist0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cardlist1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cardlist2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Random", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Random> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardList });
    	return [];
    }

    class Random extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Random",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\components\massRater.svelte generated by Svelte v3.38.3 */
    const file$5 = "src\\components\\massRater.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (192:4) {:else}
    function create_else_block$2(ctx) {
    	let p;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("No unrated ");
    			t1 = text(/*type*/ ctx[1]);
    			t2 = text(" found");
    			add_location(p, file$5, 192, 8, 6434);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*type*/ 2) set_data_dev(t1, /*type*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(192:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:4) {#if data.length > 0}
    function create_if_block_1$2(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let label;
    	let input;
    	let t0;
    	let th1;
    	let t1;
    	let t2;
    	let th2;
    	let t4;
    	let tbody;
    	let table_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			label = element("label");
    			input = element("input");
    			t0 = space();
    			th1 = element("th");
    			t1 = text(/*type*/ ctx[1]);
    			t2 = space();
    			th2 = element("th");
    			th2.textContent = "Rating";
    			t4 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$5, 137, 24, 3884);
    			attr_dev(label, "class", "svelte-1u25aaf");
    			add_location(label, file$5, 136, 20, 3851);
    			add_location(th0, file$5, 135, 16, 3825);
    			add_location(th1, file$5, 140, 16, 4008);
    			add_location(th2, file$5, 141, 16, 4041);
    			add_location(tr, file$5, 134, 12, 3803);
    			add_location(thead, file$5, 133, 12, 3782);
    			add_location(tbody, file$5, 145, 12, 4113);
    			attr_dev(table, "id", "massRater");
    			attr_dev(table, "class", table_class_value = "massRater " + /*type*/ ctx[1] + " svelte-1u25aaf");
    			add_location(table, file$5, 132, 8, 3721);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, label);
    			append_dev(label, input);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(th1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(table, t4);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", handleToggleAll, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*type*/ 2) set_data_dev(t1, /*type*/ ctx[1]);

    			if (dirty & /*type, data, showArtist, showAlbum*/ 51) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*type*/ 2 && table_class_value !== (table_class_value = "massRater " + /*type*/ ctx[1] + " svelte-1u25aaf")) {
    				attr_dev(table, "class", table_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(132:4) {#if data.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (129:0) {#if loading}
    function create_if_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Loading";
    			add_location(p, file$5, 129, 4, 3661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(129:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (161:36) {#if type === 'song'}
    function create_if_block_6$1(ctx) {
    	let t_value = /*item*/ ctx[16].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t_value !== (t_value = /*item*/ ctx[16].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(161:36) {#if type === 'song'}",
    		ctx
    	});

    	return block;
    }

    // (165:36) {#if type === 'album'}
    function create_if_block_5$1(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/" + /*item*/ ctx[16].id,
    				title: /*item*/ ctx[16].name,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*data*/ 1) link_changes.to = "albums/" + /*item*/ ctx[16].id;
    			if (dirty & /*data*/ 1) link_changes.title = /*item*/ ctx[16].name;

    			if (dirty & /*$$scope, data*/ 524289) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(165:36) {#if type === 'album'}",
    		ctx
    	});

    	return block;
    }

    // (166:40) <Link to="albums/{item.id}" title="{item.name}">
    function create_default_slot_3(ctx) {
    	let t_value = /*item*/ ctx[16].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t_value !== (t_value = /*item*/ ctx[16].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(166:40) <Link to=\\\"albums/{item.id}\\\" title=\\\"{item.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (169:36) {#if type === 'artist'}
    function create_if_block_4$1(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*item*/ ctx[16].id,
    				title: /*item*/ ctx[16].name,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*data*/ 1) link_changes.to = "artists/" + /*item*/ ctx[16].id;
    			if (dirty & /*data*/ 1) link_changes.title = /*item*/ ctx[16].name;

    			if (dirty & /*$$scope, data*/ 524289) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(169:36) {#if type === 'artist'}",
    		ctx
    	});

    	return block;
    }

    // (170:40) <Link to="artists/{item.id}" title="{item.name}">
    function create_default_slot_2(ctx) {
    	let t_value = /*item*/ ctx[16].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t_value !== (t_value = /*item*/ ctx[16].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(170:40) <Link to=\\\"artists/{item.id}\\\" title=\\\"{item.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (174:32) {#if showAlbum && item.album}
    function create_if_block_3$1(ctx) {
    	let div;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "albums/" + /*item*/ ctx[16].album.id,
    				title: /*item*/ ctx[16].album.name,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(div, "class", "album");
    			add_location(div, file$5, 174, 36, 5463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(link, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*data*/ 1) link_changes.to = "albums/" + /*item*/ ctx[16].album.id;
    			if (dirty & /*data*/ 1) link_changes.title = /*item*/ ctx[16].album.name;

    			if (dirty & /*$$scope, data*/ 524289) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(174:32) {#if showAlbum && item.album}",
    		ctx
    	});

    	return block;
    }

    // (176:40) <Link to="albums/{item.album.id}" title="{item.album.name}">
    function create_default_slot_1$1(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*item*/ ctx[16].album.name + "";
    	let t1;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*data*/ 1) && t1_value !== (t1_value = /*item*/ ctx[16].album.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(176:40) <Link to=\\\"albums/{item.album.id}\\\" title=\\\"{item.album.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (179:32) {#if showArtist && item.artist}
    function create_if_block_2$2(ctx) {
    	let div;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "artists/" + /*item*/ ctx[16].artist.id,
    				title: /*item*/ ctx[16].artist.name,
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(div, "class", "artist");
    			add_location(div, file$5, 179, 36, 5821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(link, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*data*/ 1) link_changes.to = "artists/" + /*item*/ ctx[16].artist.id;
    			if (dirty & /*data*/ 1) link_changes.title = /*item*/ ctx[16].artist.name;

    			if (dirty & /*$$scope, data*/ 524289) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(179:32) {#if showArtist && item.artist}",
    		ctx
    	});

    	return block;
    }

    // (181:40) <Link to="artists/{item.artist.id}" title="{item.artist.name}">
    function create_default_slot$4(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*item*/ ctx[16].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*data*/ 1) && t1_value !== (t1_value = /*item*/ ctx[16].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(181:40) <Link to=\\\"artists/{item.artist.id}\\\" title=\\\"{item.artist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (147:12) {#each data as item}
    function create_each_block$1(ctx) {
    	let tr;
    	let td0;
    	let label;
    	let input;
    	let input_id_value;
    	let t0;
    	let td1;
    	let div1;
    	let span0;
    	let img;
    	let img_src_value;
    	let t1;
    	let span1;
    	let div0;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let td2;
    	let rating;
    	let t7;
    	let current;
    	let if_block0 = /*type*/ ctx[1] === "song" && create_if_block_6$1(ctx);
    	let if_block1 = /*type*/ ctx[1] === "album" && create_if_block_5$1(ctx);
    	let if_block2 = /*type*/ ctx[1] === "artist" && create_if_block_4$1(ctx);
    	let if_block3 = /*showAlbum*/ ctx[5] && /*item*/ ctx[16].album && create_if_block_3$1(ctx);
    	let if_block4 = /*showArtist*/ ctx[4] && /*item*/ ctx[16].artist && create_if_block_2$2(ctx);

    	rating = new Rating({
    			props: {
    				type: /*type*/ ctx[1],
    				id: /*item*/ ctx[16].id,
    				rating: /*item*/ ctx[16].rating,
    				flag: /*item*/ ctx[16].flag,
    				averageRating: /*item*/ ctx[16].averagerating
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			label = element("label");
    			input = element("input");
    			t0 = space();
    			td1 = element("td");
    			div1 = element("div");
    			span0 = element("span");
    			img = element("img");
    			t1 = space();
    			span1 = element("span");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			td2 = element("td");
    			create_component(rating.$$.fragment);
    			t7 = space();
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", input_id_value = /*item*/ ctx[16].id);
    			add_location(input, file$5, 150, 28, 4265);
    			attr_dev(label, "class", "svelte-1u25aaf");
    			add_location(label, file$5, 149, 24, 4228);
    			add_location(td0, file$5, 148, 20, 4198);
    			if (img.src !== (img_src_value = "" + (/*item*/ ctx[16].art + "&thumb=1"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "height", "60");
    			attr_dev(img, "width", "60");
    			attr_dev(img, "alt", "");
    			attr_dev(img, "loading", "lazy");
    			attr_dev(img, "class", "svelte-1u25aaf");
    			add_location(img, file$5, 156, 32, 4520);
    			attr_dev(span0, "class", "thumb svelte-1u25aaf");
    			add_location(span0, file$5, 155, 28, 4466);
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$5, 159, 32, 4719);
    			attr_dev(span1, "class", "details");
    			add_location(span1, file$5, 158, 28, 4663);
    			attr_dev(div1, "class", "item svelte-1u25aaf");
    			add_location(div1, file$5, 154, 24, 4418);
    			add_location(td1, file$5, 153, 20, 4388);
    			add_location(td2, file$5, 186, 20, 6200);
    			add_location(tr, file$5, 147, 16, 4172);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, label);
    			append_dev(label, input);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, div1);
    			append_dev(div1, span0);
    			append_dev(span0, img);
    			append_dev(div1, t1);
    			append_dev(div1, span1);
    			append_dev(span1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t2);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(span1, t4);
    			if (if_block3) if_block3.m(span1, null);
    			append_dev(span1, t5);
    			if (if_block4) if_block4.m(span1, null);
    			append_dev(tr, t6);
    			append_dev(tr, td2);
    			mount_component(rating, td2, null);
    			append_dev(tr, t7);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*data*/ 1 && input_id_value !== (input_id_value = /*item*/ ctx[16].id)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty & /*data*/ 1 && img.src !== (img_src_value = "" + (/*item*/ ctx[16].art + "&thumb=1"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (/*type*/ ctx[1] === "song") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*type*/ ctx[1] === "album") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[1] === "artist") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showAlbum*/ ctx[5] && /*item*/ ctx[16].album) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*showAlbum, data*/ 33) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_3$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(span1, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showArtist*/ ctx[4] && /*item*/ ctx[16].artist) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*showArtist, data*/ 17) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_2$2(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(span1, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			const rating_changes = {};
    			if (dirty & /*type*/ 2) rating_changes.type = /*type*/ ctx[1];
    			if (dirty & /*data*/ 1) rating_changes.id = /*item*/ ctx[16].id;
    			if (dirty & /*data*/ 1) rating_changes.rating = /*item*/ ctx[16].rating;
    			if (dirty & /*data*/ 1) rating_changes.flag = /*item*/ ctx[16].flag;
    			if (dirty & /*data*/ 1) rating_changes.averageRating = /*item*/ ctx[16].averagerating;
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			destroy_component(rating);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(147:12) {#each data as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let label0;
    	let t0;
    	let input;
    	let t1;
    	let label1;
    	let t2;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let t6;
    	let label2;
    	let t7;
    	let select1;
    	let option3;
    	let t8;
    	let option3_selected_value;
    	let option4;
    	let t9;
    	let option4_selected_value;
    	let option5;
    	let t10;
    	let option5_selected_value;
    	let option6;
    	let t11;
    	let option6_selected_value;
    	let option7;
    	let t12;
    	let option7_selected_value;
    	let t13;
    	let button0;
    	let t15;
    	let button1;
    	let t17;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$4, create_if_block_1$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[3]) return 0;
    		if (/*data*/ ctx[0].length > 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			label0 = element("label");
    			t0 = text("Regex pattern:\r\n        ");
    			input = element("input");
    			t1 = space();
    			label1 = element("label");
    			t2 = text("Type\r\n\r\n        ");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Artists";
    			option1 = element("option");
    			option1.textContent = "Albums";
    			option2 = element("option");
    			option2.textContent = "Songs";
    			t6 = space();
    			label2 = element("label");
    			t7 = text("Rating\r\n\r\n        ");
    			select1 = element("select");
    			option3 = element("option");
    			t8 = text("1");
    			option4 = element("option");
    			t9 = text("2");
    			option5 = element("option");
    			t10 = text("3");
    			option6 = element("option");
    			t11 = text("4");
    			option7 = element("option");
    			t12 = text("5");
    			t13 = space();
    			button0 = element("button");
    			button0.textContent = "Apply to selected items";
    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "Reload";
    			t17 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(input, "type", "text");
    			add_location(input, file$5, 95, 8, 2593);
    			attr_dev(label0, "class", "svelte-1u25aaf");
    			add_location(label0, file$5, 93, 4, 2552);
    			option0.__value = "artist";
    			option0.value = option0.__value;
    			add_location(option0, file$5, 106, 12, 2840);
    			option1.__value = "album";
    			option1.value = option1.__value;
    			add_location(option1, file$5, 107, 12, 2893);
    			option2.__value = "song";
    			option2.value = option2.__value;
    			option2.selected = true;
    			add_location(option2, file$5, 108, 12, 2944);
    			add_location(select0, file$5, 105, 8, 2795);
    			attr_dev(label1, "class", "svelte-1u25aaf");
    			add_location(label1, file$5, 102, 4, 2762);
    			option3.__value = "1";
    			option3.value = option3.__value;
    			option3.selected = option3_selected_value = /*newRating*/ ctx[2] === 1;
    			add_location(option3, file$5, 116, 12, 3111);
    			option4.__value = "2";
    			option4.value = option4.__value;
    			option4.selected = option4_selected_value = /*newRating*/ ctx[2] === 2;
    			add_location(option4, file$5, 117, 12, 3180);
    			option5.__value = "3";
    			option5.value = option5.__value;
    			option5.selected = option5_selected_value = /*newRating*/ ctx[2] === 3;
    			add_location(option5, file$5, 118, 12, 3249);
    			option6.__value = "4";
    			option6.value = option6.__value;
    			option6.selected = option6_selected_value = /*newRating*/ ctx[2] === 4;
    			add_location(option6, file$5, 119, 12, 3318);
    			option7.__value = "5";
    			option7.value = option7.__value;
    			option7.selected = option7_selected_value = /*newRating*/ ctx[2] === 5;
    			add_location(option7, file$5, 120, 12, 3387);
    			add_location(select1, file$5, 115, 8, 3064);
    			attr_dev(label2, "class", "svelte-1u25aaf");
    			add_location(label2, file$5, 112, 4, 3029);
    			attr_dev(button0, "class", "primary");
    			add_location(button0, file$5, 124, 4, 3483);
    			attr_dev(button1, "class", "secondary");
    			add_location(button1, file$5, 125, 4, 3568);
    			attr_dev(div, "class", "inputs svelte-1u25aaf");
    			add_location(div, file$5, 92, 0, 2526);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label0);
    			append_dev(label0, t0);
    			append_dev(label0, input);
    			set_input_value(input, /*customRegex*/ ctx[6]);
    			append_dev(div, t1);
    			append_dev(div, label1);
    			append_dev(label1, t2);
    			append_dev(label1, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(div, t6);
    			append_dev(div, label2);
    			append_dev(label2, t7);
    			append_dev(label2, select1);
    			append_dev(select1, option3);
    			append_dev(option3, t8);
    			append_dev(select1, option4);
    			append_dev(option4, t9);
    			append_dev(select1, option5);
    			append_dev(option5, t10);
    			append_dev(select1, option6);
    			append_dev(option6, t11);
    			append_dev(select1, option7);
    			append_dev(option7, t12);
    			append_dev(div, t13);
    			append_dev(div, button0);
    			append_dev(div, t15);
    			append_dev(div, button1);
    			insert_dev(target, t17, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[12]),
    					listen_dev(input, "paste", /*handleRegexChange*/ ctx[7], false, false, false),
    					listen_dev(input, "keyup", /*handleRegexChange*/ ctx[7], false, false, false),
    					listen_dev(select0, "change", /*handleType*/ ctx[8], false, false, false),
    					listen_dev(select1, "change", /*handleRating*/ ctx[11], false, false, false),
    					listen_dev(button0, "click", /*handleApply*/ ctx[10], false, false, false),
    					listen_dev(button1, "click", /*loadItems*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*customRegex*/ 64 && input.value !== /*customRegex*/ ctx[6]) {
    				set_input_value(input, /*customRegex*/ ctx[6]);
    			}

    			if (!current || dirty & /*newRating*/ 4 && option3_selected_value !== (option3_selected_value = /*newRating*/ ctx[2] === 1)) {
    				prop_dev(option3, "selected", option3_selected_value);
    			}

    			if (!current || dirty & /*newRating*/ 4 && option4_selected_value !== (option4_selected_value = /*newRating*/ ctx[2] === 2)) {
    				prop_dev(option4, "selected", option4_selected_value);
    			}

    			if (!current || dirty & /*newRating*/ 4 && option5_selected_value !== (option5_selected_value = /*newRating*/ ctx[2] === 3)) {
    				prop_dev(option5, "selected", option5_selected_value);
    			}

    			if (!current || dirty & /*newRating*/ 4 && option6_selected_value !== (option6_selected_value = /*newRating*/ ctx[2] === 4)) {
    				prop_dev(option6, "selected", option6_selected_value);
    			}

    			if (!current || dirty & /*newRating*/ 4 && option7_selected_value !== (option7_selected_value = /*newRating*/ ctx[2] === 5)) {
    				prop_dev(option7, "selected", option7_selected_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t17);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleToggleAll(e) {
    	let allCheckboxes = document.querySelectorAll("#massRater tbody input[type=checkbox]");
    	allCheckboxes.forEach(element => element.checked = !!e.target.checked);
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MassRater", slots, []);
    	let data = [];
    	let type = "song";
    	let newRating = 3;
    	let logic;
    	let loading = true;
    	let limit = 100;
    	let showArtist = false;
    	let showAlbum = false;
    	let timeout;
    	let customRegex = "";

    	function handleRegexChange(event) {
    		clearTimeout(timeout);

    		timeout = setTimeout(
    			function () {
    				let chars = event.target.value;

    				if (chars.length >= 3) {
    					loadItems();
    				}
    			},
    			600
    		);
    	}

    	function handleType(e) {
    		$$invalidate(1, type = e.target.value);
    		loadItems();
    	}

    	async function loadItems() {
    		switch (type) {
    			case "song":
    				logic = unratedSongs;
    				$$invalidate(5, showAlbum = true);
    				$$invalidate(4, showArtist = true);
    				break;
    			case "album":
    				logic = unratedAlbums;
    				$$invalidate(5, showAlbum = false);
    				$$invalidate(4, showArtist = true);
    				break;
    			case "artist":
    				logic = unratedArtists;
    				$$invalidate(5, showAlbum = false);
    				$$invalidate(4, showArtist = false);
    				break;
    		}

    		$$invalidate(3, loading = true);
    		$$invalidate(0, data = await logic({ query: customRegex, limit }));
    		$$invalidate(3, loading = false);
    	}

    	function handleApply() {
    		let checkedBoxes = document.querySelectorAll("#massRater tbody input[type=checkbox]:checked");

    		checkedBoxes.forEach(async function (element) {
    			await setRating(type, element.id, newRating);
    			element.closest("tr").hidden = true;
    		});
    	}

    	function handleRating(e) {
    		$$invalidate(2, newRating = parseInt(e.target.value));
    	}

    	onMount(() => {
    		loadItems();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MassRater> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		customRegex = this.value;
    		$$invalidate(6, customRegex);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		unratedArtists,
    		unratedAlbums,
    		unratedSongs,
    		setRating,
    		Link,
    		Rating,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		data,
    		type,
    		newRating,
    		logic,
    		loading,
    		limit,
    		showArtist,
    		showAlbum,
    		timeout,
    		customRegex,
    		handleRegexChange,
    		handleType,
    		loadItems,
    		handleToggleAll,
    		handleApply,
    		handleRating
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("newRating" in $$props) $$invalidate(2, newRating = $$props.newRating);
    		if ("logic" in $$props) logic = $$props.logic;
    		if ("loading" in $$props) $$invalidate(3, loading = $$props.loading);
    		if ("limit" in $$props) limit = $$props.limit;
    		if ("showArtist" in $$props) $$invalidate(4, showArtist = $$props.showArtist);
    		if ("showAlbum" in $$props) $$invalidate(5, showAlbum = $$props.showAlbum);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("customRegex" in $$props) $$invalidate(6, customRegex = $$props.customRegex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		type,
    		newRating,
    		loading,
    		showArtist,
    		showAlbum,
    		customRegex,
    		handleRegexChange,
    		handleType,
    		loadItems,
    		handleApply,
    		handleRating,
    		input_input_handler
    	];
    }

    class MassRater extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MassRater",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\views\unrated.svelte generated by Svelte v3.38.3 */
    const file$4 = "src\\views\\unrated.svelte";

    // (21:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>
    function create_default_slot$3(ctx) {
    	let div0;
    	let cardlist0;
    	let t0;
    	let cardlist1;
    	let t1;
    	let cardlist2;
    	let t2;
    	let div1;
    	let massrater;
    	let current;

    	cardlist0 = new CardList({
    			props: {
    				type: "artist",
    				dataProvider: "unratedArtists",
    				limit: "6",
    				refresh: "true",
    				heading: "Artists"
    			},
    			$$inline: true
    		});

    	cardlist1 = new CardList({
    			props: {
    				type: "album",
    				dataProvider: "unratedAlbums",
    				limit: "6",
    				refresh: "true",
    				heading: "Albums"
    			},
    			$$inline: true
    		});

    	cardlist2 = new CardList({
    			props: {
    				type: "song",
    				dataProvider: "unratedSongs",
    				limit: "9",
    				refresh: "true",
    				heading: "Songs"
    			},
    			$$inline: true
    		});

    	massrater = new MassRater({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(cardlist0.$$.fragment);
    			t0 = space();
    			create_component(cardlist1.$$.fragment);
    			t1 = space();
    			create_component(cardlist2.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(massrater.$$.fragment);
    			attr_dev(div0, "class", "random");
    			set_style(div0, "display", /*currentTab*/ ctx[0] === "random" ? "block" : "none");
    			add_location(div0, file$4, 21, 4, 677);
    			attr_dev(div1, "class", "batch");
    			set_style(div1, "display", /*currentTab*/ ctx[0] === "mass" ? "block" : "none");
    			add_location(div1, file$4, 29, 4, 1095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(cardlist0, div0, null);
    			append_dev(div0, t0);
    			mount_component(cardlist1, div0, null);
    			append_dev(div0, t1);
    			mount_component(cardlist2, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(massrater, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div0, "display", /*currentTab*/ ctx[0] === "random" ? "block" : "none");
    			}

    			if (!current || dirty & /*currentTab*/ 1) {
    				set_style(div1, "display", /*currentTab*/ ctx[0] === "mass" ? "block" : "none");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardlist0.$$.fragment, local);
    			transition_in(cardlist1.$$.fragment, local);
    			transition_in(cardlist2.$$.fragment, local);
    			transition_in(massrater.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardlist0.$$.fragment, local);
    			transition_out(cardlist1.$$.fragment, local);
    			transition_out(cardlist2.$$.fragment, local);
    			transition_out(massrater.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(cardlist0);
    			destroy_component(cardlist1);
    			destroy_component(cardlist2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(massrater);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(21:0) <Tabs bind:activeTabValue={currentTab} items={tabItems}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let h1;
    	let t1;
    	let tabs;
    	let updating_activeTabValue;
    	let current;

    	function tabs_activeTabValue_binding(value) {
    		/*tabs_activeTabValue_binding*/ ctx[2](value);
    	}

    	let tabs_props = {
    		items: /*tabItems*/ ctx[1],
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	if (/*currentTab*/ ctx[0] !== void 0) {
    		tabs_props.activeTabValue = /*currentTab*/ ctx[0];
    	}

    	tabs = new Tabs({ props: tabs_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabs, "activeTabValue", tabs_activeTabValue_binding));

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Unrated";
    			t1 = space();
    			create_component(tabs.$$.fragment);
    			add_location(h1, file$4, 18, 0, 595);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope, currentTab*/ 9) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeTabValue && dirty & /*currentTab*/ 1) {
    				updating_activeTabValue = true;
    				tabs_changes.activeTabValue = /*currentTab*/ ctx[0];
    				add_flush_callback(() => updating_activeTabValue = false);
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Unrated", slots, []);

    	let tabItems = [
    		{
    			label: "Random",
    			value: "random",
    			icon: Random$1
    		},
    		{
    			label: "Mass assign",
    			value: "mass",
    			icon: Star_full
    		}
    	];

    	// Current active tab
    	let currentTab;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Unrated> was created with unknown prop '${key}'`);
    	});

    	function tabs_activeTabValue_binding(value) {
    		currentTab = value;
    		$$invalidate(0, currentTab);
    	}

    	$$self.$capture_state = () => ({
    		Tabs,
    		CardList,
    		MassRater,
    		SVGRandom: Random$1,
    		SVGStarFull: Star_full,
    		tabItems,
    		currentTab
    	});

    	$$self.$inject_state = $$props => {
    		if ("tabItems" in $$props) $$invalidate(1, tabItems = $$props.tabItems);
    		if ("currentTab" in $$props) $$invalidate(0, currentTab = $$props.currentTab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentTab, tabItems, tabs_activeTabValue_binding];
    }

    class Unrated extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Unrated",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\views\test.svelte generated by Svelte v3.38.3 */
    const file$3 = "src\\views\\test.svelte";

    // (42:4) {#if isVisible}
    function create_if_block$3(ctx) {
    	let menu;
    	let updating_isVisible;
    	let current;

    	function menu_isVisible_binding(value) {
    		/*menu_isVisible_binding*/ ctx[4](value);
    	}

    	let menu_props = {
    		anchor: /*menuAnchor*/ ctx[1],
    		toggleElement: document.querySelector("#testToggleMenu"),
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	if (/*isVisible*/ ctx[0] !== void 0) {
    		menu_props.isVisible = /*isVisible*/ ctx[0];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "isVisible", menu_isVisible_binding));

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};
    			if (dirty & /*menuAnchor*/ 2) menu_changes.anchor = /*menuAnchor*/ ctx[1];

    			if (dirty & /*$$scope*/ 32) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_isVisible && dirty & /*isVisible*/ 1) {
    				updating_isVisible = true;
    				menu_changes.isVisible = /*isVisible*/ ctx[0];
    				add_flush_callback(() => updating_isVisible = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(42:4) {#if isVisible}",
    		ctx
    	});

    	return block;
    }

    // (43:8) <Menu anchor="{menuAnchor}" toggleElement={document.querySelector("#testToggleMenu")} bind:isVisible>
    function create_default_slot$2(ctx) {
    	let ul;
    	let li0;
    	let t1;
    	let li1;
    	let t3;
    	let li2;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "One";
    			t1 = space();
    			li1 = element("li");
    			li1.textContent = "Two is longer so we can test stuff";
    			t3 = space();
    			li2 = element("li");
    			li2.textContent = "Three";
    			add_location(li0, file$3, 44, 16, 1480);
    			add_location(li1, file$3, 45, 16, 1510);
    			add_location(li2, file$3, 46, 16, 1571);
    			set_style(ul, "margin", "0");
    			add_location(ul, file$3, 43, 12, 1439);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(ul, t3);
    			append_dev(ul, li2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(43:8) <Menu anchor=\\\"{menuAnchor}\\\" toggleElement={document.querySelector(\\\"#testToggleMenu\\\")} bind:isVisible>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let h1;
    	let t1;
    	let section0;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let button2;
    	let t7;
    	let button3;
    	let t9;
    	let section1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let option7;
    	let option8;
    	let option9;
    	let option10;
    	let option11;
    	let t22;
    	let button4;
    	let t23;
    	let t24;
    	let t25;
    	let t26;
    	let section2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*isVisible*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Test page yo";
    			t1 = space();
    			section0 = element("section");
    			button0 = element("button");
    			button0.textContent = "Danger";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Warning";
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Primary";
    			t7 = space();
    			button3 = element("button");
    			button3.textContent = "Secondary";
    			t9 = space();
    			section1 = element("section");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "left-top";
    			option1 = element("option");
    			option1.textContent = "left-center";
    			option2 = element("option");
    			option2.textContent = "left-bottom";
    			option3 = element("option");
    			option3.textContent = "top-left";
    			option4 = element("option");
    			option4.textContent = "top-center";
    			option5 = element("option");
    			option5.textContent = "top-right";
    			option6 = element("option");
    			option6.textContent = "right-top";
    			option7 = element("option");
    			option7.textContent = "right-center";
    			option8 = element("option");
    			option8.textContent = "right-bottom";
    			option9 = element("option");
    			option9.textContent = "bottom-left";
    			option10 = element("option");
    			option10.textContent = "bottom-center";
    			option11 = element("option");
    			option11.textContent = "bottom-right";
    			t22 = space();
    			button4 = element("button");
    			t23 = text("Menu ");
    			t24 = text(/*menuAnchor*/ ctx[1]);
    			t25 = space();
    			if (if_block) if_block.c();
    			t26 = space();
    			section2 = element("section");
    			add_location(h1, file$3, 11, 0, 196);
    			attr_dev(button0, "class", "danger");
    			add_location(button0, file$3, 14, 4, 236);
    			attr_dev(button1, "class", "warning");
    			add_location(button1, file$3, 15, 4, 280);
    			attr_dev(button2, "class", "primary");
    			add_location(button2, file$3, 16, 4, 326);
    			attr_dev(button3, "class", "secondary");
    			add_location(button3, file$3, 17, 4, 372);
    			add_location(section0, file$3, 13, 0, 221);
    			option0.__value = "left-top";
    			option0.value = option0.__value;
    			add_location(option0, file$3, 22, 8, 503);
    			option1.__value = "left-center";
    			option1.value = option1.__value;
    			add_location(option1, file$3, 23, 8, 555);
    			option2.__value = "left-bottom";
    			option2.value = option2.__value;
    			option2.selected = true;
    			add_location(option2, file$3, 24, 8, 613);
    			option3.__value = "top-left";
    			option3.value = option3.__value;
    			add_location(option3, file$3, 26, 8, 682);
    			option4.__value = "top-center";
    			option4.value = option4.__value;
    			add_location(option4, file$3, 27, 8, 734);
    			option5.__value = "top-right";
    			option5.value = option5.__value;
    			add_location(option5, file$3, 28, 8, 790);
    			option6.__value = "right-top";
    			option6.value = option6.__value;
    			add_location(option6, file$3, 30, 8, 846);
    			option7.__value = "right-center";
    			option7.value = option7.__value;
    			add_location(option7, file$3, 31, 8, 900);
    			option8.__value = "right-bottom";
    			option8.value = option8.__value;
    			add_location(option8, file$3, 32, 8, 960);
    			option9.__value = "bottom-left";
    			option9.value = option9.__value;
    			add_location(option9, file$3, 34, 8, 1022);
    			option10.__value = "bottom-center";
    			option10.value = option10.__value;
    			add_location(option10, file$3, 35, 8, 1080);
    			option11.__value = "bottom-right";
    			option11.value = option11.__value;
    			add_location(option11, file$3, 36, 8, 1142);
    			if (/*menuAnchor*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[3].call(select));
    			add_location(select, file$3, 21, 4, 461);
    			attr_dev(button4, "id", "testToggleMenu");
    			add_location(button4, file$3, 39, 4, 1215);
    			attr_dev(section1, "class", "menus svelte-738tfc");
    			add_location(section1, file$3, 20, 0, 432);
    			attr_dev(section2, "class", "actions");
    			add_location(section2, file$3, 52, 0, 1648);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section0, anchor);
    			append_dev(section0, button0);
    			append_dev(section0, t3);
    			append_dev(section0, button1);
    			append_dev(section0, t5);
    			append_dev(section0, button2);
    			append_dev(section0, t7);
    			append_dev(section0, button3);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			append_dev(select, option5);
    			append_dev(select, option6);
    			append_dev(select, option7);
    			append_dev(select, option8);
    			append_dev(select, option9);
    			append_dev(select, option10);
    			append_dev(select, option11);
    			select_option(select, /*menuAnchor*/ ctx[1]);
    			append_dev(section1, t22);
    			append_dev(section1, button4);
    			append_dev(button4, t23);
    			append_dev(button4, t24);
    			append_dev(section1, t25);
    			if (if_block) if_block.m(section1, null);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, section2, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[3]),
    					listen_dev(button4, "click", /*toggleMenu*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*menuAnchor*/ 2) {
    				select_option(select, /*menuAnchor*/ ctx[1]);
    			}

    			if (!current || dirty & /*menuAnchor*/ 2) set_data_dev(t24, /*menuAnchor*/ ctx[1]);

    			if (/*isVisible*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isVisible*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(section1);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(section2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Test", slots, []);
    	let isVisible = false;
    	let menuAnchor;

    	function toggleMenu() {
    		$$invalidate(0, isVisible = !isVisible);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Test> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		menuAnchor = select_value(this);
    		$$invalidate(1, menuAnchor);
    	}

    	function menu_isVisible_binding(value) {
    		isVisible = value;
    		$$invalidate(0, isVisible);
    	}

    	$$self.$capture_state = () => ({ Menu, isVisible, menuAnchor, toggleMenu });

    	$$self.$inject_state = $$props => {
    		if ("isVisible" in $$props) $$invalidate(0, isVisible = $$props.isVisible);
    		if ("menuAnchor" in $$props) $$invalidate(1, menuAnchor = $$props.menuAnchor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isVisible,
    		menuAnchor,
    		toggleMenu,
    		select_change_handler,
    		menu_isVisible_binding
    	];
    }

    class Test extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Test",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\views\advancedSearch.svelte generated by Svelte v3.38.3 */

    const { Map: Map_1 } = globals;

    const file$2 = "src\\views\\advancedSearch.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[36] = list;
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i][0];
    	child_ctx[39] = list[i][1];
    	child_ctx[41] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    // (29:20) {:else}
    function create_else_block$1(ctx) {
    	let each_1_anchor;
    	let each_value_3 = /*value*/ ctx[39];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*groupedFieldsToShow*/ 4) {
    				each_value_3 = /*value*/ ctx[39];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(29:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:20) {#if key.length > 0}
    function create_if_block_18(ctx) {
    	let optgroup;
    	let optgroup_label_value;
    	let each_value_2 = /*value*/ ctx[39];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			optgroup = element("optgroup");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(optgroup, "label", optgroup_label_value = /*key*/ ctx[38]);
    			add_location(optgroup, file$2, 23, 24, 812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, optgroup, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(optgroup, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*groupedFieldsToShow*/ 4) {
    				each_value_2 = /*value*/ ctx[39];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(optgroup, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty[0] & /*groupedFieldsToShow*/ 4 && optgroup_label_value !== (optgroup_label_value = /*key*/ ctx[38])) {
    				attr_dev(optgroup, "label", optgroup_label_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(optgroup);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(23:20) {#if key.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (30:24) {#each value as field}
    function create_each_block_3(ctx) {
    	let option;
    	let t_value = /*field*/ ctx[42].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*field*/ ctx[42].id;
    			option.value = option.__value;
    			add_location(option, file$2, 30, 28, 1152);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*groupedFieldsToShow*/ 4 && t_value !== (t_value = /*field*/ ctx[42].label + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*groupedFieldsToShow*/ 4 && option_value_value !== (option_value_value = /*field*/ ctx[42].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(30:24) {#each value as field}",
    		ctx
    	});

    	return block;
    }

    // (25:28) {#each value as field}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*field*/ ctx[42].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*field*/ ctx[42].id;
    			option.value = option.__value;
    			add_location(option, file$2, 25, 32, 922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*groupedFieldsToShow*/ 4 && t_value !== (t_value = /*field*/ ctx[42].label + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*groupedFieldsToShow*/ 4 && option_value_value !== (option_value_value = /*field*/ ctx[42].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(25:28) {#each value as field}",
    		ctx
    	});

    	return block;
    }

    // (22:16) {#each [...groupedFieldsToShow] as [key, value], i}
    function create_each_block_1(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*key*/ ctx[38].length > 0) return create_if_block_18;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(22:16) {#each [...groupedFieldsToShow] as [key, value], i}",
    		ctx
    	});

    	return block;
    }

    // (39:12) {#if row.operatorType === "string"}
    function create_if_block_17(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let option7;
    	let option8;
    	let option9;
    	let mounted;
    	let dispose;

    	function select_change_handler_1() {
    		/*select_change_handler_1*/ ctx[13].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "contains";
    			option1 = element("option");
    			option1.textContent = "does not contain";
    			option2 = element("option");
    			option2.textContent = "starts with";
    			option3 = element("option");
    			option3.textContent = "ends with";
    			option4 = element("option");
    			option4.textContent = "is";
    			option5 = element("option");
    			option5.textContent = "is not";
    			option6 = element("option");
    			option6.textContent = "sounds like";
    			option7 = element("option");
    			option7.textContent = "does not sound like";
    			option8 = element("option");
    			option8.textContent = "matches regular expression";
    			option9 = element("option");
    			option9.textContent = "does not match regular expression";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 40, 20, 1468);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 41, 20, 1525);
    			option2.__value = "2";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 42, 20, 1590);
    			option3.__value = "3";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 43, 20, 1650);
    			option4.__value = "4";
    			option4.value = option4.__value;
    			add_location(option4, file$2, 44, 20, 1708);
    			option5.__value = "5";
    			option5.value = option5.__value;
    			add_location(option5, file$2, 45, 20, 1759);
    			option6.__value = "6";
    			option6.value = option6.__value;
    			add_location(option6, file$2, 46, 20, 1814);
    			option7.__value = "7";
    			option7.value = option7.__value;
    			add_location(option7, file$2, 47, 20, 1874);
    			option8.__value = "8";
    			option8.value = option8.__value;
    			add_location(option8, file$2, 48, 20, 1942);
    			option9.__value = "9";
    			option9.value = option9.__value;
    			add_location(option9, file$2, 49, 20, 2017);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_1);
    			add_location(select, file$2, 39, 16, 1412);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			append_dev(select, option5);
    			append_dev(select, option6);
    			append_dev(select, option7);
    			append_dev(select, option8);
    			append_dev(select, option9);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(39:12) {#if row.operatorType === \\\"string\\\"}",
    		ctx
    	});

    	return block;
    }

    // (54:12) {#if row.operatorType === "number"}
    function create_if_block_16(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let mounted;
    	let dispose;

    	function select_change_handler_2() {
    		/*select_change_handler_2*/ ctx[14].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "is greater than or equal to";
    			option1 = element("option");
    			option1.textContent = "is less than or equal to";
    			option2 = element("option");
    			option2.textContent = "equals";
    			option3 = element("option");
    			option3.textContent = "does not equal";
    			option4 = element("option");
    			option4.textContent = "is greater than";
    			option5 = element("option");
    			option5.textContent = "is less than";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 55, 20, 2248);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 56, 20, 2324);
    			option2.__value = "2";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 57, 20, 2397);
    			option3.__value = "3";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 58, 20, 2452);
    			option4.__value = "4";
    			option4.value = option4.__value;
    			add_location(option4, file$2, 59, 20, 2515);
    			option5.__value = "5";
    			option5.value = option5.__value;
    			add_location(option5, file$2, 60, 20, 2579);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_2);
    			add_location(select, file$2, 54, 16, 2192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			append_dev(select, option5);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_2);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(54:12) {#if row.operatorType === \\\"number\\\"}",
    		ctx
    	});

    	return block;
    }

    // (65:12) {#if row.operatorType === "relative"}
    function create_if_block_15(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_3() {
    		/*select_change_handler_3*/ ctx[15].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "before";
    			option1 = element("option");
    			option1.textContent = "after";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 66, 20, 2791);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 67, 20, 2846);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_3);
    			add_location(select, file$2, 65, 16, 2735);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_3);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(65:12) {#if row.operatorType === \\\"relative\\\"}",
    		ctx
    	});

    	return block;
    }

    // (72:12) {#if row.operatorType === "relative_x_days"}
    function create_if_block_14(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_4() {
    		/*select_change_handler_4*/ ctx[16].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "before (x) days ago";
    			option1 = element("option");
    			option1.textContent = "after (x) days ago";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 73, 20, 3058);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 74, 20, 3126);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_4);
    			add_location(select, file$2, 72, 16, 3002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_4);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(72:12) {#if row.operatorType === \\\"relative_x_days\\\"}",
    		ctx
    	});

    	return block;
    }

    // (79:12) {#if row.operatorType === "rating_expanded"}
    function create_if_block_13(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let mounted;
    	let dispose;

    	function select_change_handler_5() {
    		/*select_change_handler_5*/ ctx[17].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "has loved";
    			option1 = element("option");
    			option1.textContent = "has rated 5 stars";
    			option2 = element("option");
    			option2.textContent = "has rated 4 stars";
    			option3 = element("option");
    			option3.textContent = "has rated 3 stars";
    			option4 = element("option");
    			option4.textContent = "has rated 2 stars";
    			option5 = element("option");
    			option5.textContent = "has rated 1 stars";
    			option6 = element("option");
    			option6.textContent = "has not rated";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 80, 20, 3351);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 81, 20, 3409);
    			option2.__value = "2";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 82, 20, 3475);
    			option3.__value = "3";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 83, 20, 3541);
    			option4.__value = "4";
    			option4.value = option4.__value;
    			add_location(option4, file$2, 84, 20, 3607);
    			option5.__value = "5";
    			option5.value = option5.__value;
    			add_location(option5, file$2, 85, 20, 3673);
    			option6.__value = "6";
    			option6.value = option6.__value;
    			add_location(option6, file$2, 86, 20, 3739);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_5);
    			add_location(select, file$2, 79, 16, 3295);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			append_dev(select, option5);
    			append_dev(select, option6);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_5);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(79:12) {#if row.operatorType === \\\"rating_expanded\\\"}",
    		ctx
    	});

    	return block;
    }

    // (91:12) {#if row.operatorType === "limit"}
    function create_if_block_12(ctx) {
    	let label;
    	let input;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t = text("\r\n                    limit");
    			attr_dev(input, "name", "banana");
    			attr_dev(input, "type", "radio");
    			input.value = "0";
    			input.checked = true;
    			input.readOnly = true;
    			input.hidden = true;
    			add_location(input, file$2, 92, 20, 3922);
    			attr_dev(label, "class", "svelte-1ad80nx");
    			add_location(label, file$2, 91, 16, 3893);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			append_dev(label, t);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(91:12) {#if row.operatorType === \\\"limit\\\"}",
    		ctx
    	});

    	return block;
    }

    // (98:12) {#if row.operatorType === "true"}
    function create_if_block_11(ctx) {
    	let label;
    	let input;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t = text("\r\n                    is true");
    			attr_dev(input, "name", "apple");
    			attr_dev(input, "type", "radio");
    			input.value = "0";
    			input.checked = true;
    			input.readOnly = true;
    			input.hidden = true;
    			add_location(input, file$2, 99, 20, 4160);
    			attr_dev(label, "class", "svelte-1ad80nx");
    			add_location(label, file$2, 98, 16, 4131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			append_dev(label, t);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(98:12) {#if row.operatorType === \\\"true\\\"}",
    		ctx
    	});

    	return block;
    }

    // (105:12) {#if row.operatorType === "boolean_true"}
    function create_if_block_10(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_6() {
    		/*select_change_handler_6*/ ctx[18].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "is true";
    			option1 = element("option");
    			option1.textContent = "is false";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 106, 20, 4434);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 107, 20, 4490);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_6);
    			add_location(select, file$2, 105, 16, 4378);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_6);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(105:12) {#if row.operatorType === \\\"boolean_true\\\"}",
    		ctx
    	});

    	return block;
    }

    // (112:12) {#if row.operatorType === "boolean_is"}
    function create_if_block_9(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_7() {
    		/*select_change_handler_7*/ ctx[19].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "is";
    			option1 = element("option");
    			option1.textContent = "is not";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 113, 20, 4700);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 114, 20, 4751);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].operator === void 0) add_render_callback(select_change_handler_7);
    			add_location(select, file$2, 112, 16, 4644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].operator);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_7);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].operator);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(112:12) {#if row.operatorType === \\\"boolean_is\\\"}",
    		ctx
    	});

    	return block;
    }

    // (121:12) {#if row.inputType === "text"}
    function create_if_block_8(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[20].call(input, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "svelte-1ad80nx");
    			add_location(input, file$2, 121, 16, 4925);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32 && input.value !== /*row*/ ctx[35].input) {
    				set_input_value(input, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(121:12) {#if row.inputType === \\\"text\\\"}",
    		ctx
    	});

    	return block;
    }

    // (125:12) {#if row.inputType === "number"}
    function create_if_block_7(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[21].call(input, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "number");
    			attr_dev(input, "class", "svelte-1ad80nx");
    			add_location(input, file$2, 125, 16, 5054);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32 && to_number(input.value) !== /*row*/ ctx[35].input) {
    				set_input_value(input, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(125:12) {#if row.inputType === \\\"number\\\"}",
    		ctx
    	});

    	return block;
    }

    // (129:12) {#if row.inputType === "rating"}
    function create_if_block_6(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let mounted;
    	let dispose;

    	function select_change_handler_8() {
    		/*select_change_handler_8*/ ctx[22].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "0 Stars";
    			option1 = element("option");
    			option1.textContent = "1 Star";
    			option2 = element("option");
    			option2.textContent = "2 Stars";
    			option3 = element("option");
    			option3.textContent = "3 Stars";
    			option4 = element("option");
    			option4.textContent = "4 Stars";
    			option5 = element("option");
    			option5.textContent = "5 Stars";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 130, 20, 5238);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 131, 20, 5294);
    			option2.__value = "2";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 132, 20, 5349);
    			option3.__value = "3";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 133, 20, 5405);
    			option4.__value = "4";
    			option4.value = option4.__value;
    			add_location(option4, file$2, 134, 20, 5461);
    			option5.__value = "5";
    			option5.value = option5.__value;
    			add_location(option5, file$2, 135, 20, 5517);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].input === void 0) add_render_callback(select_change_handler_8);
    			add_location(select, file$2, 129, 16, 5185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			append_dev(select, option5);
    			select_option(select, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_8);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(129:12) {#if row.inputType === \\\"rating\\\"}",
    		ctx
    	});

    	return block;
    }

    // (140:12) {#if row.inputType === "user"}
    function create_if_block_5(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_9() {
    		/*select_change_handler_9*/ ctx[23].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "TBA user 1";
    			option1 = element("option");
    			option1.textContent = "TBA user 2";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 141, 20, 5714);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 142, 20, 5773);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].input === void 0) add_render_callback(select_change_handler_9);
    			add_location(select, file$2, 140, 16, 5661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_9);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(140:12) {#if row.inputType === \\\"user\\\"}",
    		ctx
    	});

    	return block;
    }

    // (147:12) {#if row.inputType === "catalog"}
    function create_if_block_4(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_10() {
    		/*select_change_handler_10*/ ctx[24].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "TBA catalog 1";
    			option1 = element("option");
    			option1.textContent = "TBA catalog 2";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 148, 20, 5976);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 149, 20, 6038);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].input === void 0) add_render_callback(select_change_handler_10);
    			add_location(select, file$2, 147, 16, 5923);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_10);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(147:12) {#if row.inputType === \\\"catalog\\\"}",
    		ctx
    	});

    	return block;
    }

    // (154:12) {#if row.inputType === "playlist"}
    function create_if_block_3(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_11() {
    		/*select_change_handler_11*/ ctx[25].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "TBA playlist 1";
    			option1 = element("option");
    			option1.textContent = "TBA playlist 2";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 155, 20, 6245);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 156, 20, 6308);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].input === void 0) add_render_callback(select_change_handler_11);
    			add_location(select, file$2, 154, 16, 6192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_11);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(154:12) {#if row.inputType === \\\"playlist\\\"}",
    		ctx
    	});

    	return block;
    }

    // (161:12) {#if row.inputType === "smartlist"}
    function create_if_block_2$1(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;

    	function select_change_handler_12() {
    		/*select_change_handler_12*/ ctx[26].call(select, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "TBA smartlist 1";
    			option1 = element("option");
    			option1.textContent = "TBA smartlist 2";
    			option0.__value = "0";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 162, 20, 6517);
    			option1.__value = "1";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 163, 20, 6581);
    			attr_dev(select, "class", "svelte-1ad80nx");
    			if (/*row*/ ctx[35].input === void 0) add_render_callback(select_change_handler_12);
    			add_location(select, file$2, 161, 16, 6464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler_12);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				select_option(select, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(161:12) {#if row.inputType === \\\"smartlist\\\"}",
    		ctx
    	});

    	return block;
    }

    // (168:12) {#if row.inputType === "" || row.inputType === null}
    function create_if_block_1$1(ctx) {
    	let span;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_2() {
    		/*input_input_handler_2*/ ctx[27].call(input, /*each_value*/ ctx[36], /*row_index*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			input = element("input");
    			attr_dev(input, "type", "hidden");
    			add_location(input, file$2, 169, 20, 6783);
    			attr_dev(span, "class", "svelte-1ad80nx");
    			add_location(span, file$2, 168, 16, 6755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, input);
    			set_input_value(input, /*row*/ ctx[35].input);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_2);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rows*/ 32) {
    				set_input_value(input, /*row*/ ctx[35].input);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(168:12) {#if row.inputType === \\\"\\\" || row.inputType === null}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#each rows as row (row.id)}
    function create_each_block(key_1, ctx) {
    	let div;
    	let select;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let t17;
    	let mounted;
    	let dispose;
    	let each_value_1 = [.../*groupedFieldsToShow*/ ctx[2]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	function change_handler(...args) {
    		return /*change_handler*/ ctx[12](/*row*/ ctx[35], ...args);
    	}

    	let if_block0 = /*row*/ ctx[35].operatorType === "string" && create_if_block_17(ctx);
    	let if_block1 = /*row*/ ctx[35].operatorType === "number" && create_if_block_16(ctx);
    	let if_block2 = /*row*/ ctx[35].operatorType === "relative" && create_if_block_15(ctx);
    	let if_block3 = /*row*/ ctx[35].operatorType === "relative_x_days" && create_if_block_14(ctx);
    	let if_block4 = /*row*/ ctx[35].operatorType === "rating_expanded" && create_if_block_13(ctx);
    	let if_block5 = /*row*/ ctx[35].operatorType === "limit" && create_if_block_12(ctx);
    	let if_block6 = /*row*/ ctx[35].operatorType === "true" && create_if_block_11(ctx);
    	let if_block7 = /*row*/ ctx[35].operatorType === "boolean_true" && create_if_block_10(ctx);
    	let if_block8 = /*row*/ ctx[35].operatorType === "boolean_is" && create_if_block_9(ctx);
    	let if_block9 = /*row*/ ctx[35].inputType === "text" && create_if_block_8(ctx);
    	let if_block10 = /*row*/ ctx[35].inputType === "number" && create_if_block_7(ctx);
    	let if_block11 = /*row*/ ctx[35].inputType === "rating" && create_if_block_6(ctx);
    	let if_block12 = /*row*/ ctx[35].inputType === "user" && create_if_block_5(ctx);
    	let if_block13 = /*row*/ ctx[35].inputType === "catalog" && create_if_block_4(ctx);
    	let if_block14 = /*row*/ ctx[35].inputType === "playlist" && create_if_block_3(ctx);
    	let if_block15 = /*row*/ ctx[35].inputType === "smartlist" && create_if_block_2$1(ctx);
    	let if_block16 = (/*row*/ ctx[35].inputType === "" || /*row*/ ctx[35].inputType === null) && create_if_block_1$1(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			t7 = space();
    			if (if_block7) if_block7.c();
    			t8 = space();
    			if (if_block8) if_block8.c();
    			t9 = space();
    			if (if_block9) if_block9.c();
    			t10 = space();
    			if (if_block10) if_block10.c();
    			t11 = space();
    			if (if_block11) if_block11.c();
    			t12 = space();
    			if (if_block12) if_block12.c();
    			t13 = space();
    			if (if_block13) if_block13.c();
    			t14 = space();
    			if (if_block14) if_block14.c();
    			t15 = space();
    			if (if_block15) if_block15.c();
    			t16 = space();
    			if (if_block16) if_block16.c();
    			t17 = space();
    			attr_dev(select, "class", "svelte-1ad80nx");
    			add_location(select, file$2, 20, 12, 627);
    			attr_dev(div, "class", "row svelte-1ad80nx");
    			add_location(div, file$2, 19, 8, 596);
    			this.first = div;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t4);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t5);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t6);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t7);
    			if (if_block7) if_block7.m(div, null);
    			append_dev(div, t8);
    			if (if_block8) if_block8.m(div, null);
    			append_dev(div, t9);
    			if (if_block9) if_block9.m(div, null);
    			append_dev(div, t10);
    			if (if_block10) if_block10.m(div, null);
    			append_dev(div, t11);
    			if (if_block11) if_block11.m(div, null);
    			append_dev(div, t12);
    			if (if_block12) if_block12.m(div, null);
    			append_dev(div, t13);
    			if (if_block13) if_block13.m(div, null);
    			append_dev(div, t14);
    			if (if_block14) if_block14.m(div, null);
    			append_dev(div, t15);
    			if (if_block15) if_block15.m(div, null);
    			append_dev(div, t16);
    			if (if_block16) if_block16.m(div, null);
    			append_dev(div, t17);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", change_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*groupedFieldsToShow*/ 4) {
    				each_value_1 = [.../*groupedFieldsToShow*/ ctx[2]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*row*/ ctx[35].operatorType === "string") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_17(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "number") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_16(ctx);
    					if_block1.c();
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "relative") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_15(ctx);
    					if_block2.c();
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "relative_x_days") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_14(ctx);
    					if_block3.c();
    					if_block3.m(div, t4);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "rating_expanded") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_13(ctx);
    					if_block4.c();
    					if_block4.m(div, t5);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "limit") {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_12(ctx);
    					if_block5.c();
    					if_block5.m(div, t6);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "true") {
    				if (if_block6) ; else {
    					if_block6 = create_if_block_11(ctx);
    					if_block6.c();
    					if_block6.m(div, t7);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "boolean_true") {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);
    				} else {
    					if_block7 = create_if_block_10(ctx);
    					if_block7.c();
    					if_block7.m(div, t8);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (/*row*/ ctx[35].operatorType === "boolean_is") {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);
    				} else {
    					if_block8 = create_if_block_9(ctx);
    					if_block8.c();
    					if_block8.m(div, t9);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "text") {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block_8(ctx);
    					if_block9.c();
    					if_block9.m(div, t10);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "number") {
    				if (if_block10) {
    					if_block10.p(ctx, dirty);
    				} else {
    					if_block10 = create_if_block_7(ctx);
    					if_block10.c();
    					if_block10.m(div, t11);
    				}
    			} else if (if_block10) {
    				if_block10.d(1);
    				if_block10 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "rating") {
    				if (if_block11) {
    					if_block11.p(ctx, dirty);
    				} else {
    					if_block11 = create_if_block_6(ctx);
    					if_block11.c();
    					if_block11.m(div, t12);
    				}
    			} else if (if_block11) {
    				if_block11.d(1);
    				if_block11 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "user") {
    				if (if_block12) {
    					if_block12.p(ctx, dirty);
    				} else {
    					if_block12 = create_if_block_5(ctx);
    					if_block12.c();
    					if_block12.m(div, t13);
    				}
    			} else if (if_block12) {
    				if_block12.d(1);
    				if_block12 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "catalog") {
    				if (if_block13) {
    					if_block13.p(ctx, dirty);
    				} else {
    					if_block13 = create_if_block_4(ctx);
    					if_block13.c();
    					if_block13.m(div, t14);
    				}
    			} else if (if_block13) {
    				if_block13.d(1);
    				if_block13 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "playlist") {
    				if (if_block14) {
    					if_block14.p(ctx, dirty);
    				} else {
    					if_block14 = create_if_block_3(ctx);
    					if_block14.c();
    					if_block14.m(div, t15);
    				}
    			} else if (if_block14) {
    				if_block14.d(1);
    				if_block14 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "smartlist") {
    				if (if_block15) {
    					if_block15.p(ctx, dirty);
    				} else {
    					if_block15 = create_if_block_2$1(ctx);
    					if_block15.c();
    					if_block15.m(div, t16);
    				}
    			} else if (if_block15) {
    				if_block15.d(1);
    				if_block15 = null;
    			}

    			if (/*row*/ ctx[35].inputType === "" || /*row*/ ctx[35].inputType === null) {
    				if (if_block16) {
    					if_block16.p(ctx, dirty);
    				} else {
    					if_block16 = create_if_block_1$1(ctx);
    					if_block16.c();
    					if_block16.m(div, t17);
    				}
    			} else if (if_block16) {
    				if_block16.d(1);
    				if_block16 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    			if (if_block10) if_block10.d();
    			if (if_block11) if_block11.d();
    			if (if_block12) if_block12.d();
    			if (if_block13) if_block13.d();
    			if (if_block14) if_block14.d();
    			if (if_block15) if_block15.d();
    			if (if_block16) if_block16.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(19:4) {#each rows as row (row.id)}",
    		ctx
    	});

    	return block;
    }

    // (181:0) {#if results.length > 0}
    function create_if_block$2(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let previous_key = /*loadedTime*/ ctx[3];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Total: ");
    			t1 = text(/*resultsTotal*/ ctx[4]);
    			t2 = space();
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*resultsTotal*/ 16) set_data_dev(t1, /*resultsTotal*/ ctx[4]);

    			if (dirty[0] & /*loadedTime*/ 8 && safe_not_equal(previous_key, previous_key = /*loadedTime*/ ctx[3])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(181:0) {#if results.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (183:4) {#key loadedTime}
    function create_key_block(ctx) {
    	let lister;
    	let updating_data;
    	let current;

    	function lister_data_binding(value) {
    		/*lister_data_binding*/ ctx[28](value);
    	}

    	let lister_props = { type: "song" };

    	if (/*results*/ ctx[1] !== void 0) {
    		lister_props.data = /*results*/ ctx[1];
    	}

    	lister = new Lister({ props: lister_props, $$inline: true });
    	binding_callbacks.push(() => bind(lister, "data", lister_data_binding));

    	const block = {
    		c: function create() {
    			create_component(lister.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lister, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lister_changes = {};

    			if (!updating_data && dirty[0] & /*results*/ 2) {
    				updating_data = true;
    				lister_changes.data = /*results*/ ctx[1];
    				add_flush_callback(() => updating_data = false);
    			}

    			lister.$set(lister_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lister.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lister.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lister, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(183:4) {#key loadedTime}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let h1;
    	let t1;
    	let label;
    	let t2;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t7;
    	let div0;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map_1();
    	let t12;
    	let div2;
    	let button2;
    	let t14;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*rows*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[35].id;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	let if_block = /*results*/ ctx[1].length > 0 && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Advanced Search";
    			t1 = space();
    			label = element("label");
    			t2 = text("Type:\r\n    ");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Songs";
    			option1 = element("option");
    			option1.textContent = "Albums";
    			option2 = element("option");
    			option2.textContent = "Artists";
    			option3 = element("option");
    			option3.textContent = "Playlists";
    			t7 = space();
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Add another rule";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Clear all";
    			t11 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			div2 = element("div");
    			button2 = element("button");
    			button2.textContent = "Search";
    			t14 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$2, 0, 0, 0);
    			option0.__value = "song";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 5, 8, 129);
    			option1.__value = "album";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 6, 8, 174);
    			option2.__value = "artist";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 7, 8, 221);
    			option3.__value = "playlist";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 8, 8, 270);
    			if (/*selectedObjectType*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[11].call(select));
    			add_location(select, file$2, 4, 4, 52);
    			add_location(label, file$2, 2, 0, 28);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "secondary");
    			add_location(button0, file$2, 13, 4, 353);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "danger");
    			add_location(button1, file$2, 14, 4, 442);
    			add_location(div0, file$2, 12, 0, 342);
    			attr_dev(div1, "class", "container svelte-1ad80nx");
    			add_location(div1, file$2, 17, 0, 529);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "primary");
    			add_location(button2, file$2, 177, 4, 6925);
    			add_location(div2, file$2, 176, 0, 6914);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, label, anchor);
    			append_dev(label, t2);
    			append_dev(label, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			select_option(select, /*selectedObjectType*/ ctx[0]);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(div0, t9);
    			append_dev(div0, button1);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			insert_dev(target, t12, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button2);
    			insert_dev(target, t14, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[11]),
    					listen_dev(select, "change", /*populateFields*/ ctx[8], false, false, false),
    					listen_dev(button0, "click", /*addRow*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*clearAll*/ ctx[7], false, false, false),
    					listen_dev(button2, "click", /*search*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*selectedObjectType*/ 1) {
    				select_option(select, /*selectedObjectType*/ ctx[0]);
    			}

    			if (dirty[0] & /*rows, setField, groupedFieldsToShow*/ 548) {
    				each_value = /*rows*/ ctx[5];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, destroy_block, create_each_block, null, get_each_context);
    			}

    			if (/*results*/ ctx[1].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*results*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t14);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AdvancedSearch", slots, []);
    	let selectedObjectType = "song";
    	let fieldsToShow;
    	let groupedFieldsToShow;
    	let maximum = 0;
    	let isRandom = false;
    	let matchAllRules = true;
    	let loadedTime;
    	let resultsTotal;
    	let results = [];
    	let rows = [];
    	let rowCounter = 0;

    	function addRow() {
    		$$invalidate(5, rows = [...rows, { id: rowCounter, rule: rowCounter + 1 }]);
    		setField(rows[rows.length - 1]);
    		rowCounter++;
    	}

    	function clearAll() {
    		$$invalidate(5, rows = []);
    		rowCounter = 0;
    		addRow();
    	}

    	function populateFields() {
    		let groups = new Map();
    		fieldsToShow = fields.filter(field => field.object_types.find(type => type.id === selectedObjectType));

    		// setup categories based on initial order
    		for (let i = 0; i < fieldsToShow.length; i++) {
    			let item = fieldsToShow[i].object_types.find(type => type.id === selectedObjectType);

    			// apply any overrides while we're at it
    			fieldsToShow[i].label = item.label ? item.label : fieldsToShow[i].label;

    			fieldsToShow[i].category = item.category ? item.category : fieldsToShow[i].category;

    			if (!groups.get(fieldsToShow[i].category)) {
    				groups.set(fieldsToShow[i].category, []);
    			}

    			groups.get(fieldsToShow[i].category).push(fieldsToShow[i]);
    		}

    		// alphabetize each group
    		groups.forEach(group => {
    			group.sort(function (obj1, obj2) {
    				return obj1.label.localeCompare(obj2.label);
    			});
    		});

    		$$invalidate(2, groupedFieldsToShow = groups);
    	}

    	function setField(row, event = null) {
    		// reset operator if type changes
    		$$invalidate(5, rows[row.id].operator = "0", rows);

    		$$invalidate(5, rows[row.id].field = event ? event.target.value : fieldsToShow[0].id, rows);
    		$$invalidate(5, rows[row.id].operatorType = fieldsToShow.find(field => field.id === rows[row.id].field).operatorType, rows);
    		$$invalidate(5, rows[row.id].inputType = fieldsToShow.find(field => field.id === rows[row.id].field).inputType, rows);
    	}

    	async function search() {
    		$$invalidate(1, results = []);
    		$$invalidate(3, loadedTime = null);

    		switch (selectedObjectType) {
    			case "song":
    				$$invalidate(1, results = await getSongsFromAdvancedSearch({
    					rows,
    					limit: maximum,
    					random: isRandom,
    					matchAll: matchAllRules
    				}));
    				break;
    		}

    		// console.debug(results);
    		$$invalidate(3, loadedTime = new Date());
    	}

    	let fields = [
    		{
    			id: "anywhere",
    			label: "Any searchable text",
    			category: "",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "title",
    			label: "Title",
    			category: "Metadata",
    			object_types: [
    				{ id: "song", category: "Song Metadata" },
    				{ id: "album", category: "Album Metadata" },
    				{
    					id: "artist",
    					category: "Artist Metadata",
    					label: "Name"
    				},
    				{
    					id: "playlist",
    					category: "Playlist Metadata",
    					label: "Name"
    				}
    			],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "artist",
    			label: "Artist",
    			category: "Metadata",
    			object_types: [
    				{
    					id: "song",
    					category: "Song Metadata",
    					label: "Song Artist"
    				},
    				{
    					id: "album",
    					category: "Album Metadata",
    					label: "Album Artist"
    				}
    			],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "year",
    			label: "Year",
    			category: "Metadata",
    			object_types: [
    				{ id: "song", category: "Song Metadata" },
    				{ id: "album", category: "Album Metadata" },
    				{
    					id: "artist",
    					category: "Artist Metadata"
    				}
    			],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "tag",
    			label: "Genre",
    			category: "Metadata",
    			object_types: [
    				{ id: "song", category: "Song Metadata" },
    				{ id: "album", category: "Album Metadata" },
    				{
    					id: "artist",
    					category: "Artist Metadata"
    				}
    			],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "album_tag",
    			label: "Album Genre",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "comment",
    			label: "Comment",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "lyrics",
    			label: "Lyrics",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "file",
    			label: "Filename",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "bitrate",
    			label: "Bitrate",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "label",
    			label: "Label",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "artist_tag",
    			label: "Artist Genre",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "album",
    			label: "Album",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "composer",
    			label: "Composer",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "album_artist",
    			label: "Album Artist",
    			category: "Song Metadata",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "original_year",
    			label: "Original Year",
    			category: "Album Metadata",
    			object_types: [{ id: "album" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "release_type",
    			label: "Release Type",
    			category: "Album Metadata",
    			object_types: [{ id: "album" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "release_status",
    			label: "Release Status",
    			category: "Album Metadata",
    			object_types: [{ id: "album" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "yearformed",
    			label: "Year Formed",
    			category: "Artist Metadata",
    			object_types: [{ id: "artist" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "placeformed",
    			label: "Place Formed",
    			category: "Artist Metadata",
    			object_types: [{ id: "artist" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "myrating",
    			label: "My Rating",
    			category: "Rating",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "rating"
    		},
    		{
    			id: "rating",
    			label: "Rating (average)",
    			category: "Rating",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "rating"
    		},
    		{
    			id: "albumrating",
    			label: "My Rating (album)",
    			category: "Rating",
    			object_types: [{ id: "song" }],
    			operatorType: "number",
    			inputType: "rating"
    		},
    		{
    			id: "artistrating",
    			label: "My Rating (artist)",
    			category: "Rating",
    			object_types: [{ id: "song" }, { id: "album" }],
    			operatorType: "number",
    			inputType: "rating"
    		},
    		{
    			id: "favorite",
    			label: "Favorites",
    			category: "Rating",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "favorite_album",
    			label: "Favorites (Album)",
    			category: "Rating",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "favorite_artist",
    			label: "Favorites (Artist)",
    			category: "Rating",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "played_times",
    			label: "# Played",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "skipped_times",
    			label: "# Skipped",
    			category: "Plays",
    			object_types: [{ id: "song" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "played_or_skipped_times",
    			label: "# Played or Skipped",
    			category: "Plays",
    			object_types: [{ id: "song" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "play_skip_ratio",
    			label: "Played/Skipped ratio",
    			category: "Plays",
    			object_types: [{ id: "song" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "recent_played",
    			label: "Recently played",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "limit",
    			inputType: "number"
    		},
    		{
    			id: "last_play",
    			label: "My Last Play",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "relative_x_days",
    			inputType: "number"
    		},
    		{
    			id: "last_skip",
    			label: "My Last Skip",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "relative_x_days",
    			inputType: "number"
    		},
    		{
    			id: "last_play_or_skip",
    			label: "My Last Play or Skip",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "relative_x_days",
    			inputType: "number"
    		},
    		{
    			id: "played",
    			label: "Played",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "boolean_true",
    			inputType: ""
    		},
    		{
    			id: "myplayed",
    			label: "Played by me",
    			category: "Plays",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "boolean_true",
    			inputType: ""
    		},
    		{
    			id: "myplayedalbum",
    			label: "Played by Me (Album)",
    			category: "Plays",
    			object_types: [{ id: "song" }],
    			operatorType: "boolean_true",
    			inputType: ""
    		},
    		{
    			id: "myplayedartist",
    			label: "Played by Me (Artist)",
    			category: "Plays",
    			object_types: [{ id: "song" }],
    			operatorType: "boolean_true",
    			inputType: ""
    		},
    		{
    			id: "other_user",
    			label: "Another User",
    			category: "System",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "rating_expanded",
    			inputType: "user"
    		},
    		{
    			id: "catalog",
    			label: "Catalog",
    			category: "System",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "boolean_is",
    			inputType: "catalog"
    		},
    		{
    			id: "other_user_album",
    			label: "Another User (Album)",
    			category: "System",
    			object_types: [{ id: "song" }],
    			operatorType: "rating_expanded",
    			inputType: "user"
    		},
    		{
    			id: "other_user_artist",
    			label: "Another User (Artist)",
    			category: "System",
    			object_types: [{ id: "song" }],
    			operatorType: "rating_expanded",
    			inputType: "user"
    		},
    		{
    			id: "playlist",
    			label: "Playlist",
    			category: "Playlist",
    			object_types: [{ id: "song" }],
    			operatorType: "boolean_is",
    			inputType: "playlist"
    		},
    		{
    			id: "smartplaylist",
    			label: "Smart Playlist",
    			category: "Playlist",
    			object_types: [{ id: "song" }],
    			operatorType: "boolean_is",
    			inputType: "smartlist"
    		},
    		{
    			id: "playlist_name",
    			label: "Playlist Name",
    			category: "Playlist",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "time",
    			label: "Length (in minutes)",
    			category: "Time",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "added",
    			label: "Added",
    			category: "Time",
    			object_types: [{ id: "song" }],
    			operatorType: "relative",
    			inputType: "number"
    		},
    		{
    			id: "updated",
    			label: "Updated",
    			category: "Time",
    			object_types: [{ id: "song" }],
    			operatorType: "relative",
    			inputType: "number"
    		},
    		{
    			id: "recent_added",
    			label: "Recently added",
    			category: "Time",
    			object_types: [{ id: "song" }],
    			operatorType: "limit",
    			inputType: "number"
    		},
    		{
    			id: "recent_updated",
    			label: "Recently updated",
    			category: "Time",
    			object_types: [{ id: "song" }],
    			operatorType: "limit",
    			inputType: "number"
    		},
    		{
    			id: "mbid",
    			label: "MusicBrainz ID",
    			category: "MusicBrainz",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "mbid_album",
    			label: "MusicBrainz ID (Album)",
    			category: "MusicBrainz",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "mbid_artist",
    			label: "MusicBrainz ID (Artist)",
    			category: "MusicBrainz",
    			object_types: [{ id: "song" }],
    			operatorType: "string",
    			inputType: "text"
    		},
    		{
    			id: "possible_duplicate",
    			label: "Possible Duplicate",
    			category: "System",
    			object_types: [{ id: "song" }, { id: "album" }, { id: "artist" }],
    			operatorType: "true",
    			inputType: ""
    		},
    		{
    			id: "possible_duplicate_album",
    			label: "Possible Duplicate Albums",
    			category: "System",
    			object_types: [{ id: "artist" }],
    			operatorType: "true",
    			inputType: ""
    		},
    		{
    			id: "has_image",
    			label: "Local Image",
    			category: "System",
    			object_types: [{ id: "album" }, { id: "artist" }],
    			operatorType: "true",
    			inputType: ""
    		},
    		{
    			id: "image_width",
    			label: "Image Width",
    			category: "System",
    			object_types: [{ id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "number"
    		},
    		{
    			id: "image_height",
    			label: "Image Height",
    			category: "System",
    			object_types: [{ id: "album" }, { id: "artist" }],
    			operatorType: "number",
    			inputType: "number"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AdvancedSearch> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selectedObjectType = select_value(this);
    		$$invalidate(0, selectedObjectType);
    	}

    	const change_handler = (row, e) => {
    		setField(row, e);
    	};

    	function select_change_handler_1(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_2(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_3(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_4(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_5(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_6(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_7(each_value, row_index) {
    		each_value[row_index].operator = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function input_input_handler(each_value, row_index) {
    		each_value[row_index].input = this.value;
    		$$invalidate(5, rows);
    	}

    	function input_input_handler_1(each_value, row_index) {
    		each_value[row_index].input = to_number(this.value);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_8(each_value, row_index) {
    		each_value[row_index].input = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_9(each_value, row_index) {
    		each_value[row_index].input = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_10(each_value, row_index) {
    		each_value[row_index].input = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_11(each_value, row_index) {
    		each_value[row_index].input = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function select_change_handler_12(each_value, row_index) {
    		each_value[row_index].input = select_value(this);
    		$$invalidate(5, rows);
    	}

    	function input_input_handler_2(each_value, row_index) {
    		each_value[row_index].input = this.value;
    		$$invalidate(5, rows);
    	}

    	function lister_data_binding(value) {
    		results = value;
    		$$invalidate(1, results);
    	}

    	$$self.$capture_state = () => ({
    		getSongsFromAdvancedSearch,
    		Lister,
    		selectedObjectType,
    		fieldsToShow,
    		groupedFieldsToShow,
    		maximum,
    		isRandom,
    		matchAllRules,
    		loadedTime,
    		resultsTotal,
    		results,
    		rows,
    		rowCounter,
    		addRow,
    		clearAll,
    		populateFields,
    		setField,
    		search,
    		fields
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedObjectType" in $$props) $$invalidate(0, selectedObjectType = $$props.selectedObjectType);
    		if ("fieldsToShow" in $$props) fieldsToShow = $$props.fieldsToShow;
    		if ("groupedFieldsToShow" in $$props) $$invalidate(2, groupedFieldsToShow = $$props.groupedFieldsToShow);
    		if ("maximum" in $$props) maximum = $$props.maximum;
    		if ("isRandom" in $$props) isRandom = $$props.isRandom;
    		if ("matchAllRules" in $$props) matchAllRules = $$props.matchAllRules;
    		if ("loadedTime" in $$props) $$invalidate(3, loadedTime = $$props.loadedTime);
    		if ("resultsTotal" in $$props) $$invalidate(4, resultsTotal = $$props.resultsTotal);
    		if ("results" in $$props) $$invalidate(1, results = $$props.results);
    		if ("rows" in $$props) $$invalidate(5, rows = $$props.rows);
    		if ("rowCounter" in $$props) rowCounter = $$props.rowCounter;
    		if ("fields" in $$props) fields = $$props.fields;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*selectedObjectType*/ 1) {
    			// $: console.debug(rows);
    			// reset everything if object type changes
    			{
    				if (selectedObjectType) {
    					populateFields();
    					clearAll();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*results*/ 2) {
    			$$invalidate(4, resultsTotal = results.length);
    		}
    	};

    	return [
    		selectedObjectType,
    		results,
    		groupedFieldsToShow,
    		loadedTime,
    		resultsTotal,
    		rows,
    		addRow,
    		clearAll,
    		populateFields,
    		setField,
    		search,
    		select_change_handler,
    		change_handler,
    		select_change_handler_1,
    		select_change_handler_2,
    		select_change_handler_3,
    		select_change_handler_4,
    		select_change_handler_5,
    		select_change_handler_6,
    		select_change_handler_7,
    		input_input_handler,
    		input_input_handler_1,
    		select_change_handler_8,
    		select_change_handler_9,
    		select_change_handler_10,
    		select_change_handler_11,
    		select_change_handler_12,
    		input_input_handler_2,
    		lister_data_binding
    	];
    }

    class AdvancedSearch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdvancedSearch",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.38.3 */
    const file$1 = "src\\App.svelte";

    // (76:4) {#if $isLoggedIn === null && $userToken === null}
    function create_if_block_2(ctx) {
    	let siteloading;
    	let current;
    	siteloading = new SiteLoading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(siteloading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(siteloading, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(siteloading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(siteloading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(siteloading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(76:4) {#if $isLoggedIn === null && $userToken === null}",
    		ctx
    	});

    	return block;
    }

    // (80:4) {#if $isLoggedIn === false}
    function create_if_block_1(ctx) {
    	let loginpage;
    	let current;
    	loginpage = new Login({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loginpage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginpage, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginpage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(80:4) {#if $isLoggedIn === false}",
    		ctx
    	});

    	return block;
    }

    // (84:4) {#if $isLoggedIn}
    function create_if_block$1(ctx) {
    	let div2;
    	let sidebar;
    	let t0;
    	let div1;
    	let div0;
    	let route0;
    	let t1;
    	let route1;
    	let t2;
    	let route2;
    	let t3;
    	let route3;
    	let t4;
    	let route4;
    	let t5;
    	let route5;
    	let t6;
    	let route6;
    	let t7;
    	let route7;
    	let t8;
    	let route8;
    	let t9;
    	let route9;
    	let t10;
    	let route10;
    	let t11;
    	let route11;
    	let t12;
    	let route12;
    	let t13;
    	let route13;
    	let t14;
    	let route14;
    	let t15;
    	let route15;
    	let t16;
    	let route16;
    	let t17;
    	let route17;
    	let t18;
    	let route18;
    	let t19;
    	let route19;
    	let t20;
    	let route20;
    	let t21;
    	let route21;
    	let t22;
    	let route22;
    	let t23;
    	let route23;
    	let t24;
    	let route24;
    	let t25;
    	let route25;
    	let t26;
    	let route26;
    	let t27;
    	let route27;
    	let t28;
    	let player;
    	let current;
    	sidebar = new Sidebar({ $$inline: true });

    	route0 = new Route({
    			props: { path: "test", component: Test },
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: "search",
    				component: AdvancedSearch
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "artists/all",
    				component: ArtistsAll
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "artists/:id",
    				component: Artist
    			},
    			$$inline: true
    		});

    	route4 = new Route({
    			props: { path: "artists", component: Artists },
    			$$inline: true
    		});

    	route5 = new Route({
    			props: { path: "albums/:id", component: Album },
    			$$inline: true
    		});

    	route6 = new Route({
    			props: { path: "albums/all", component: AlbumsAll },
    			$$inline: true
    		});

    	route7 = new Route({
    			props: {
    				path: "albums/year/:year",
    				component: AlbumsByYear
    			},
    			$$inline: true
    		});

    	route8 = new Route({
    			props: {
    				path: "albums/year",
    				component: AlbumsByYear
    			},
    			$$inline: true
    		});

    	route9 = new Route({
    			props: { path: "albums", component: Albums },
    			$$inline: true
    		});

    	route10 = new Route({
    			props: {
    				path: "playlists/:id",
    				component: Playlist
    			},
    			$$inline: true
    		});

    	route11 = new Route({
    			props: {
    				path: "playlists",
    				component: Playlists
    			},
    			$$inline: true
    		});

    	route12 = new Route({
    			props: {
    				path: "smartlists/:id",
    				component: Playlist
    			},
    			$$inline: true
    		});

    	route13 = new Route({
    			props: {
    				path: "smartlists",
    				component: Smartlists
    			},
    			$$inline: true
    		});

    	route14 = new Route({
    			props: {
    				path: "genres/:id/:type",
    				component: Genre
    			},
    			$$inline: true
    		});

    	route15 = new Route({
    			props: { path: "genres/:id", component: Genre },
    			$$inline: true
    		});

    	route16 = new Route({
    			props: { path: "genres", component: Genres },
    			$$inline: true
    		});

    	route17 = new Route({
    			props: { path: "newest", component: Newest },
    			$$inline: true
    		});

    	route18 = new Route({
    			props: { path: "recent", component: Recent },
    			$$inline: true
    		});

    	route19 = new Route({
    			props: {
    				path: "favorites",
    				component: Favorites
    			},
    			$$inline: true
    		});

    	route20 = new Route({
    			props: {
    				path: "trending",
    				component: Trending
    			},
    			$$inline: true
    		});

    	route21 = new Route({
    			props: { path: "top", component: TopRated },
    			$$inline: true
    		});

    	route22 = new Route({
    			props: {
    				path: "forgotten",
    				component: Forgotten
    			},
    			$$inline: true
    		});

    	route23 = new Route({
    			props: { path: "random", component: Random },
    			$$inline: true
    		});

    	route24 = new Route({
    			props: { path: "unrated", component: Unrated },
    			$$inline: true
    		});

    	route25 = new Route({
    			props: { path: "", component: Home },
    			$$inline: true
    		});

    	route26 = new Route({
    			props: { path: "/", component: Home },
    			$$inline: true
    		});

    	route27 = new Route({
    			props: { path: "*", component: NotFound404 },
    			$$inline: true
    		});

    	player = new Player({ $$inline: true });

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			create_component(sidebar.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			create_component(route0.$$.fragment);
    			t1 = space();
    			create_component(route1.$$.fragment);
    			t2 = space();
    			create_component(route2.$$.fragment);
    			t3 = space();
    			create_component(route3.$$.fragment);
    			t4 = space();
    			create_component(route4.$$.fragment);
    			t5 = space();
    			create_component(route5.$$.fragment);
    			t6 = space();
    			create_component(route6.$$.fragment);
    			t7 = space();
    			create_component(route7.$$.fragment);
    			t8 = space();
    			create_component(route8.$$.fragment);
    			t9 = space();
    			create_component(route9.$$.fragment);
    			t10 = space();
    			create_component(route10.$$.fragment);
    			t11 = space();
    			create_component(route11.$$.fragment);
    			t12 = space();
    			create_component(route12.$$.fragment);
    			t13 = space();
    			create_component(route13.$$.fragment);
    			t14 = space();
    			create_component(route14.$$.fragment);
    			t15 = space();
    			create_component(route15.$$.fragment);
    			t16 = space();
    			create_component(route16.$$.fragment);
    			t17 = space();
    			create_component(route17.$$.fragment);
    			t18 = space();
    			create_component(route18.$$.fragment);
    			t19 = space();
    			create_component(route19.$$.fragment);
    			t20 = space();
    			create_component(route20.$$.fragment);
    			t21 = space();
    			create_component(route21.$$.fragment);
    			t22 = space();
    			create_component(route22.$$.fragment);
    			t23 = space();
    			create_component(route23.$$.fragment);
    			t24 = space();
    			create_component(route24.$$.fragment);
    			t25 = space();
    			create_component(route25.$$.fragment);
    			t26 = space();
    			create_component(route26.$$.fragment);
    			t27 = space();
    			create_component(route27.$$.fragment);
    			t28 = space();
    			create_component(player.$$.fragment);
    			attr_dev(div0, "class", "site-content-inner");
    			add_location(div0, file$1, 87, 16, 3358);
    			attr_dev(div1, "class", "site-content");
    			add_location(div1, file$1, 86, 12, 3314);
    			attr_dev(div2, "class", "site-inner");
    			add_location(div2, file$1, 84, 8, 3252);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			mount_component(sidebar, div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(route0, div0, null);
    			append_dev(div0, t1);
    			mount_component(route1, div0, null);
    			append_dev(div0, t2);
    			mount_component(route2, div0, null);
    			append_dev(div0, t3);
    			mount_component(route3, div0, null);
    			append_dev(div0, t4);
    			mount_component(route4, div0, null);
    			append_dev(div0, t5);
    			mount_component(route5, div0, null);
    			append_dev(div0, t6);
    			mount_component(route6, div0, null);
    			append_dev(div0, t7);
    			mount_component(route7, div0, null);
    			append_dev(div0, t8);
    			mount_component(route8, div0, null);
    			append_dev(div0, t9);
    			mount_component(route9, div0, null);
    			append_dev(div0, t10);
    			mount_component(route10, div0, null);
    			append_dev(div0, t11);
    			mount_component(route11, div0, null);
    			append_dev(div0, t12);
    			mount_component(route12, div0, null);
    			append_dev(div0, t13);
    			mount_component(route13, div0, null);
    			append_dev(div0, t14);
    			mount_component(route14, div0, null);
    			append_dev(div0, t15);
    			mount_component(route15, div0, null);
    			append_dev(div0, t16);
    			mount_component(route16, div0, null);
    			append_dev(div0, t17);
    			mount_component(route17, div0, null);
    			append_dev(div0, t18);
    			mount_component(route18, div0, null);
    			append_dev(div0, t19);
    			mount_component(route19, div0, null);
    			append_dev(div0, t20);
    			mount_component(route20, div0, null);
    			append_dev(div0, t21);
    			mount_component(route21, div0, null);
    			append_dev(div0, t22);
    			mount_component(route22, div0, null);
    			append_dev(div0, t23);
    			mount_component(route23, div0, null);
    			append_dev(div0, t24);
    			mount_component(route24, div0, null);
    			append_dev(div0, t25);
    			mount_component(route25, div0, null);
    			append_dev(div0, t26);
    			mount_component(route26, div0, null);
    			append_dev(div0, t27);
    			mount_component(route27, div0, null);
    			insert_dev(target, t28, anchor);
    			mount_component(player, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sidebar.$$.fragment, local);
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(route11.$$.fragment, local);
    			transition_in(route12.$$.fragment, local);
    			transition_in(route13.$$.fragment, local);
    			transition_in(route14.$$.fragment, local);
    			transition_in(route15.$$.fragment, local);
    			transition_in(route16.$$.fragment, local);
    			transition_in(route17.$$.fragment, local);
    			transition_in(route18.$$.fragment, local);
    			transition_in(route19.$$.fragment, local);
    			transition_in(route20.$$.fragment, local);
    			transition_in(route21.$$.fragment, local);
    			transition_in(route22.$$.fragment, local);
    			transition_in(route23.$$.fragment, local);
    			transition_in(route24.$$.fragment, local);
    			transition_in(route25.$$.fragment, local);
    			transition_in(route26.$$.fragment, local);
    			transition_in(route27.$$.fragment, local);
    			transition_in(player.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sidebar.$$.fragment, local);
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(route11.$$.fragment, local);
    			transition_out(route12.$$.fragment, local);
    			transition_out(route13.$$.fragment, local);
    			transition_out(route14.$$.fragment, local);
    			transition_out(route15.$$.fragment, local);
    			transition_out(route16.$$.fragment, local);
    			transition_out(route17.$$.fragment, local);
    			transition_out(route18.$$.fragment, local);
    			transition_out(route19.$$.fragment, local);
    			transition_out(route20.$$.fragment, local);
    			transition_out(route21.$$.fragment, local);
    			transition_out(route22.$$.fragment, local);
    			transition_out(route23.$$.fragment, local);
    			transition_out(route24.$$.fragment, local);
    			transition_out(route25.$$.fragment, local);
    			transition_out(route26.$$.fragment, local);
    			transition_out(route27.$$.fragment, local);
    			transition_out(player.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(sidebar);
    			destroy_component(route0);
    			destroy_component(route1);
    			destroy_component(route2);
    			destroy_component(route3);
    			destroy_component(route4);
    			destroy_component(route5);
    			destroy_component(route6);
    			destroy_component(route7);
    			destroy_component(route8);
    			destroy_component(route9);
    			destroy_component(route10);
    			destroy_component(route11);
    			destroy_component(route12);
    			destroy_component(route13);
    			destroy_component(route14);
    			destroy_component(route15);
    			destroy_component(route16);
    			destroy_component(route17);
    			destroy_component(route18);
    			destroy_component(route19);
    			destroy_component(route20);
    			destroy_component(route21);
    			destroy_component(route22);
    			destroy_component(route23);
    			destroy_component(route24);
    			destroy_component(route25);
    			destroy_component(route26);
    			destroy_component(route27);
    			if (detaching) detach_dev(t28);
    			destroy_component(player, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(84:4) {#if $isLoggedIn}",
    		ctx
    	});

    	return block;
    }

    // (75:0) <Router basepath="/ample">
    function create_default_slot$1(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*$isLoggedIn*/ ctx[0] === null && /*$userToken*/ ctx[1] === null && create_if_block_2(ctx);
    	let if_block1 = /*$isLoggedIn*/ ctx[0] === false && create_if_block_1(ctx);
    	let if_block2 = /*$isLoggedIn*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$isLoggedIn*/ ctx[0] === null && /*$userToken*/ ctx[1] === null) {
    				if (if_block0) {
    					if (dirty & /*$isLoggedIn, $userToken*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$isLoggedIn*/ ctx[0] === false) {
    				if (if_block1) {
    					if (dirty & /*$isLoggedIn*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$isLoggedIn*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$isLoggedIn*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(75:0) <Router basepath=\\\"/ample\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let themehandler;
    	let t;
    	let router;
    	let current;
    	themehandler = new ThemeHandler({ $$inline: true });

    	router = new Router({
    			props: {
    				basepath: "/ample",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(themehandler.$$.fragment);
    			t = space();
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(themehandler, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, $isLoggedIn, $userToken*/ 19) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(themehandler.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(themehandler.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(themehandler, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $MediaPlayer;
    	let $isLoggedIn;
    	let $userToken;
    	validate_store(MediaPlayer, "MediaPlayer");
    	component_subscribe($$self, MediaPlayer, $$value => $$invalidate(2, $MediaPlayer = $$value));
    	validate_store(isLoggedIn, "isLoggedIn");
    	component_subscribe($$self, isLoggedIn, $$value => $$invalidate(0, $isLoggedIn = $$value));
    	validate_store(userToken, "userToken");
    	component_subscribe($$self, userToken, $$value => $$invalidate(1, $userToken = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	overrideItemIdKeyNameBeforeInitialisingDndZones("_id");
    	validateAuthToken();

    	let intervalId = window.setInterval(
    		function () {
    			extendSession();
    		},
    		1000 * 60 * 15
    	);

    	// reset scroll position after each 'page' load
    	history.pushState = new Proxy(history.pushState,
    	{
    			apply(target, thisArg, argumentsList) {
    				$MediaPlayer.setWaveColors();
    				document.querySelector(".site-content-inner").scrollTop = 0;
    				Reflect.apply(target, thisArg, argumentsList);
    			}
    		});

    	onMount(async () => {
    		// get Ampache server version
    		serverVersion.set(await getServerVersion());
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Router,
    		Route,
    		serverVersion,
    		isLoggedIn,
    		userToken,
    		MediaPlayer,
    		validateAuthToken,
    		extendSession,
    		getServerVersion,
    		overrideItemIdKeyNameBeforeInitialisingDndZones,
    		ThemeHandler,
    		SiteLoading,
    		Sidebar,
    		Player,
    		LoginPage: Login,
    		NotFound404Page: NotFound404,
    		HomePage: Home,
    		ArtistsPage: Artists,
    		ArtistsAll,
    		ArtistPage: Artist,
    		AlbumsPage: Albums,
    		AlbumsAll,
    		AlbumsByYearPage: AlbumsByYear,
    		AlbumPage: Album,
    		PlaylistsPage: Playlists,
    		PlaylistPage: Playlist,
    		SmartlistsPage: Smartlists,
    		GenresPage: Genres,
    		GenrePage: Genre,
    		NewestPage: Newest,
    		RecentPage: Recent,
    		FavoritesPage: Favorites,
    		TrendingPage: Trending,
    		TopRatedPage: TopRated,
    		ForgottenPage: Forgotten,
    		RandomPage: Random,
    		UnratedPage: Unrated,
    		TestPage: Test,
    		AdvancedSearchPage: AdvancedSearch,
    		intervalId,
    		$MediaPlayer,
    		$isLoggedIn,
    		$userToken
    	});

    	$$self.$inject_state = $$props => {
    		if ("intervalId" in $$props) intervalId = $$props.intervalId;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$isLoggedIn, $userToken];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    let app = new App({
        target: document.body
    });

    /* src\components\songCard.svelte generated by Svelte v3.38.3 */
    const file = "src\\components\\songCard.svelte";

    // (44:4) {:else}
    function create_else_block(ctx) {
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div7;
    	let div4;
    	let div1;
    	let t2;
    	let div2;
    	let br0;
    	let t3;
    	let div3;
    	let br1;
    	let t4;
    	let div6;
    	let rating;
    	let t5;
    	let div5;
    	let actions;
    	let current;
    	rating = new Rating({ $$inline: true });

    	actions = new Actions({
    			props: { type: "song", mode: "miniButtons" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div1.textContent = "Loading";
    			t2 = space();
    			div2 = element("div");
    			br0 = element("br");
    			t3 = space();
    			div3 = element("div");
    			br1 = element("br");
    			t4 = space();
    			div6 = element("div");
    			create_component(rating.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(img, "class", "image svelte-15yz0wi");
    			attr_dev(img, "height", "200");
    			attr_dev(img, "width", "200");
    			if (img.src !== (img_src_value = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file, 45, 12, 1727);
    			attr_dev(div0, "class", "image-container svelte-15yz0wi");
    			add_location(div0, file, 44, 8, 1684);
    			attr_dev(div1, "class", "title svelte-15yz0wi");
    			add_location(div1, file, 50, 16, 1962);
    			add_location(br0, file, 51, 36, 2032);
    			attr_dev(div2, "class", "artist svelte-15yz0wi");
    			add_location(div2, file, 51, 16, 2012);
    			add_location(br1, file, 52, 35, 2079);
    			attr_dev(div3, "class", "album svelte-15yz0wi");
    			add_location(div3, file, 52, 16, 2060);
    			attr_dev(div4, "class", "details");
    			add_location(div4, file, 49, 12, 1923);
    			attr_dev(div5, "class", "actions svelte-15yz0wi");
    			add_location(div5, file, 58, 16, 2204);
    			attr_dev(div6, "class", "actions-container svelte-15yz0wi");
    			add_location(div6, file, 55, 12, 2125);
    			attr_dev(div7, "class", "info svelte-15yz0wi");
    			add_location(div7, file, 48, 8, 1891);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, img);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div4, div1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div2, br0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, br1);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			mount_component(rating, div6, null);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			mount_component(actions, div5, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div7);
    			destroy_component(rating);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(44:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if song}
    function create_if_block(ctx) {
    	let div0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t0;
    	let div7;
    	let div4;
    	let div1;
    	let t1_value = /*song*/ ctx[0].name + "";
    	let t1;
    	let div1_title_value;
    	let t2;
    	let div2;
    	let link0;
    	let t3;
    	let div3;
    	let link1;
    	let t4;
    	let div6;
    	let rating;
    	let t5;
    	let div5;
    	let actions;
    	let current;

    	link0 = new Link({
    			props: {
    				to: "artists/" + /*song*/ ctx[0].artist.id,
    				title: /*song*/ ctx[0].artist.name,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "albums/" + /*song*/ ctx[0].album.id,
    				title: /*song*/ ctx[0].album.name,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	rating = new Rating({
    			props: {
    				type: "song",
    				id: /*song*/ ctx[0].id,
    				rating: /*song*/ ctx[0].rating,
    				flag: /*song*/ ctx[0].flag,
    				averageRating: /*song*/ ctx[0].averagerating
    			},
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				type: "song",
    				mode: "miniButtons",
    				id: /*song*/ ctx[0].id,
    				count: "1",
    				albumID: /*song*/ ctx[0].album.id,
    				artistID: /*song*/ ctx[0].artist.id
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			create_component(link0.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(link1.$$.fragment);
    			t4 = space();
    			div6 = element("div");
    			create_component(rating.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(actions.$$.fragment);
    			attr_dev(img, "class", "image svelte-15yz0wi");
    			attr_dev(img, "height", "200");
    			attr_dev(img, "width", "200");
    			if (img.src !== (img_src_value = "" + (/*song*/ ctx[0].art + "&thumb=22"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = "Image of " + /*song*/ ctx[0].name);
    			attr_dev(img, "loading", "lazy");
    			add_location(img, file, 18, 12, 464);
    			attr_dev(div0, "class", "image-container svelte-15yz0wi");
    			add_location(div0, file, 17, 8, 421);
    			attr_dev(div1, "class", "title svelte-15yz0wi");
    			attr_dev(div1, "title", div1_title_value = /*song*/ ctx[0].name);
    			add_location(div1, file, 23, 16, 675);
    			attr_dev(div2, "class", "artist svelte-15yz0wi");
    			add_location(div2, file, 24, 16, 749);
    			attr_dev(div3, "class", "album svelte-15yz0wi");
    			add_location(div3, file, 25, 16, 909);
    			attr_dev(div4, "class", "details");
    			add_location(div4, file, 22, 12, 636);
    			attr_dev(div5, "class", "actions svelte-15yz0wi");
    			add_location(div5, file, 31, 16, 1266);
    			attr_dev(div6, "class", "actions-container svelte-15yz0wi");
    			add_location(div6, file, 28, 12, 1081);
    			attr_dev(div7, "class", "info svelte-15yz0wi");
    			add_location(div7, file, 21, 8, 604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, img);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div4, div1);
    			append_dev(div1, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			mount_component(link0, div2, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			mount_component(link1, div3, null);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			mount_component(rating, div6, null);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			mount_component(actions, div5, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*song*/ 1 && img.src !== (img_src_value = "" + (/*song*/ ctx[0].art + "&thumb=22"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*song*/ 1 && img_alt_value !== (img_alt_value = "Image of " + /*song*/ ctx[0].name)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if ((!current || dirty & /*song*/ 1) && t1_value !== (t1_value = /*song*/ ctx[0].name + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*song*/ 1 && div1_title_value !== (div1_title_value = /*song*/ ctx[0].name)) {
    				attr_dev(div1, "title", div1_title_value);
    			}

    			const link0_changes = {};
    			if (dirty & /*song*/ 1) link0_changes.to = "artists/" + /*song*/ ctx[0].artist.id;
    			if (dirty & /*song*/ 1) link0_changes.title = /*song*/ ctx[0].artist.name;

    			if (dirty & /*$$scope, song*/ 5) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty & /*song*/ 1) link1_changes.to = "albums/" + /*song*/ ctx[0].album.id;
    			if (dirty & /*song*/ 1) link1_changes.title = /*song*/ ctx[0].album.name;

    			if (dirty & /*$$scope, song*/ 5) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const rating_changes = {};
    			if (dirty & /*song*/ 1) rating_changes.id = /*song*/ ctx[0].id;
    			if (dirty & /*song*/ 1) rating_changes.rating = /*song*/ ctx[0].rating;
    			if (dirty & /*song*/ 1) rating_changes.flag = /*song*/ ctx[0].flag;
    			if (dirty & /*song*/ 1) rating_changes.averageRating = /*song*/ ctx[0].averagerating;
    			rating.$set(rating_changes);
    			const actions_changes = {};
    			if (dirty & /*song*/ 1) actions_changes.id = /*song*/ ctx[0].id;
    			if (dirty & /*song*/ 1) actions_changes.albumID = /*song*/ ctx[0].album.id;
    			if (dirty & /*song*/ 1) actions_changes.artistID = /*song*/ ctx[0].artist.id;
    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(rating.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(rating.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div7);
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(rating);
    			destroy_component(actions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(17:4) {#if song}",
    		ctx
    	});

    	return block;
    }

    // (25:36) <Link to="artists/{song.artist.id}" title="{song.artist.name}">
    function create_default_slot_1(ctx) {
    	let svgartist;
    	let t0;
    	let t1_value = /*song*/ ctx[0].artist.name + "";
    	let t1;
    	let current;

    	svgartist = new Artist$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgartist.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgartist, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*song*/ 1) && t1_value !== (t1_value = /*song*/ ctx[0].artist.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgartist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgartist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgartist, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(25:36) <Link to=\\\"artists/{song.artist.id}\\\" title=\\\"{song.artist.name}\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:35) <Link to="albums/{song.album.id}" title="{song.album.name}">
    function create_default_slot(ctx) {
    	let svgalbum;
    	let t0;
    	let t1_value = /*song*/ ctx[0].album.name + "";
    	let t1;
    	let current;

    	svgalbum = new Album$1({
    			props: { class: "inline" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svgalbum.$$.fragment);
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			mount_component(svgalbum, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*song*/ 1) && t1_value !== (t1_value = /*song*/ ctx[0].album.name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgalbum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgalbum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svgalbum, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(26:35) <Link to=\\\"albums/{song.album.id}\\\" title=\\\"{song.album.name}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*song*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "song-card svelte-15yz0wi");
    			add_location(div, file, 15, 0, 372);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SongCard", slots, []);
    	let { data = null } = $$props;
    	let song;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SongCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		Link,
    		Rating,
    		Actions,
    		SVGArtist: Artist$1,
    		SVGAlbum: Album$1,
    		data,
    		song
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("song" in $$props) $$invalidate(0, song = $$props.song);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2) {
    			$$invalidate(0, song = data);
    		}
    	};

    	return [song, data];
    }

    class SongCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { data: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongCard",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get data() {
    		throw new Error("<SongCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SongCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var songCard = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': SongCard
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
